{"title":"面试总结 10-14.md","slug":"面试总结10-14","date":"2021-10-14","updated":"2021-10-14","comments":true,"path":"api/posts/33370.json","excerpt":"<p> 今天面试官问的是基础问题加场景题和项目问题 </p>","cover":null,"covers":null,"content":"<p>今天面试官问的是基础问题加场景题和项目问题 </p><a id=\"more\"></a><h2 id=\"题目\"><a class=\"headerlink\" href=\"# 题目\"></a> 题目 </h2><h3 id=\"自我介绍\"><a class=\"headerlink\" href=\"# 自我介绍\"></a> 自我介绍 </h3><h3 id=\"项目问题\"><a class=\"headerlink\" href=\"# 项目问题\"></a> 项目问题 </h3><ul><li> 前后端接口 </li><li>axios 的使用</li><li>GET、POST 有什么区别</li></ul><p> 应用场景：GET 请求是幂等的 (就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的), 一般 GET 请求不会对服务器资源产生影响的场景，比如说请求一个网页的资源，而 POST 不是一个幂等的请求，一般用于对服务器资源会产生影响，比如说注册用户这一类的操作</p><p> 是否缓存：浏览器会对 GET 请求缓存，很少对 POST 请求缓存 </p><p> 发送的报文格式：GET 请求的报文中实体部分为空，POST 请求的报文中的实体部分是向服务器请求的数据 </p><h3 id=\"用 js 实现修改一个元素的颜色\"><a class=\"headerlink\" href=\"# 用 js 实现修改一个元素的颜色\"></a> 用 js 实现修改一个元素的颜色 </h3><h3 id=\"怎么使用 flex 布局实现垂直水平居中\"><a class=\"headerlink\" href=\"# 怎么使用 flex 布局实现垂直水平居中\"></a> 怎么使用 flex 布局实现垂直水平居中 </h3><h3 id=\"一个 div 下有 8 个 div- 没有类名和 ID-，怎么使 8 个 div 的颜色变成红色\"><a class=\"headerlink\" href=\"# 一个 div 下有 8 个 div- 没有类名和 ID-，怎么使 8 个 div 的颜色变成红色\"></a> 一个 div 下有 8 个 div(没有类名和 ID)，怎么使 8 个 div 的颜色变成红色 </h3><h3 id=\"对象怎么添加属性\"><a class=\"headerlink\" href=\"# 对象怎么添加属性\"></a> 对象怎么添加属性 </h3><h3 id=\"两个数组怎么合并\"><a class=\"headerlink\" href=\"# 两个数组怎么合并\"></a> 两个数组怎么合并 </h3><h3 id=\"数组中常见的方法\"><a class=\"headerlink\" href=\"# 数组中常见的方法\"></a> 数组中常见的方法 </h3><h3 id=\"数组中 slice 的用法\"><a class=\"headerlink\" href=\"# 数组中 slice 的用法\"></a> 数组中 slice 的用法 </h3><h3 id=\"数组中的 splice 的用法\"><a class=\"headerlink\" href=\"# 数组中的 splice 的用法\"></a> 数组中的 splice 的用法 </h3><h3 id=\"块级元素有哪些\"><a class=\"headerlink\" href=\"# 块级元素有哪些\"></a> 块级元素有哪些 </h3><h3 id=\"es6 的新特性你用过哪些\"><a class=\"headerlink\" href=\"#es6 的新特性你用过哪些\"></a>es6 的新特性你用过哪些</h3><h3 id=\"promise 的用法\"><a class=\"headerlink\" href=\"#promise 的用法\"></a>promise 的用法</h3><h3 id=\"了解过 storage 吗\"><a class=\"headerlink\" href=\"# 了解过 storage 吗\"></a> 了解过 storage 吗 </h3><h3 id=\"文本超出内容该怎么隐藏\"><a class=\"headerlink\" href=\"# 文本超出内容该怎么隐藏\"></a> 文本超出内容该怎么隐藏 </h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span> 文本超出隐藏 <span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        * &#123;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"css\">        <span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\">            width: 100px;</span><br><span class=\"line\">            height: 100px;</span><br><span class=\"line\"><span class=\"css\">            <span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:2px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">red</span>;</span></span><br><span class=\"line\">            overflow: hidden;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> 我们是才华横溢的设计师， 也是勤勤恳恳的木匠，要能用上帝视角凌空俯视，也能回到现实操盘世界 <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id=\"其他题目\"><a class=\"headerlink\" href=\"# 其他题目\"></a> 其他题目 </h3><h3 id=\"首个共同祖先\"><a class=\"headerlink\" href=\"# 首个共同祖先\"></a><a href=\"https://leetcode-cn.com/problems/first-common-ancestor-lcci/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\"> 首个共同祖先 </a></h3><p> 设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p><h3 id=\"01 串\"><a class=\"headerlink\" href=\"#01 串\"></a>01 串 </h3><h3 id=\"res 加密算法不是基于 hash，md5、sha 是基于 hash\"><a class=\"headerlink\" href=\"#res 加密算法不是基于 hash，md5、sha 是基于 hash\"></a>res 加密算法不是基于 hash，md5、sha 是基于 hash.</h3><h3 id=\"Vue 如何实现双向绑定的\"><a class=\"headerlink\" href=\"#Vue 如何实现双向绑定的\"></a>Vue 如何实现双向绑定的</h3><h3 id=\"proxy 好在哪里\"><a class=\"headerlink\" href=\"#proxy 好在哪里\"></a>proxy 好在哪里</h3><h3 id=\"聊一聊脏检查\"><a class=\"headerlink\" href=\"# 聊一聊脏检查\"></a> 聊一聊脏检查 </h3><h3 id=\"js 中判断数据类型的方法\"><a class=\"headerlink\" href=\"#js 中判断数据类型的方法\"></a>js 中判断数据类型的方法</h3><ul><li>typeof</li></ul><p>typeof 是一个操作符，其右侧跟着一个一元表达式，并返回这个表达式的数据类型，返回的结果是一个字符串。</p><p> 对于基本类型，除了 null 返回 object 外均有效。</p><p>对于引用类型，除了 function 返回 function 外，一律范围 object。</p><p>其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。</p><ul><li>instanceof</li></ul><p>instanceof 判断 A 是否为 B 的实例，表达式为 A instanceof B，如果 A 是 B 的实例 ，则返回 true，否则返回 false。instanceof 检查的是 <strong> 原型 </strong></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">instanceof</span> (a, b) = &#123;</span><br><span class=\"line\">    val l = a.__proto__;</span><br><span class=\"line\">    val r = b.__proto__;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。instanceof 在不同的全局环境下无效</strong></p><p> 针对数组，es5 中有 Array.isArray()的方式，本质上是检测对象的 [[class]],[[class]] 包含了对象的类型信息。</p><ul><li>constructor</li></ul><p>当一个函数 F 被定义时，JS 引擎会为 F 添加 prototype 原型，然后再在 prototype 上添加一个 constructor 属性，并让其指向 F 的引用。</p><p>当执行 var f = new F() 时，F 被当成了构造函数，f 是 F 的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F。</p><p>可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><ol><li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p></li><li><p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p></li></ol><ul><li>toString</li></ul><p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p><p>对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p><h3 id=\"判断数组的方法有哪些\"><a class=\"headerlink\" href=\"# 判断数组的方法有哪些\"></a>判断数组的方法有哪些 </h3><p>object.prototype.toString.call()</p><p> 原型链 </p><p>Array.isArray()</p><p>instanceof</p><p>Array.prototype.isPrototypeOf</p><h3 id=\"操作符的强制转化规则\"><a class=\"headerlink\" href=\"# 操作符的强制转化规则\"></a>== 操作符的强制转化规则</h3><p> 对于 == 来说，如果双方的类型不太一样，就会类型转化，流程如下。</p><p>1. 首先判断两者的类型是否相同，相同这比较两者的大小。</p><p>2. 类型不同的话，就会进行类型转换。</p><p>3. 会判断是否在对比 null 和 undefined，是的话就返回 true。</p><p>4. 判断两者类型是否为 string 和 number，是的话就会把字符串转成 number。</p><p>5. 一方是否为 boolean，就会把 boolean 转成 number，再进行判断 </p><p>6. 判断一方是否为 object 且另一方为 string、number、symbol，</p><p> 正常情况下调用 toString()方法，有运算操作符的时候先调用 valueOf()方法再调用 toString()方法。</p><h3 id=\"其他值转化布尔类型的转化规则\"><a class=\"headerlink\" href=\"# 其他值转化布尔类型的转化规则\"></a>其他值转化布尔类型的转化规则 </h3><p> 以下为假值 </p><p>undefined、null、false、+0、-0、NaN、&quot;&quot;</p><p> 其他为真值 </p><h3 id=\"object-is- 与比较操作符的区别\"><a class=\"headerlink\" href=\"#object-is- 与比较操作符的区别\"></a><a href=\"http://object.is\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">object.is</a>() 与比较操作符的区别 </h3><p> 使用双等号 (==) 进行相等判断，如果两边的类型不一样则会强制类型转化。</p><p>使用三等号 (===) 进行相等判断，如果两边的类型不一样不会做强制类型转化，直接返回 false。</p><p>使用 object.is 来判断相等，一般情况下和三等号的情况相等，特殊情况 +0、-0 不在相等，两个 NaN 是相等的。</p><h3 id=\"es6 的扩展运算符 -…\"><a class=\"headerlink\" href=\"#es6 的扩展运算符 -…\"></a>es6 的扩展运算符 (…)</h3><p> 对象中的扩展运算符 (…) 用于取出参数对象中的所有可遍历的属性拷贝到当前对象中。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let bar &#x3D; &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">let baz &#x3D; &#123; ...bar &#125;; &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let bar &#x3D; &#123; a: 1, b: 2 &#125;;</span><br><span class=\"line\">let baz &#x3D; Object.assign(&#123;&#125;, bar); &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure><p>Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><p>Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><h3 id=\"如果 new 一个箭头函数会怎么样\"><a class=\"headerlink\" href=\"# 如果 new 一个箭头函数会怎么样\"></a>如果 new 一个箭头函数会怎么样 </h3><p> 箭头函数是 es6 中提出来的，它没有 prototype, 也没有自己的 this 指向，更不可以使用 arguments 参数，所以不能 new 一个箭头函数。</p><p>new 操作符的实现步骤如下:</p><ul><li>创建一个对象 </li><li> 将构造函数的作用域赋给新对象，也就是将对象的 proto 属性指向构造函数的 prototype 属性 </li><li> 指向构造函数中的代码，构造函数中的 this 指向该对象，为这个对象添加属性和方法 </li><li> 返回新的对象 </li></ul><p> 由上可知第二、三步，箭头函数都是没办法执行的。</p><h3 id=\"箭头函数与普通函数有什么区别\"><a class=\"headerlink\" href=\"# 箭头函数与普通函数有什么区别\"></a>箭头函数与普通函数有什么区别 </h3><p> 箭头函数比普通函数更加简洁 </p><p> 箭头函数没有自己的 this(在定义的时候就确定了)</p><p>箭头函数继承来的 this 指向永远不会改变 (及不能 new 一个箭头函数，因为 new 可以改变 this 的指向)</p><p>call()、apply()、bind() 等方法不能改变 this 的指向 </p><p> 箭头函数不能作为构造函数使用 </p><p> 箭头没有自己的 arguments 对象，在箭头函数中访问 arguments 实际上获得是它外层 函数的 arguments 值 </p><p> 箭头函数没有自己的 prototype</p><p>箭头函数不能 作为 generator 函数，不能用 yeild 的关键字 </p><h3 id=\"arguments\"><a class=\"headerlink\" href=\"#arguments\"></a>arguments</h3><p>1.arguments 对象和 Function 是分不开的。</p><p>2. 因为 arguments 这个对象不能显式创建。</p><p>3.arguments 对象只有函数开始时才可用。</p><p>arguments 对象并不是一个数组（类数组），但是访问单个参数的方式与访问数组元素的方式相同</p><h3 id=\"generator\"><a class=\"headerlink\" href=\"#generator\"></a>generator</h3><p>generator（生成器）是 ES6 标准引入的新的数据类型。一个 generator 看上去像一个函数，但可以返回多次。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">n</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; a) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">        i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> value = n(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value.next());    <span class=\"comment\">//&#123;value: 0, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value.next());    <span class=\"comment\">//&#123;value: 1, done: false&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(value.next());    <span class=\"comment\">//&#123;value: 2, done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id=\"yield\"><a class=\"headerlink\" href=\"#yield\"></a>yield</h3><p>yield 是 ES6 的新关键字，使生成器函数执行暂停，yield 关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的 return 关键字。<br>yield 关键字实际返回一个 IteratorResult（迭代器）对象，它有两个属性，value 和 done，分别代表返回值和是否完成。<br>yield 无法单独工作，需要配合 generator(生成器) 的其他函数，如 next，懒汉式操作，展现强大的主动控制特性。</p><h3 id=\"es6 处理字符串的方法\"><a class=\"headerlink\" href=\"#es6 处理字符串的方法\"></a>es6 处理字符串的方法 </h3><ul><li> 模板字符串 </li></ul><p> 在模板字符串中空格、缩进、换行都能被保留下 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'css'</span>   </span><br><span class=\"line\"><span class=\"keyword\">var</span> career = <span class=\"string\">'coder'</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span> hobby = [<span class=\"string\">'coding'</span>, <span class=\"string\">'writing'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> finalString = <span class=\"string\">`my name is <span class=\"subst\">$&#123;name&#125;</span>, I work as a <span class=\"subst\">$&#123;career&#125;</span> I love <span class=\"subst\">$&#123;hobby[<span class=\"number\">0</span>]&#125;</span> and <span class=\"subst\">$&#123;hobby[<span class=\"number\">1</span>]&#125;</span>`</span></span><br></pre></td></tr></table></figure><ul><li>includes</li></ul><p> 用来判断字符串与子串的包含关系 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> son = <span class=\"string\">'haha'</span> </span><br><span class=\"line\"><span class=\"keyword\">const</span> father = <span class=\"string\">'xixi haha hehe'</span></span><br><span class=\"line\">father.includes(son) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><ul><li>startsWith</li></ul><p> 判断字符串是否以某个 / 串字符串开头 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> father = <span class=\"string\">'xixi haha hehe'</span></span><br><span class=\"line\">father.startsWith(<span class=\"string\">'haha'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">father.startsWith(<span class=\"string\">'xixi'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><ul><li>endWith</li></ul><p> 判断字符串是否以某个 / 串字符串结尾 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> father = <span class=\"string\">'xixi haha hehe'</span></span><br><span class=\"line\">father.endsWith(<span class=\"string\">'hehe'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><ul><li>repeat</li></ul><p> 可以使用同一个字符串输出多次</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sourceCode = <span class=\"string\">'repeat for 3 times;'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> repeated = sourceCode.repeat(<span class=\"number\">3</span>) </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(repeated) <span class=\"comment\">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br></pre></td></tr></table></figure>","url":"/posts/33370/","min2read":10,"word4post":"2.7k","prev_post":{"title":"axios 封装及处理","url":"/posts/47662/"},"next_post":{"title":"面试总结 10-13","url":"/posts/13632/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"题目\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\"> 题目 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"自我介绍\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\"> 自我介绍 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"项目问题\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\"> 项目问题 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"用 js 实现修改一个元素的颜色\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\"> 用 js 实现修改一个元素的颜色 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"怎么使用 flex 布局实现垂直水平居中\" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\"> 怎么使用 flex 布局实现垂直水平居中 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"一个 div 下有 8 个 div- 没有类名和 ID-，怎么使 8 个 div 的颜色变成红色\" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\"> 一个 div 下有 8 个 div(没有类名和 ID)，怎么使 8 个 div 的颜色变成红色 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"对象怎么添加属性\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\"> 对象怎么添加属性 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"两个数组怎么合并\" href = \"#\"><span class=\"toc-number\">1.7.</span> <span class=\"toc-text\"> 两个数组怎么合并 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数组中常见的方法\" href = \"#\"><span class=\"toc-number\">1.8.</span> <span class=\"toc-text\"> 数组中常见的方法 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数组中 slice 的用法\" href = \"#\"><span class=\"toc-number\">1.9.</span> <span class=\"toc-text\"> 数组中 slice 的用法 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"数组中的 splice 的用法\" href = \"#\"><span class=\"toc-number\">1.10.</span> <span class=\"toc-text\"> 数组中的 splice 的用法 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"块级元素有哪些\" href = \"#\"><span class=\"toc-number\">1.11.</span> <span class=\"toc-text\"> 块级元素有哪些 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"es6 的新特性你用过哪些\" href = \"#\"><span class=\"toc-number\">1.12.</span> <span class=\"toc-text\">es6 的新特性你用过哪些</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"promise 的用法\" href = \"#\"><span class=\"toc-number\">1.13.</span> <span class=\"toc-text\">promise 的用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"了解过 storage 吗\" href = \"#\"><span class=\"toc-number\">1.14.</span> <span class=\"toc-text\"> 了解过 storage 吗 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"文本超出内容该怎么隐藏\" href = \"#\"><span class=\"toc-number\">1.15.</span> <span class=\"toc-text\"> 文本超出内容该怎么隐藏 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"其他题目\" href = \"#\"><span class=\"toc-number\">1.16.</span> <span class=\"toc-text\"> 其他题目 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"首个共同祖先\" href = \"#\"><span class=\"toc-number\">1.17.</span> <span class=\"toc-text\"> 首个共同祖先 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"01 串\" href = \"#\"><span class=\"toc-number\">1.18.</span> <span class=\"toc-text\">01 串 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"res 加密算法不是基于 hash，md5、sha 是基于 hash\" href = \"#\"><span class=\"toc-number\">1.19.</span> <span class=\"toc-text\">res 加密算法不是基于 hash，md5、sha 是基于 hash.</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Vue 如何实现双向绑定的\" href = \"#\"><span class=\"toc-number\">1.20.</span> <span class=\"toc-text\">Vue 如何实现双向绑定的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"proxy 好在哪里\" href = \"#\"><span class=\"toc-number\">1.21.</span> <span class=\"toc-text\">proxy 好在哪里</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"聊一聊脏检查\" href = \"#\"><span class=\"toc-number\">1.22.</span> <span class=\"toc-text\"> 聊一聊脏检查 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"js 中判断数据类型的方法\" href = \"#\"><span class=\"toc-number\">1.23.</span> <span class=\"toc-text\">js 中判断数据类型的方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"判断数组的方法有哪些\" href = \"#\"><span class=\"toc-number\">1.24.</span> <span class=\"toc-text\">判断数组的方法有哪些 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"操作符的强制转化规则\" href = \"#\"><span class=\"toc-number\">1.25.</span> <span class=\"toc-text\">&#x3D;&#x3D; 操作符的强制转化规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"其他值转化布尔类型的转化规则\" href = \"#\"><span class=\"toc-number\">1.26.</span> <span class=\"toc-text\">其他值转化布尔类型的转化规则 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"object-is- 与比较操作符的区别\" href = \"#\"><span class=\"toc-number\">1.27.</span> <span class=\"toc-text\">object.is() 与比较操作符的区别 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"es6 的扩展运算符 -…\" href = \"#\"><span class=\"toc-number\">1.28.</span> <span class=\"toc-text\">es6 的扩展运算符 (…)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"如果 new 一个箭头函数会怎么样\" href = \"#\"><span class=\"toc-number\">1.29.</span> <span class=\"toc-text\">如果 new 一个箭头函数会怎么样 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"箭头函数与普通函数有什么区别\" href = \"#\"><span class=\"toc-number\">1.30.</span> <span class=\"toc-text\">箭头函数与普通函数有什么区别 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"arguments\" href = \"#\"><span class=\"toc-number\">1.31.</span> <span class=\"toc-text\">arguments</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"generator\" href = \"#\"><span class=\"toc-number\">1.32.</span> <span class=\"toc-text\">generator</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"yield\" href = \"#\"><span class=\"toc-number\">1.33.</span> <span class=\"toc-text\">yield</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"es6 处理字符串的方法\" href = \"#\"><span class=\"toc-number\">1.34.</span> <span class=\"toc-text\">es6 处理字符串的方法 </span></a></li></ol></li></ol>","categories":[{"name":"面经","path":"api/categories/面经.json","url":"/categories/面经/"}],"tags":[{"name":"面经","path":"api/tags/面经.json","url":"/tags/面经/"}]}