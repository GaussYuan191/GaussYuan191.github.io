{"title":"传统 diff 与 diff 优化","slug":"传统diff与diff优化","date":"2022-02-10","updated":"2022-02-10","comments":true,"path":"api/posts/49936.json","excerpt":"<p></p>","cover":"/gallery/nor-diff-01.jpeg","covers":["/gallery/nor-diff-01.jpeg"],"content":"<p><img src=\"/gallery/nor-diff-01.jpeg\" alt=\"\"></p><a id=\"more\"></a><h1 id=\" 传统的 diff\"><a class=\"headerlink\"href=\"# 传统的 diff\"></a>传统的 diff</h1><p>计算两颗树形结构差异并进行转换，传统 diff 算法是这样做的：循环递归每一个节点 </p><p><img src=\"/gallery/nor-diff-02.webp\"alt=\"\"></p><p> 比如说左侧的树会依次和右侧的树比较，时间复杂度为 O(n<sup>2), 找到不同后，还需要对不同的地方做出处理，时间复杂度为 O(n), 所以总的时间复杂度为 O(n</sup>3)，非常消耗性能 </p><h1 id=\"diff 的优化\"><a class=\"headerlink\" href=\"#diff 的优化\"></a>diff 的优化</h1><ul><li> 只比较同一层，不跨级比较</li><li>tag 不相同，则会直接删除重建，不做深度比较</li><li>tag 和 key 都相同，则认为其为相同的节点，不再深度比较</li></ul>","url":"/posts/49936/","min2read":"1","word4post":162,"prev_post":{"title":"Reflect 对象解析","url":"/posts/60673/"},"next_post":{"title":"详解 js 继承","url":"/posts/31746/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\" 传统的 diff\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">传统的 diff</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"diff 的优化\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">diff 的优化</span></a></li></ol>","categories":[{"name":"总结","path":"api/categories/总结.json","url":"/categories/总结/"}],"tags":[{"name":"diff","path":"api/tags/diff.json","url":"/tags/diff/"}]}