{"title":"详解 js 继承","slug":"详解js继承","date":"2022-02-08","updated":"2022-02-08","comments":true,"path":"api/posts/31746.json","excerpt":"<p></p>","cover":"/gallery/js-extend-01.png","covers":["/gallery/js-extend-01.png"],"content":"<p><img src=\"/gallery/js-extend-01.png\" alt=\"\"></p><a id=\"more\"></a><h1 id=\" 预备知识 \"><a class=\"headerlink\"href=\"# 预备知识 \"></a>预备知识 </h1><h1 id=\"1、构造函数属性 \"><a class=\"headerlink\"href=\"#1、构造函数属性 \"></a>1、构造函数属性</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// 实例基本的属性（该属性，强调私有，不共享）</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>] <span class=\"comment\">// 实例引用属性（该属性，强调私有，不共享）</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例引用属性吗，强调共享</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"2、什么是原型对象 \"><a class=\"headerlink\"href=\"#2、什么是原型对象 \"></a>2、什么是原型对象</h2><p> 简单来说，每个函数都有 prototype 属性，它就是原型对象，通过函数实例化出来的对象有个 **<strong>proto</strong>** 属性，指向原型对象 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\">a.__proto__ == A.prototype</span><br><span class=\"line\"><span class=\"comment\">// prototype 的结构如下</span></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: A</span><br><span class=\"line\">    ... 其他属性和方法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"3、原型链 \"><a class=\"headerlink\"href=\"#3、原型链 \"></a>3、原型链</h2><p> 每个对象都有原型，当访问这个变量的时候，这个变量不存在就访问他的原型，就这样一直循环下去就产生了原型链！</p><p><img src=\"/gallery/js-extend-02.png\"alt=\"\"></p><p>首先，fn 的构造函数是 Foo()。所以：<br>fn._ _ proto _ <em>=== Foo.prototype<br>又因为 Foo.prototype 是一个普通的对象，它的构造函数是 Object，所以：<br>Foo.prototype.</em> _ proto _ _=== Object.prototype<br>通过上面的代码，我们知道这个 toString()方法是在 Object.prototype 里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到 null 为止。</p><p>所以当 fn 调用 toString()时，JS 发现 fn 中没有这个方法，于是它就去 Foo.prototype 中去找，发现还是没有这个方法，然后就去 Object.prototype 中去找，找到了，就调用 Object.prototype 中的 toString()方法。</p><p>这就是原型链，fn 能够调用 Object.prototype 中的方法正是因为存在原型链的机制。</p><p>另外，在使用原型的时候，一般推荐将需要扩展的方法写在构造函数的 prototype 属性中，避免写在_ _ proto _ _属性里面。</p><h2 id=\"4、原型对象的作用\"><a class=\"headerlink\" href=\"#4、原型对象的作用\"></a>4、原型对象的作用 </h2><p> 原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通的对象而已。并且所有的实例是共享同一个原型对象, 因此有别于实例方法或属性，原型对象仅一份。实例对象有很多份且实例属性和⽅法是独⽴的。在构造函数中：为了属性 (实例基本属性) 的私有性、以及⽅法 (实例引⽤属性) 的复⽤、共享。我们提倡：</p><ul><li>将属性封装在构造函数中 </li><li> 将方法定义在原型对象上 </li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name; <span class=\"comment\">// (该属性，强调私有，不共享)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">A.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义在原型对象上的⽅法 (强调复⽤，需要共享)</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 不推荐的写法：[原因](https://blog.csdn.net/kkkkkxiaofei/article/details/46474303)</span></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">  say: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h1 id=\"继承方式\"><a class=\"headerlink\" href=\"# 继承方式\"></a> 继承方式 </h1><h2 id=\"方式 1、原型链继承\"><a class=\"headerlink\" href=\"# 方式 1、原型链继承\"></a> 方式 1、原型链继承 </h2><p><strong> 核心：将父类实例作为子类的原型 </strong></p><p> 优点： 方法复用 </p><p>​ 由于方法定义在父类的原型上，复用了父类构造函数的方法。比如说 say 方法。</p><p> 缺点：</p><ul><li>创建子类的时候，不能向父类传递参数，比如说 name。</li><li>​ 子类实例共享了父类构造函数的引用属性，比如说 arr 属性。</li><li>​ 无法实现多继承（同时继承多个父类）</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"父亲\"</span>; <span class=\"comment\">// 实例基本属性(该属性，强调私有，不共享)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>]; <span class=\"comment\">//(该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将要复用，共享方法定义在父类原型上</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">like</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.like = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1. 原型链继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 核心</span></span><br><span class=\"line\">Child.prototype.constructor = Child; <span class=\"comment\">// 修正 constructor 指向</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"comment\">// 优点：共享了父类构造函数的 say 方法</span></span><br><span class=\"line\">boy1.say();</span><br><span class=\"line\">boy2.say();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.say === boy2.say); <span class=\"comment\">// hello , hello , true</span></span><br><span class=\"line\"><span class=\"comment\">// 缺点 1：不能向父类的构造函数传参</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.name, boy2.name, boy1.name == boy2.name);</span><br><span class=\"line\"><span class=\"comment\">// 缺点 2：子类实例共享了父类构造函数的应用属性，比如说 arr</span></span><br><span class=\"line\">boy1.arr.push(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy2.arr); <span class=\"comment\">// 注意修改 boy1 的 name，boy2 的 name 不影响</span></span><br><span class=\"line\"><span class=\"comment\">// 注意要修改 child 类实例的 constructor 的指向</span></span><br></pre></td></tr></table></figure><h2 id=\"方式 2、借用构造函数\"><a class=\"headerlink\" href=\"# 方式 2、借用构造函数\"></a> 方式 2、借用构造函数 </h2><p><strong> 核心：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</strong></p><p>优点：实例之间独立 </p><ul><li> 创建子类实例，可以向父类构造函数传递参数。</li><li>子类实例不共享父类构造函数中的应用属性，比如说 arr 属性 </li><li> 可以实现多继承（通过多个 call 或者 apply 继承多个父类）</li></ul><p>缺点：</p><ul><li>父类的方法不能复用 </li><li> 子类实例，继承不了父类原型上的属性（应为没有用到原型）</li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"父亲\"</span>; <span class=\"comment\">// 实例基本属性(该属性，强调私有，不共享)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>]; <span class=\"comment\">//(该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将要复用，共享方法定义在父类原型上</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, like</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 核心 拷贝了父类的实例属性和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.like = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"小红\"</span>, <span class=\"string\">\"apple\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"小明\"</span>, <span class=\"string\">\"orange\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 优点 1: 可向父类构造函数传参</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.name, boy2.name); <span class=\"comment\">// 小红 小明</span></span><br><span class=\"line\"><span class=\"comment\">// 优点 2: 不共享父类构造函数的引用类型</span></span><br><span class=\"line\">boy1.arr.push(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.arr, boy2.arr);</span><br><span class=\"line\"><span class=\"comment\">// 缺点 1：方法不能复用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.say === boy2.say);</span><br><span class=\"line\"><span class=\"comment\">// 缺点 2: 不能继承父类原型上的方法</span></span><br><span class=\"line\">boy1.say();   <span class=\"comment\">// boy1.say is not a function</span></span><br></pre></td></tr></table></figure><h2 id=\"方式 3、组合继承\"><a class=\"headerlink\" href=\"# 方式 3、组合继承\"></a> 方式 3、组合继承 </h2><p><strong> 核心：通过调用父类的构造函数，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数的复用。</strong></p><p>优点：</p><p>保留构造函数的优点：创建子类可以传递参数。</p><p>保留原型链的优点：父类的方法定义在父类的原型对象上，可以实现方法的复用。</p><p>不共享父类的应用属性。比如 arr 属性。</p><p>缺点：</p><p>由于调用了两次父类的构造方法，会存在一份多余的父类实例属性。</p><p>第⼀次 Parent.call(this); 从⽗类拷⻉⼀份⽗类实例属性，作为⼦类的实例属性，第⼆次 Child.prototype = new Parent(); 创建⽗类实例作为⼦类原型，Child.protype 中的⽗类属性和⽅法会被第⼀次拷⻉来的实例属性屏蔽掉，所以多余。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"父亲\"</span>; <span class=\"comment\">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>]; <span class=\"comment\">//(该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将要复用，共享方法定义在父类原型上</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, like</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 核心 拷贝了父类的实例属性和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.like = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent(); <span class=\"comment\">// 核心</span></span><br><span class=\"line\">Child.prototype.constructor = Child; <span class=\"comment\">// 修正 constructor 的指向</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"小红\"</span>, <span class=\"string\">\"apple\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"小明\"</span>, <span class=\"string\">\"orange\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优点 1: 可向父类构造函数传参</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.name, boy2.name); <span class=\"comment\">// 小红 小明</span></span><br><span class=\"line\"><span class=\"comment\">// 优点 2: 不共享父类构造函数的引用类型</span></span><br><span class=\"line\">boy1.arr.push(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.arr, boy2.arr);</span><br><span class=\"line\"><span class=\"comment\">// 优点 3：方法能复用</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.say === boy2.say);</span><br><span class=\"line\"><span class=\"comment\">// 优点 4: 能继承父类原型上的方法</span></span><br><span class=\"line\">boy1.say();</span><br><span class=\"line\"><span class=\"comment\">// 缺点 1：由于调⽤了 2 次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child.prototype.__proto__ === Parent.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Child.prototype);</span><br></pre></td></tr></table></figure><h2 id=\"方式 4、组合继承优化 1\"><a class=\"headerlink\" href=\"# 方式 4、组合继承优化 1\"></a> 方式 4、组合继承优化 1</h2><p><strong>核心：通过这种方式，砍掉父类的实例属性，这样在调用父类构造函数的时候，就不会初始化两次实例，</strong></p><p><strong>避免组合继承的缺点。</strong></p><p>优点：</p><ul><li>只调用一次父类构造函数。</li><li>保留构造函数的优点：创建子类实例，可以向父类构造函数传递参数。</li><li>保留原型链的优点 </li></ul><p> 缺点：</p><p>修正构造函数的指向后，父类实例的构造函数指向，同时也发生变化 </p><p> 原因是：不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"父亲\"</span>; <span class=\"comment\">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>]; <span class=\"comment\">//(该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将要复用，共享方法定义在父类原型上</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, like</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 核心 拷贝了父类的实例属性和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.like = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = Parent.prototype; <span class=\"comment\">// 核⼼ ⼦类原型和⽗类原型，实质上是同⼀个</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"><span class=\"comment\">// 缺点 1：当修复⼦类构造函数的指向后，⽗类实例的构造函数指向也会跟着变了。 没修复之前：</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.constructor); <span class=\"comment\">// Parent 修复代码：</span></span><br><span class=\"line\">Child.prototype.constructor = Child; <span class=\"comment\">// 修复之后：</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boy1.constructor); <span class=\"comment\">// Child</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.constructor); <span class=\"comment\">// Child 这⾥就是存在的问题(我们希望是 Parent) 具体原因：因为是通过原型来实现继承的，Child.prototype 的上⾯是没有 constructor 属性的， 就会往上找，这样就找到了 Parent.prototype 上⾯的 constructor 属性；当你修改了⼦类实例的 construtor 属性，所有的 constructor 的指向都会发⽣变化。</span></span><br></pre></td></tr></table></figure><h2 id=\"方式 5、组合寄生继承–完美方式\"><a class=\"headerlink\" href=\"# 方式 5、组合寄生继承–完美方式\"></a> 方式 5、组合寄生继承–完美方式 </h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"父亲\"</span>; <span class=\"comment\">// 实例基本属性(该属性，强调私有，不共享)</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.arr = [<span class=\"number\">1</span>]; <span class=\"comment\">//(该属性，强调私有)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将要复用，共享方法定义在父类原型上</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 子类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, like</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// 核心 拷贝了父类的实例属性和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.like = like;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 核⼼ 通过创建中间对象，⼦类原型和⽗类原型，就会隔离开。不是同⼀个啦，有效避免了⽅式 4 的缺点。</span></span><br><span class=\"line\">Child.prototype = <span class=\"built_in\">Object</span>.create(Parent.prototype);</span><br><span class=\"line\"><span class=\"comment\">// 这⾥是修复构造函数指向的代码</span></span><br><span class=\"line\">Child.prototype.constructor = Child;</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"⼩红\"</span>, <span class=\"string\">\"apple\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> boy2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"⼩明\"</span>, <span class=\"string\">\"orange\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> Parent(<span class=\"string\">\"⼩爸爸\"</span>);</span><br></pre></td></tr></table></figure><h2 id=\"为什么要修正 constructor 的指向\"><a class=\"headerlink\" href=\"# 为什么要修正 constructor 的指向\"></a> 为什么要修正 constructor 的指向 </h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"eat\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Woman</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dance = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">\"dance\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Woman.prototype = <span class=\"keyword\">new</span> People();</span><br><span class=\"line\">Women.prototype.constructor = Women;</span><br></pre></td></tr></table></figure><p>1、不更正 constructor 的情形</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> man;</span><br><span class=\"line\"><span class=\"keyword\">var</span> gril;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">\"eat\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Woman</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dance = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">\"dance\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Woman.prototype = <span class=\"keyword\">new</span> People();</span><br><span class=\"line\">    <span class=\"comment\">//Women.prototype.constructor = Women;// 不更正</span></span><br><span class=\"line\">    People.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    man = <span class=\"keyword\">new</span> People(<span class=\"string\">\"lili\"</span>);</span><br><span class=\"line\">    gril = <span class=\"keyword\">new</span> Women();</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">man.constructor.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gril.constructor.prototype.sayLove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love u\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gril.sayHi();<span class=\"comment\">//\"hi\"</span></span><br><span class=\"line\">gril.sayLove();<span class=\"comment\">//\"i love u\"</span></span><br><span class=\"line\">man.sayHi();<span class=\"comment\">//\"hi\"\t\t</span></span><br><span class=\"line\">man.sayLove();<span class=\"comment\">//\"i love u\"   (不应该添加到 People 类)</span></span><br></pre></td></tr></table></figure><p> 可以看到，这里给父类添加了方法 sayHi，给子类添加了方法 sayLove，但是并未更正 constructor 的时候，没有达到我们想要的效果，把 sayLove 也添加到了父类 people 中，这是因为存在如下的关系 </p><p><img src=\"/gallery/js-extend-03.png\" alt=\"\"></p><p> 可以看出，gril.constructor.prototype = man.constructor.protype=People.prototype，所以 sayLove 被添加到父类 People 中也是情理之中的了。</p><p>2、更正后 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> man;</span><br><span class=\"line\"><span class=\"keyword\">var</span> gril;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">People</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">\"eat\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Woman</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dance = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"string\">\"dance\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Woman.prototype = <span class=\"keyword\">new</span> People();</span><br><span class=\"line\">    Women.prototype.constructor = Women;<span class=\"comment\">// 更正</span></span><br><span class=\"line\">    People.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    man = <span class=\"keyword\">new</span> People(<span class=\"string\">\"lili\"</span>);</span><br><span class=\"line\">    gril = <span class=\"keyword\">new</span> Women();</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">man.constructor.prototype.sayHi = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"hi\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gril.constructor.prototype.sayLove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love u\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">gril.sayHi();<span class=\"comment\">//\"hi\"</span></span><br><span class=\"line\">gril.sayLove();<span class=\"comment\">//\"i love u\"</span></span><br><span class=\"line\">man.sayHi();<span class=\"comment\">//\"hi\"</span></span><br><span class=\"line\">man.sayLove();<span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure><p> 现在我们的目的就实现啦！那么我们再来看看此时的原型图吧：</p><p><img src=\"/gallery/js-extend-04.png\"alt=\"\"></p><p>constructor 更正后就可以通过 child.constructor.prototype 在原型上添加方法了 </p><h1 id=\"其他问题\"><a class=\"headerlink\" href=\"# 其他问题\"></a> 其他问题 </h1><h2 id=\"1、Object-create-object-propertiesObject\"><a class=\"headerlink\" href=\"#1、Object-create-object-propertiesObject\"></a>1、Object.create(object, propertiesObject)</h2><p>Object.create()⽅法创建⼀个新对象，使⽤第⼀个参数来提供新创建对象的__proto__（以第⼀个参</p><p> 数作为新对象的构造函数的原型对象）； ⽅法还有第⼆个可选参数，是添加到新创建对象的属性，写法如下。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"built_in\">Object</span>.create(Person.prototype, &#123;</span><br><span class=\"line\">  age: &#123; <span class=\"attr\">value</span>: <span class=\"number\">12</span>, <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><ul><li>new 与 Object.create() 的区别？</li></ul><p>new 产⽣的实例，优先获取构造函数上的属性；构造函数上没有对应的属性，才会去原型上查找；</p><p>如果构造函数中以及原型中都没有对应的属性，就会报错。Object.create() 产⽣的对象，只会在原 </p><p> 型上进⾏查找属性，原型上没有对应的属性，就会报错。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Base1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o1 = <span class=\"keyword\">new</span> Base1();</span><br><span class=\"line\"><span class=\"keyword\">let</span> o2 = <span class=\"built_in\">Object</span>.create(Base1.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o1.a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o2.a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Base2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">Base2.prototype.a = <span class=\"string\">\"aa\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o3 = <span class=\"keyword\">new</span> Base2();</span><br><span class=\"line\"><span class=\"keyword\">let</span> o4 = <span class=\"built_in\">Object</span>.create(Base2.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o3.a); <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o4.a); <span class=\"comment\">// aa</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> Base3 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Base3.prototype.a = <span class=\"string\">\"aa\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o5 = <span class=\"keyword\">new</span> Base3();</span><br><span class=\"line\"><span class=\"keyword\">let</span> o6 = <span class=\"built_in\">Object</span>.create(Base3.prototype);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o5.a); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(o6.a); <span class=\"comment\">// aa</span></span><br></pre></td></tr></table></figure><h2 id=\"2、new 的过程\"><a class=\"headerlink\" href=\"#2、new 的过程\"></a>2、new 的过程 </h2><p> 创建新的对象（如 object）</p><p>将新的对象的–proto–指向构造函数的 prototype 对象 </p><p> 执行构造函数，为这个新对象添加属性，并将 this 指向创建的新对象 object</p><p>当构建函数本身返回值为对象时，返回该对象，否则返回新对象 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new</span>(<span class=\"params\">fn, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个空对象 obj, 并让其继承 fn.prototype</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.create(fn.prototype);</span><br><span class=\"line\">  <span class=\"comment\">// 执行构造函数，并让 this 指向创建的空对象 obj</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = fn.call(obj, ...args);</span><br><span class=\"line\">  <span class=\"comment\">// 当返回值为对象时，返回该对象，否则返回新的对象 obj</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> ? result : obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> ming = _new(Person, <span class=\"string\">\"小明\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(ming);</span><br></pre></td></tr></table></figure><p>Object.create 创建 obj, 使得 obj.<strong>proto</strong>==Fn.prototype</p><h2 id=\"3、为什么‘组合继承’这种方式，会执行两次父类函数\"><a class=\"headerlink\" href=\"#3、为什么‘组合继承’这种方式，会执行两次父类函数\"></a>3、为什么‘组合继承’这种方式，会执行两次父类函数</h2><ul><li> 第一次：new Parent()</li></ul><p>'new’的过程的第三步，其实就是执行父类的构造函数。</p><ul><li>第二次 Parent.call(this,name,like)</li></ul><p>call 的作⽤是改变函数执⾏时的上下⽂。⽐如：A.call(B)。其实，最终执⾏的还是 A 函数，只不过是</p><p>⽤B 来调⽤⽽已。所以，你就懂了 Parent.call(this,name,like) , 也就是执⾏了⽗类构造函数 Person。</p>","url":"/posts/31746/","min2read":14,"word4post":"3.4k","prev_post":{"title":"传统 diff 与 diff 优化","url":"/posts/49936/"},"next_post":{"title":"JS 中 == 与 ===","url":"/posts/33716/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\" 预备知识 \" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">预备知识 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"1、构造函数属性 \" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">1、构造函数属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"2、什么是原型对象 \" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\">2、什么是原型对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3、原型链 \" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">3、原型链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"4、原型对象的作用\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\">4、原型对象的作用 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"继承方式\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\"> 继承方式 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"方式 1、原型链继承\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 方式 1、原型链继承 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"方式 2、借用构造函数\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\"> 方式 2、借用构造函数 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"方式 3、组合继承\" href = \"#\"><span class=\"toc-number\">3.3.</span> <span class=\"toc-text\"> 方式 3、组合继承 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"方式 4、组合继承优化 1\" href = \"#\"><span class=\"toc-number\">3.4.</span> <span class=\"toc-text\"> 方式 4、组合继承优化 1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"方式 5、组合寄生继承–完美方式\" href = \"#\"><span class=\"toc-number\">3.5.</span> <span class=\"toc-text\"> 方式 5、组合寄生继承–完美方式 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"为什么要修正 constructor 的指向\" href = \"#\"><span class=\"toc-number\">3.6.</span> <span class=\"toc-text\"> 为什么要修正 constructor 的指向 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"其他问题\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\"> 其他问题 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"1、Object-create-object-propertiesObject\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\">1、Object.create(object, propertiesObject)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"2、new 的过程\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">2、new 的过程 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3、为什么‘组合继承’这种方式，会执行两次父类函数\" href = \"#\"><span class=\"toc-number\">4.3.</span> <span class=\"toc-text\">3、为什么‘组合继承’这种方式，会执行两次父类函数</span></a></li></ol></li></ol>","categories":[{"name":"继承","path":"api/categories/继承.json","url":"/categories/继承/"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json","url":"/tags/JavaScript/"}]}