{"title":"axios 封装及处理","slug":"axios封装及处理","date":"2021-10-14","updated":"2021-10-14","comments":true,"path":"api/posts/47662.json","excerpt":"<p></p>","cover":"/gallery/axios.jpg","covers":["/gallery/axios.jpg"],"content":"<p><img src=\"/gallery/axios.jpg\" alt=\"\"></p><a id=\"more\"></a><h1 id=\"axios 封装以处理 \"><a class=\"headerlink\"href=\"#axios 封装以处理 \"></a>axios 封装以处理 </h1><h3 id=\" 接口封装必要性 \"><a class=\"headerlink\"href=\"# 接口封装必要性 \"></a> 接口封装必要性 </h3><p> 在大型前端项目中，当有很多接口实现数据输入、流出并附加拦截，结合状态管理，抵御 XSRF 攻击等时，统一管理 API 接口就成为大型前端项目必须面对的环节。axios 作为最流行的基于 Promise 的 HTTP 库可以同时运行在浏览器端和服务器端，已经成为大部分前端项目的首选。</p><h3 id=\"POST 序列化 \"><a class=\"headerlink\"href=\"#POST 序列化 \"></a>POST 序列化 </h3><p> 通过 <code>JSON.stringify</code> 我们同样可以实现序列化, 但是对于复杂 <code>ObjectJSON.stringify</code> 的支持行不如 <code>qs.stringify</code>。所以通过引入 qs 这个库，qs 可以帮我们对深层嵌套的 JSON 以及 Array 形式进行序列化，让我们的 API 封装兼容更多的场景。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'hehe'</span>,<span class=\"attr\">age</span>:<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"> qs.stringify(a)</span><br><span class=\"line\"><span class=\"comment\">//'name=hehe&amp;age=10'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(a)</span><br><span class=\"line\"><span class=\"comment\">//'&#123;\"name\":\"hehe\",\"age\":10&#125;'</span></span><br></pre></td></tr></table></figure><p> 例外：现在后台工程大多可以在 body 里面获取 json，array 等，某些情况下，可能后台是直接读取的字符串信息，这种情况下，qs.stringify 封装参数中的 JSON 以及 Array 格式无法获取，需要使用 <code>JSON.stringify</code> 去处理 </p><h3 id=\"axios- 对于配置的处理 \"><a class=\"headerlink\"href=\"#axios- 对于配置的处理 \"></a>axios 对于配置的处理</h3><p> 在正式进行 axios 二次封装之前，简单了解一下 axios 对于配置项的处理；可以从 axios 暴露出来的方法了解，可以在 axios.defaults 上配置 config，也可以在拦截器上以及新的 instance config 上去配置；通过阅读源码，发现其实 axios 的 config 配置是通过 merge 方法去实现的：</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.create = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">instanceConfig</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createInstance(mergeConfig(axios.defaults, instanceConfig));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>axios default 以及新的 instance 的 config 之外，也提供了初始化的默认 config；</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DEFAULT_CONTENT_TYPE = &#123;</span><br><span class=\"line\">  <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setContentTypeIfUnset</span>(<span class=\"params\">headers, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!utils.isUndefined(headers) &amp;&amp; utils.isUndefined(headers[<span class=\"string\">'Content-Type'</span>])) &#123;</span><br><span class=\"line\">    headers[<span class=\"string\">'Content-Type'</span>] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>axios 的 config 是这样一个逻辑：</p><p>1. 默认的初始化 config 与 defaultconfig 进行 merge</p><p>2. 将第一步得到的结果和新 instance 上的 config 进行 merge</p><p>通过分析，我们可以直接将请求的接口进行配置化处理，更方便的一步化适应各种场景 </p><h4 id=\"default-config\"><a class=\"headerlink\"href=\"#default-config\"></a>default config</h4><p>axios 给我提供了一个 default 系列的属性，可以直接向<code>axios.default</code> 的一些属性赋值，这个 <code>axios.default</code> 的赋值会作用给所用 axios 请求；官方文档给我提供了一些参考：比如设置默认的 baseURL，为基于 token 的请求把 token 放到 header 的 Authorization 中，以及设置 post 的请求类型；</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.baseURL = <span class=\"string\">'https://api.example.com'</span>;</span><br><span class=\"line\">axios.defaults.headers.common[<span class=\"string\">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><h4 id=\" 请求拦截以及响应拦截 \"><a class=\"headerlink\"href=\"# 请求拦截以及响应拦截 \"></a>请求拦截以及响应拦截 </h4><p> 作为一个出色的 http 请求库，axios 提供了强大请求拦截和响应拦截功能。</p><h5 id=\" 请求拦截 \"><a class=\"headerlink\"href=\"# 请求拦截 \"></a>请求拦截 </h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 vuex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'@/store'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">axios.interceptors.request.use(<span class=\"function\"><span class=\"params\">config</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将 token 添加到了 request 的 header 里面</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = store.state.token;</span><br><span class=\"line\">  config.headers.common[<span class=\"string\">'Authorization'</span>] = token</span><br><span class=\"line\">  <span class=\"comment\">// loading</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> config</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(error)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p> 通过拦截器可以实现请求的前置操作，例如，这里实现了比较常见的将 token 添加到 header 中。当然，在 default 中处理 token 也是可以的。所以网上大部分对拦截器的操作都是可以放到 defaults 中执行的，并没有什么区别；个人认为请求前拦截可以结合一些定时器已经前端监控相关插件的使用。</p><h5 id=\" 响应拦截 \"><a class=\"headerlink\"href=\"# 响应拦截 \"></a>响应拦截 </h5><p> 需要注意一下响应拦截的执行顺序，先执行 <code>axios.interceptors.response.use</code> 然后再执行正常的响应处理;</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 响应拦截器 </span></span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">    response =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的 response 返回的 HTTP 状态码为 2XX 的情况，可以在这里集中处理 200+JSON 形式中 JSON 中前后端约定的状态码</span></span><br><span class=\"line\">    &#125;,   </span><br><span class=\"line\">    <span class=\"comment\">// 这里的 error 返回的是 HTTP 状态码不是 2XX 的情况，可以在这里处理不同 HTTP 的 status</span></span><br><span class=\"line\">    error =&gt; &#123;            </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.response.status) &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (error.response.status) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">401</span>:                    </span><br><span class=\"line\">                <span class=\"comment\">// 未登录的处理              </span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">403</span>:</span><br><span class=\"line\">                <span class=\"comment\">// 权限不足的处理                </span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; </span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">              <span class=\"comment\">// 404 请求不存在的处理</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 其他错误，直接抛出错误提示</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"comment\">// 默认处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error.response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><h3 id=\"axios 完全配置化 \"><a class=\"headerlink\"href=\"#axios 完全配置化 \"></a>axios 完全配置化</h3><p> 通过上面对 axios 的具体 config 分析，我们可以通过增加 merge 结合封装方法来实现多种场景的配置；可以实现诸如，是否跨域携带 cookie，是否附带 loading，配置特殊接口的请求时常等待等 </p><p> 可以创建一个 config.js</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> configMap = &#123;</span><br><span class=\"line\">  defaultConfig: &#123;</span><br><span class=\"line\">    withCredentials: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    baseURL: path.baseUrl,</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      post: &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded; charset=UTF-8'</span> &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  long: &#123;</span><br><span class=\"line\">    timeout: <span class=\"number\">60000</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  nocookie: &#123;</span><br><span class=\"line\">    withCredentials: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure><p>通过在 httpjs 中引入 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> configMap <span class=\"keyword\">from</span> <span class=\"string\">'./config'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; showFullScreenLoading, tryHideFullScreenLoading &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./loading'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> merge <span class=\"keyword\">from</span> <span class=\"string\">'lodash.merge'</span></span><br><span class=\"line\">...</span><br><span class=\"line\">merge(axios.defaults, configMap[<span class=\"string\">'defaultConfig'</span>])</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleTypeString</span>(<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  type.toLowerCase().split(<span class=\"string\">'-'</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> merge(axios.defaults, configMap[item]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  post(url, data, type) &#123;</span><br><span class=\"line\">    handleTypeString(type)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">      method: <span class=\"string\">'post'</span>,</span><br></pre></td></tr></table></figure><p> 这样可以实现多个接口请求的配置组合，后面的会覆盖前面的，一个接一个，实现 axios 请求的完全配置化处理；</p><p>在 vue 中使用 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> http <span class=\"keyword\">from</span> <span class=\"string\">\"@/api/http\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> path <span class=\"keyword\">from</span> <span class=\"string\">\"@/api/path\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 配合 async await 更加优雅</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> test() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> http.post(path.test, params, <span class=\"string\">\"long-nocookie\"</span>);</span><br></pre></td></tr></table></figure><p> 有些人比较喜欢使用偏函数的方式再包装一层，也可以再增加封装一层使调用时候直接使用。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(param)</span><br></pre></td></tr></table></figure><h3 id=\" 全局 loading 状态的处理 \"><a class=\"headerlink\"href=\"# 全局 loading 状态的处理 \"></a>全局 loading 状态的处理 </h3><p> 封装 loading.js 来处理部分 url 请求接口需要 loading 菊花图的情况；需要设置 needLoadingCount 来记录处理多个需要 loading 请求接口处理的情况。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Loading &#125; <span class=\"keyword\">from</span> <span class=\"string\">'element-ui'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> loading; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startLoading</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 使用 Element loading.tart 方法 </span></span><br><span class=\"line\">  loading = Loading.service(&#123;</span><br><span class=\"line\">    lock: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    text: <span class=\"string\">'loading……'</span>,</span><br><span class=\"line\">    background: <span class=\"string\">'rgba(0, 0, 0, 0.5)'</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">endLoading</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 使用 Element loading.close 方法</span></span><br><span class=\"line\">  loading.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过 needLoadingCount 来记录，在多个地方使用 loading 时候处理</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> needLoadingCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showLoading</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (needLoadingCount === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    startLoading();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  needLoadingCount++;<span class=\"comment\">//eslint-disable-line</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tryHideLoading</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (needLoadingCount &gt;= <span class=\"number\">0</span>) needLoadingCount--;<span class=\"comment\">//eslint-disable-line</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (needLoadingCount === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    endLoading();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 在 http 中配置 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (type === <span class=\"string\">'long'</span>) &#123;</span><br><span class=\"line\">  showFullScreenLoading()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(config).then(<span class=\"function\"><span class=\"params\">response</span>=&gt;</span>&#123;</span><br><span class=\"line\">     tryHideFullScreenLoading()</span><br><span class=\"line\">     rerurn response;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 其他无 loading 的 axios 请求</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> axios(config)</span><br></pre></td></tr></table></figure><h3 id=\" 多种环境切换的封装 \"><a class=\"headerlink\"href=\"# 多种环境切换的封装 \"></a> 多种环境切换的封装 </h3><p> 在前后端分离的 spa 场景下，axios 的 baseUrl 等各种环境参数是预先设定好的；然后打包成静态文件，上传到 nginx 或者 tomcat 类似的 http 服务器中，从本地开发到测试，提供静态文件给不同的后台去使用，可能不同后台设置的接口地址是不一样的，为了避免一个个的去打包，我们需要配置一个针对不同域名环境的封装；</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> merge <span class=\"keyword\">from</span> <span class=\"string\">'lodash.merge'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = &#123;</span><br><span class=\"line\">  baseUrl: <span class=\"string\">'http://localhost:3000'</span>,</span><br><span class=\"line\">  login: <span class=\"string\">'/users/login'</span>,</span><br><span class=\"line\">  test: <span class=\"string\">'/test'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> pathMap = &#123;</span><br><span class=\"line\">  <span class=\"string\">'http://localhost:3001'</span>: &#123; <span class=\"attr\">baseUrl</span>: <span class=\"string\">'http://localhost:3001'</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">'http://localhost:3002'</span>: &#123; <span class=\"attr\">baseUrl</span>: <span class=\"string\">'http://localhost:3002'</span>,<span class=\"attr\">login</span>:<span class=\"string\">'/login'</span> &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getClientIdByLocation = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; href &#125; = <span class=\"built_in\">window</span>.location;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> matchedKey = <span class=\"built_in\">Object</span>.keys(pathMap).filter(<span class=\"function\"><span class=\"params\">url</span> =&gt;</span> href.indexOf(url) &gt; <span class=\"number\">-1</span>);</span><br><span class=\"line\">  merge(path, pathMap[matchedKey])</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">getClientIdByLocation();</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> path;</span><br></pre></td></tr></table></figure><p>可以通过直接在 pathMap 中配置不同的 url 对应的 path 对象，来实现处理不同的 url 对应的 baseUrl 以及各种子路由情况不同时候的情况</p>","url":"/posts/47662/","min2read":7,"word4post":"1.8k","prev_post":{"title":"CSS 常见的布局","url":"/posts/3613/"},"next_post":{"title":"面试总结 10-14.md","url":"/posts/33370/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"axios 封装以处理 \" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">axios 封装以处理 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 接口封装必要性 \" href = \"#\"><span class=\"toc-number\">1.0.1.</span> <span class=\"toc-text\"> 接口封装必要性 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"POST 序列化 \" href = \"#\"><span class=\"toc-number\">1.0.2.</span> <span class=\"toc-text\">POST 序列化 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"axios- 对于配置的处理 \" href = \"#\"><span class=\"toc-number\">1.0.3.</span> <span class=\"toc-text\">axios 对于配置的处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"default-config\" href = \"#\"><span class=\"toc-number\">1.0.3.1.</span> <span class=\"toc-text\">default config</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 请求拦截以及响应拦截 \" href = \"#\"><span class=\"toc-number\">1.0.3.2.</span> <span class=\"toc-text\">请求拦截以及响应拦截 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" data-id=\" 请求拦截 \" href = \"#\"><span class=\"toc-number\">1.0.3.2.1.</span> <span class=\"toc-text\">请求拦截 </span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" data-id=\" 响应拦截 \" href = \"#\"><span class=\"toc-number\">1.0.3.2.2.</span> <span class=\"toc-text\">响应拦截 </span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"axios 完全配置化 \" href = \"#\"><span class=\"toc-number\">1.0.4.</span> <span class=\"toc-text\">axios 完全配置化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 全局 loading 状态的处理 \" href = \"#\"><span class=\"toc-number\">1.0.5.</span> <span class=\"toc-text\">全局 loading 状态的处理 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 多种环境切换的封装 \" href = \"#\"><span class=\"toc-number\">1.0.6.</span> <span class=\"toc-text\"> 多种环境切换的封装 </span></a></li></ol></li></ol></li></ol>","categories":[{"name":"网络请求","path":"api/categories/网络请求.json","url":"/categories/网络请求/"}],"tags":[{"name":"axios","path":"api/tags/axios.json","url":"/tags/axios/"}]}