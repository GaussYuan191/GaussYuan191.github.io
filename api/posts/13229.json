{"title":"ES6","slug":"ES6","date":"2022-01-15","updated":"2022-01-20","comments":true,"path":"api/posts/13229.json","excerpt":null,"cover":null,"covers":null,"content":"<a id=\"more\"></a><h2 id=\"ES6 小结\"><a class=\"headerlink\" href=\"#ES6 小结\"></a>ES6 小结 </h2><h3 id=\"let 和 const\"><a class=\"headerlink\" href=\"#let 和 const\"></a>let 和 const</h3><h4 id=\"1-let- 命令\"><a class=\"headerlink\" href=\"#1-let- 命令\"></a>1.let 命令</h4><h4 id=\"块级作用域\"><a class=\"headerlink\" href=\"# 块级作用域\"></a> 块级作用域 </h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure><p>for 循环有一个特别之处，就是设置环境变量的那个部分是一个父级作用域，而循环体内部是一个单独的字作用域</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br></pre></td></tr></table></figure><h4 id=\"不存在变量提升\"><a class=\"headerlink\" href=\"# 不存在变量提升\"></a> 不存在变量提升 </h4><p>var 命令会发生变量提升，那么什么是变量提升呢？变量提升就是变量可以在声明之前使用，值为 undefined，这多多少少是会有些奇怪的，let 命令就不会有这种问题</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错 ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure><h4 id=\"暂时性死区\"><a class=\"headerlink\" href=\"# 暂时性死区\"></a> 暂时性死区 </h4><p> 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”这个区域，不再受外部的影响 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p><p>“暂时性死区”也意味着 typeof 不再是一个百分百安全的操作 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure><p> 有些“死区”比较隐藏，不太容易发现 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = y, y = <span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure><p> 应为函数也有自己的作用域，x 和 y 是参数，形参不是变量，也不会提升成全局变量，执行 x = y 时 y 没有定义 则会发生 &quot; 死区 &quot; 问题 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = <span class=\"number\">2</span>, y = x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">// [2, 2]</span></span><br></pre></td></tr></table></figure><h4 id=\"不允许重复声明\"><a class=\"headerlink\" href=\"# 不允许重复声明\"></a> 不允许重复声明 </h4><p>let 不允许在相同的作用域中，重复声明同一个变量</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 因此，不能在函数内部重新声明参数。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func() <span class=\"comment\">// 报错 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure><h4 id=\"2- 块级作用域\"><a class=\"headerlink\" href=\"#2- 块级作用域\"></a>2. 块级作用域</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这就带来很多不合理的场景</p><p> 第一种场景，内层变量可能会覆盖外层变量 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure><p> 因为 if 中 用 var 声明了变量 tmp, 所以变量 tmp 提升了，相当于 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">   tmp  = <span class=\"string\">'hello world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure><p> 第二种场景，用来计数的循环变量泄露成全局变量 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure><p> 上面的 i 只是用来循环计数的变量，但在循环结束之后，它并没有消失，泄露成了全局变量 </p><p> 在 es6 中引入了块级作用域 </p><p>let 实际上为 js 新增的跨级作用域</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1() &#123;</span><br><span class=\"line\">  let n &#x3D; 5;</span><br><span class=\"line\">  if (true) &#123;</span><br><span class=\"line\">    let n &#x3D; 10;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(n); &#x2F;&#x2F; 5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 块级作用域可以嵌套 </p><h4 id=\"函数声明\"><a class=\"headerlink\" href=\"# 函数声明\"></a> 函数声明 </h4><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明</p><ul><li> 在 ES6 中，允许在块级作用域中声明函数 </li><li> 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部 </li><li> 同时，函数声明还会提升到所在块级作用域的头部 </li></ul><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 浏览器的 ES6 环境</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><h4 id=\"3-const- 命令\"><a class=\"headerlink\" href=\"#3-const- 命令\"></a>3.const 命令</h4><p>const 声明一个只读的变量，一旦声明，常量的值就不能改变，它是指变量保存的地址存的数据不得改动</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为 foo 添加一个属性，可以成功</span></span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\">foo.prop <span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 指向另一个对象，就会报错</span></span><br><span class=\"line\">foo = &#123;&#125;; <span class=\"comment\">// TypeError: \"foo\" is read-only</span></span><br></pre></td></tr></table></figure><p> 冻结对象可以使用 Object.freeze() 方法 </p><h4 id=\"ES6- 中声明变量有 6 中方法\"><a class=\"headerlink\" href=\"#ES6- 中声明变量有 6 中方法\"></a>ES6 中声明变量有 6 中方法</h4><p>ES6 之前 var、function，ES6 之后 let、const、import、class</p><h4 id=\"4- 顶层对象属性\"><a class=\"headerlink\" href=\"#4- 顶层对象属性\"></a>4. 顶层对象属性</h4><p> 浏览器环境指 windows 对象，在 node 中指 global 对象，es5 的时候顶层对象的属性与全局变量的赋值，是同一件事 </p><p>web worker 里面， self 也指向顶层对象</p><h3 id=\"变量和结构赋值\"><a class=\"headerlink\" href=\"# 变量和结构赋值\"></a> 变量和结构赋值 </h3><h4 id=\"1- 数组的结构赋值\"><a class=\"headerlink\" href=\"#1- 数组的结构赋值\"></a>1. 数组的结构赋值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">///////////</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure><p> 如果解构不成功，变量的值就等于 undefined</p><p>如果等号右边不是一个可遍历的结构，也会报错，对于 Set 结构，也可以使用数组的解构赋值 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, y, z] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br></pre></td></tr></table></figure><p> 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fibs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> a;</span><br><span class=\"line\">    [a, b] = [b, a + b];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class=\"line\">sixth <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure><h4 id=\"默认值\"><a class=\"headerlink\" href=\"# 默认值\"></a>默认值 </h4><p> 解构赋值允许指定默认值 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [foo = <span class=\"literal\">true</span>] = [];</span><br><span class=\"line\">foo <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>]; <span class=\"comment\">// x='a', y='b'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>, <span class=\"literal\">undefined</span>]; <span class=\"comment\">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p> 没有传值相当于 undefined，也只有当一个数组的成员变量严格等于 undefined，默认值才会生效 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">undefined</span>];</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];</span><br><span class=\"line\">x <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure><h4 id=\"2- 对象的解构赋值\"><a class=\"headerlink\" href=\"#2- 对象的解构赋值\"></a>2. 对象的解构赋值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; bar, foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure><p> 解构失败，变量的值等于 undefined</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">foo <span class=\"comment\">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><h4 id=\"注意点\"><a class=\"headerlink\" href=\"# 注意点\"></a>注意点 </h4><p>1. 如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 错误的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">&#123;x&#125; &#x3D; &#123;x: 1&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; SyntaxError: syntax error</span><br><span class=\"line\">&#x2F;&#x2F; 正确的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">(&#123;x&#125; &#x3D; &#123;x: 1&#125;)</span><br></pre></td></tr></table></figure><p> 上面这种语法会报错，JavaScript 引擎会将 {X} 理解成一个代码块，从而发生语法错误，正确的做法是加个大括号 </p><p>2. 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;&#125; = [<span class=\"literal\">true</span>, <span class=\"literal\">false</span>]);</span><br><span class=\"line\">(&#123;&#125; = <span class=\"string\">'abc'</span>);</span><br><span class=\"line\">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p> 虽然奇怪，但是可以语法是合法的，可以运行 </p><p>3. 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"number\">0</span> : first, [arr.length - <span class=\"number\">1</span>] : last&#125; = arr;</span><br><span class=\"line\">first <span class=\"comment\">// 1</span></span><br><span class=\"line\">last <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure><h4 id=\"3- 字符串的解构赋值\"><a class=\"headerlink\" href=\"#3- 字符串的解构赋值\"></a>3. 字符串的解构赋值</h4><p> 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">a <span class=\"comment\">// \"h\"</span></span><br><span class=\"line\">b <span class=\"comment\">// \"e\"</span></span><br><span class=\"line\">c <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">d <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">e <span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure><h4 id=\"4- 数值和布尔值的解构赋值\"><a class=\"headerlink\" href=\"#4- 数值和布尔值的解构赋值\"></a>4. 数值和布尔值的解构赋值 </h4><p> 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">toString</span>: s&#125; = <span class=\"number\">123</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Number</span>.prototype.toString <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">toString</span>: s&#125; = <span class=\"literal\">true</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Boolean</span>.prototype.toString <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><h4 id=\"5- 函数参数的解构赋值\"><a class=\"headerlink\" href=\"#5- 函数参数的解构赋值\"></a>5. 函数参数的解构赋值 </h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">///////////////////////</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">&#123;x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">move(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;); <span class=\"comment\">// [3, 8]</span></span><br><span class=\"line\">move(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;); <span class=\"comment\">// [3, 0]</span></span><br><span class=\"line\">move(&#123;&#125;); <span class=\"comment\">// [0, 0]</span></span><br><span class=\"line\">move(); <span class=\"comment\">// [0, 0]</span></span><br></pre></td></tr></table></figure><h4 id=\"6- 圆括号问题\"><a class=\"headerlink\" href=\"#6- 圆括号问题\"></a>6. 圆括号问题</h4><p> 以下三种解构赋值不得使用圆括号。</p><p>模式中 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全部报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [(a)] = [<span class=\"number\">1</span>]; <span class=\"comment\">// 不能在声明中使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> (&#123;<span class=\"attr\">x</span>: c&#125;) = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">o</span>: (&#123; <span class=\"attr\">p</span>: p &#125;) &#125; = &#123; <span class=\"attr\">o</span>: &#123; <span class=\"attr\">p</span>: <span class=\"number\">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p> 函数参数 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[(z</span>)]) </span>&#123; <span class=\"keyword\">return</span> z; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[z,(x</span>)]) </span>&#123; <span class=\"keyword\">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p> 赋值语句的模式 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全部报错</span></span><br><span class=\"line\">(&#123; <span class=\"attr\">p</span>: a &#125;) = &#123; <span class=\"attr\">p</span>: <span class=\"number\">42</span> &#125;;</span><br><span class=\"line\">([a]) = [<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure><p> 可以在赋值语句的非模式的时候使用 </p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(b)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">(&#123; <span class=\"attr\">p</span>: (d) &#125; = &#123;&#125;); <span class=\"comment\">// 正确</span></span><br><span class=\"line\">[(<span class=\"built_in\">parseInt</span>.prop)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></span><br></pre></td></tr></table></figure><h4 id=\"7- 用途\"><a class=\"headerlink\" href=\"#7- 用途\"></a>7. 用途</h4><p>1. 交换变量</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>2. 从函数中返回多个值</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回一个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = example();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p>3. 函数参数的定义</p><p> 解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参数是一组有次序的值 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>4. 提取 JSON 数据</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jsonData = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">42</span>,</span><br><span class=\"line\">  status: <span class=\"string\">\"OK\"</span>,</span><br><span class=\"line\">  data: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, <span class=\"attr\">data</span>: number &#125; = jsonData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number);</span><br><span class=\"line\"><span class=\"comment\">// 42, \"OK\", [867, 5309]</span></span><br></pre></td></tr></table></figure><p>5. 函数参数的默认值</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jQuery.ajax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  async = true,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class=\"line\">  cache = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  complete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  crossDomain = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  global = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ... more config</span></span><br><span class=\"line\">&#125; = &#123;&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... do stuff</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>6. 遍历 Map 解构</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">'first'</span>, <span class=\"string\">'hello'</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">'second'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\"is\"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first is hello</span></span><br><span class=\"line\"><span class=\"comment\">// second is world</span></span><br><span class=\"line\"><span class=\"comment\">//////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">// 获取键名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取键值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [,value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>7. 输入模块的指定方法</p><p> 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</span><br></pre></td></tr></table></figure><h3 id=\"字符串的扩展\"><a class=\"headerlink\" href=\"# 字符串的扩展\"></a>字符串的扩展 </h3><h4 id=\"1- 字符的 Unicode 表示法\"><a class=\"headerlink\" href=\"#1- 字符的 Unicode 表示法\"></a>1. 字符的 Unicode 表示法</h4><p>ES6 加强了对 Unicode 的支持，允许采用<code>\\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code> 表示字符的 Unicode 码点。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;\\u0061&quot;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;a&quot;</span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在 <code>\\u0000</code>~<code>\\uFFFF</code> 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;\\uD842\\uDFB7&quot;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;𠮷&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;\\u20BB7&quot;</span><br><span class=\"line\">&#x2F;&#x2F; &quot; 7&quot;</span><br></pre></td></tr></table></figure><p>上面代码表示，如果直接在 <code>\\u</code> 后面跟上超过 <code>0xFFFF</code> 的数值（比如 <code>\\u20BB7</code>），JavaScript 会理解成<code>\\u20BB+7</code>。由于<code>\\u20BB</code> 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 <code>7</code>。</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;\\u&#123;20BB7&#125;&quot;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;𠮷&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;&quot;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;ABC&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let hello &#x3D; 123;</span><br><span class=\"line\">hell\\u&#123;6F&#125; &#x2F;&#x2F; 123</span><br><span class=\"line\"></span><br><span class=\"line\">&#39;\\u&#123;1F680&#125;&#39; &#x3D;&#x3D;&#x3D; &#39;\\uD83D\\uDE80&#39;</span><br><span class=\"line\">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p> 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;\\z&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39;  &#x2F;&#x2F; true</span><br><span class=\"line\">&#39;\\172&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br><span class=\"line\">&#39;\\x7A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br><span class=\"line\">&#39;\\u007A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br><span class=\"line\">&#39;\\u&#123;7A&#125;&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h4 id=\"2- 字符串的遍历器接口\"><a class=\"headerlink\" href=\"#2- 字符串的遍历器接口\"></a>2. 字符串的遍历器接口 </h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code> 循环遍历。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> codePoint <span class=\"keyword\">of</span> <span class=\"string\">'foo'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(codePoint)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// \"f\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure><h4 id=\"3- 直接输入 -U-2028- 和 -U-2029\"><a class=\"headerlink\" href=\"#3- 直接输入 -U-2028- 和 -U-2029\"></a>3. 直接输入 U+2028 和 U+2029</h4><h4 id=\"4-JSON-stringify- 的改造\"><a class=\"headerlink\" href=\"#4-JSON-stringify- 的改造\"></a>4.JSON.stringify() 的改造 </h4><h4 id=\"5- 模板字符串\"><a class=\"headerlink\" href=\"#5- 模板字符串\"></a>5. 模板字符串</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通字符串</span></span><br><span class=\"line\"><span class=\"string\">`In JavaScript '\\n' is a line-feed.`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多行字符串</span></span><br><span class=\"line\"><span class=\"string\">`In JavaScript this is</span></span><br><span class=\"line\"><span class=\"string\"> not legal.`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`string text line 1</span></span><br><span class=\"line\"><span class=\"string\">string text line 2`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串中嵌入变量</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">\"Bob\"</span>, time = <span class=\"string\">\"today\"</span>;</span><br><span class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>, how are you <span class=\"subst\">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p> 如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> func = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> <span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>!`</span>;</span><br><span class=\"line\">func(<span class=\"string\">'Jack'</span>) <span class=\"comment\">// \"Hello Jack!\"</span></span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了 </p><h4 id=\"6- 实例：模板编译\"><a class=\"headerlink\" href=\"#6- 实例：模板编译\"></a>6. 实例：模板编译</h4><h4 id=\"7- 标签模板\"><a class=\"headerlink\" href=\"#7- 标签模板\"></a>7. 标签模板</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">tag<span class=\"string\">`Hello <span class=\"subst\">$&#123; a + b &#125;</span> world <span class=\"subst\">$&#123; a * b &#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">tag([<span class=\"string\">'Hello'</span>, <span class=\"string\">'world'</span>, <span class=\"string\">''</span>], <span class=\"number\">15</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure><h3 id=\" 字符串的新增方法 \"><a class=\"headerlink\"href=\"# 字符串的新增方法 \"></a> 字符串的新增方法 </h3><h4 id=\"1-String-fromCodePoint\"><a class=\"headerlink\"href=\"#1-String-fromCodePoint\"></a>1. String.fromCodePoint()</h4><p> 可识别大于 <code>0xFFFF</code> 的码点 </p><p> 注意，<code>fromCodePoint</code>方法定义在 <code>String</code> 对象上，而 <code>codePointAt</code> 方法定义在字符串的实例对象上。</p><h4 id=\"2-String-raw\"><a class=\"headerlink\"href=\"#2-String-raw\"></a>2.String.raw()</h4><p>ES6 还为原生的 String 对象，提供了一个 <code>raw()</code> 方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\n<span class=\"subst\">$&#123;<span class=\"number\">2</span>+<span class=\"number\">3</span>&#125;</span>!`</span></span><br><span class=\"line\"><span class=\"comment\">// 实际返回\"Hi\\\\n5!\"，显示的是转义后的结果\"Hi\\n5!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\u000A!`</span>;</span><br><span class=\"line\"><span class=\"comment\">// 实际返回\"Hi\\\\u000A!\"，显示的是转义后的结果\"Hi\\u000A!\"</span></span><br></pre></td></tr></table></figure><h4 id=\"3- 实例方法：codePointAt\"><a class=\"headerlink\"href=\"#3- 实例方法：codePointAt\"></a>3. 实例方法：codePointAt()</h4><h4 id=\"4- 实例方法 \"><a class=\"headerlink\"href=\"#4- 实例方法 \"></a>4. 实例方法 </h4><p> 传统上，JavaScript 只有 <code>indexOf</code> 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><h4 id=\"5-repeat\"><a class=\"headerlink\"href=\"#5-repeat\"></a>5. repeat()</h4><p>repeat() 用于返回一个新字符串，表示将原字符串重复 n 次 </p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;x&#39;.repeat(3) &#x2F;&#x2F; &quot;xxx&quot;</span><br><span class=\"line\">&#39;hello&#39;.repeat(2) &#x2F;&#x2F; &quot;hellohello&quot;</span><br><span class=\"line\">&#39;na&#39;.repeat(0) &#x2F;&#x2F; &quot;</span><br></pre></td></tr></table></figure><p> 参数如果是小数，会被下取整数, 如果参数是负数或者 infinity</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">2.9</span>) <span class=\"comment\">//\"nana\"</span></span><br><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">0.5</span>) <span class=\"comment\">//''</span></span><br><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">Infinity</span>)</span><br><span class=\"line\"><span class=\"comment\">// RangeError</span></span><br><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// RangeError</span></span><br></pre></td></tr></table></figure><p>但是，如果参数是 0 到 -1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到 -1 之间的小数，取整以后等于 <code>-0</code>，<code>repeat</code> 视同为 0。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-0.9</span>) <span class=\"comment\">// \"\"</span></span><br></pre></td></tr></table></figure><p>参数 <code>NaN</code> 等同于 0。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">NaN</span>) <span class=\"comment\">//\"\"</span></span><br></pre></td></tr></table></figure><p>如果 <code>repeat</code> 的参数是字符串，则会先转换成数字。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'na'</span>) <span class=\"comment\">// \"\"</span></span><br><span class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'3'</span>) <span class=\"comment\">//\"nanana\"</span></span><br></pre></td></tr></table></figure><h4 id=\"6- 实例方法 -padStart-padEnd\"><a class=\"headerlink\"href=\"#6- 实例方法 -padStart-padEnd\"></a>6. 实例方法 padStart(),padEnd()</h4><p>字符串补全，padStart()在头部补全，padEnd()在尾部补全，一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;x&#39;.padStart(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;ababx&#39;</span><br><span class=\"line\">&#39;x&#39;.padStart(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;abax&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">&#39;x&#39;.padEnd(5, &#39;ab&#39;) &#x2F;&#x2F; &#39;xabab&#39;</span><br><span class=\"line\">&#39;x&#39;.padEnd(4, &#39;ab&#39;) &#x2F;&#x2F; &#39;xaba&#39;</span><br></pre></td></tr></table></figure><p><code>padStart()</code>和 <code>padEnd()</code> 一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'xxx'</span>.padStart(<span class=\"number\">2</span>, <span class=\"string\">'ab'</span>) <span class=\"comment\">//'xxx'</span></span><br><span class=\"line\"><span class=\"string\">'xxx'</span>.padEnd(<span class=\"number\">2</span>, <span class=\"string\">'ab'</span>) <span class=\"comment\">//'xxx'</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'0123456789'</span>)</span><br><span class=\"line\"><span class=\"comment\">//'0123456abc'</span></span><br><span class=\"line\"><span class=\"string\">'x'</span>.padStart(<span class=\"number\">4</span>) <span class=\"comment\">//'   x'</span></span><br><span class=\"line\"><span class=\"string\">'x'</span>.padEnd(<span class=\"number\">4</span>) <span class=\"comment\">//'x   '</span></span><br><span class=\"line\"><span class=\"string\">'1'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'0'</span>) <span class=\"comment\">//\"0000000001\"</span></span><br><span class=\"line\"><span class=\"string\">'12'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'0'</span>) <span class=\"comment\">//\"0000000012\"</span></span><br><span class=\"line\"><span class=\"string\">'123456'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'0'</span>) <span class=\"comment\">//\"0000123456\"</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'YYYY-MM-DD'</span>) <span class=\"comment\">//\"YYYY-MM-12\"</span></span><br><span class=\"line\"><span class=\"string\">'09-12'</span>.padStart(<span class=\"number\">10</span>, <span class=\"string\">'YYYY-MM-DD'</span>) <span class=\"comment\">//\"YYYY-09-12\"</span></span><br></pre></td></tr></table></figure><h4 id=\"7- 实例方法：trimStart-trimEnd\"><a class=\"headerlink\"href=\"#7- 实例方法：trimStart-trimEnd\"></a>7. 实例方法：trimStart(), trimEnd()</h4><p>trimStart() 消除开头的空格，trimEnd() 消除尾部空格，他们都是返回新的字符串，不会修改原字符串 </p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"string\">'  abc  '</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">s.trim() <span class=\"comment\">//\"abc\"</span></span><br><span class=\"line\">s.trimStart() <span class=\"comment\">//\"abc  \"</span></span><br><span class=\"line\">s.trimEnd() <span class=\"comment\">//\"  abc\"</span></span><br></pre></td></tr></table></figure><p> 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p><p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是 <code>trimStart()</code> 的别名，<code>trimRight()</code>是 <code>trimEnd()</code> 的别名。</p><h4 id=\"8- 实例方法：-matchAll\"><a class=\"headerlink\"href=\"#8- 实例方法：-matchAll\"></a>8. 实例方法： matchAll()</h4><h4 id=\"9- 实例方法：replaceAll\"><a class=\"headerlink\"href=\"#9- 实例方法：replaceAll\"></a>9. 实例方法：replaceAll()</h4><p>在正则中要加 g, 开启全局搜索 </p><h4 id=\"10-at\"><a class=\"headerlink\"href=\"#10-at\"></a>10 at()</h4><p><code>at()</code> 方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">str.at(<span class=\"number\">1</span>) <span class=\"comment\">//\"e\"</span></span><br><span class=\"line\">str.at(<span class=\"number\">-1</span>) <span class=\"comment\">//\"o\"</span></span><br></pre></td></tr></table></figure><p>如果参数位置超出了字符串范围，<code>at()</code>返回 <code>undefined</code>。</p><p> 该方法来自数组添加的 <code>at()</code> 方法，目前还是一个第三阶段的提案 </p><h4 id=\" 正则的扩展 \"><a class=\"headerlink\"href=\"# 正则的扩展 \"></a> 正则的扩展 </h4><h4 id=\"1-RegExp- 构造函数 \"><a class=\"headerlink\"href=\"#1-RegExp- 构造函数 \"></a>1.RegExp 构造函数</h4><p>ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regex = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"regexp\">/xyz/</span>, <span class=\"string\">'i'</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为。如果<code>RegExp</code> 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"regexp\">/abc/ig</span>, <span class=\"string\">'i'</span>).flags</span><br><span class=\"line\"><span class=\"comment\">//\"i\"</span></span><br></pre></td></tr></table></figure><p>上面代码中，原有正则对象的修饰符是 <code>ig</code>，它会被第二个参数<code>i</code> 覆盖。</p><h4 id=\"2-RegExp-prototype-sticky- 属性 \"><a class=\"headerlink\"href=\"#2-RegExp-prototype-sticky- 属性 \"></a>2.RegExp.prototype.sticky 属性 </h4><p> 与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了 <code>sticky</code> 属性，表示是否设置了 <code>y</code> 修饰符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"regexp\">/hello\\d/y</span>;</span><br><span class=\"line\">r.sticky <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><h4 id=\"3-RegExp-prototype-flags- 属性 \"><a class=\"headerlink\"href=\"#3-RegExp-prototype-flags- 属性 \"></a>3.RegExp.prototype.flags 属性 </h4><p>ES6 为正则表达式新增了<code>flags</code> 属性，会返回正则表达式的修饰符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 的 source 属性 </span></span><br><span class=\"line\"><span class=\"comment\">// 返回正则表达式的正文</span></span><br><span class=\"line\">/abc/ig.source</span><br><span class=\"line\"><span class=\"comment\">//\"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的 flags 属性</span></span><br><span class=\"line\"><span class=\"comment\">// 返回正则表达式的修饰符</span></span><br><span class=\"line\">/abc/ig.flags</span><br><span class=\"line\"><span class=\"comment\">//'gi'</span></span><br></pre></td></tr></table></figure><h3 id=\" 数值的扩展 \"><a class=\"headerlink\"href=\"# 数值的扩展 \"></a> 数值的扩展 </h3><h4 id=\"1- 二进制和八进制表示法 \"><a class=\"headerlink\"href=\"#1- 二进制和八进制表示法 \"></a>1. 二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0b111110111</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0o767</span> === <span class=\"number\">503</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p> 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀 <code>0</code> 表示，ES6 进一步明确，要使用前缀 <code>0o</code> 表示。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非严格模式 </span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">0o11</span> === <span class=\"number\">011</span>);</span><br><span class=\"line\">&#125;)() <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 严格模式</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">0o11</span> === <span class=\"number\">011</span>);</span><br><span class=\"line\">&#125;)() <span class=\"comment\">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure><p> 如果要将 <code>0b</code> 和<code>0o</code>前缀的字符串数值转为十进制，要使用 <code>Number</code> 方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'0b111'</span>)  <span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">'0o10'</span>)  <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure><h4 id=\"2- 数值分隔符 \"><a class=\"headerlink\"href=\"#2- 数值分隔符 \"></a>2. 数值分隔符 </h4><p><a href=\"https://github.com/tc39/proposal-numeric-separator\"target=\"_blank\"rel=\"noopener external nofollow noreferrer\">ES2021</a>，允许 JavaScript 的数值使用下划线（<code>_</code>）作为分隔符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> budget = <span class=\"number\">1</span>_000_000_000_000;</span><br><span class=\"line\">budget === <span class=\"number\">10</span> ** <span class=\"number\">12</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p> 这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">123</span>_00 === <span class=\"number\">12</span>_300 <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">12345</span>_00 === <span class=\"number\">123</span>_4500 <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">12345</span>_00 === <span class=\"number\">1</span>_234_500 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>小数和科学计数法也可以使用数值分隔符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小数 </span></span><br><span class=\"line\"><span class=\"number\">0.000</span>_001</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 科学计数法</span></span><br><span class=\"line\"><span class=\"number\">1e10</span>_000</span><br></pre></td></tr></table></figure><p> 数值分隔符有几个使用注意点。</p><ul><li>不能放在数值的最前面（leading）或最后面（trailing）。</li><li>不能两个或两个以上的分隔符连在一起。</li><li>小数点的前后不能有分隔符。</li><li>科学计数法里面，表示指数的 <code>e</code> 或<code>E</code>前后不能有分隔符。</li></ul><h4 id=\"3-Number-isFinite-，Number-isNaN\"><a class=\"headerlink\"href=\"#3-Number-isFinite-，Number-isNaN\"></a>3.Number.isFinite()，Number.isNaN()</h4><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）<code>Number.isNaN()</code>用来检查一个值是否为 <code>NaN</code>。</p><p> 它们与传统的全局方法 <code>isFinite()</code> 和<code>isNaN()</code>的区别在于，传统方法先调用 <code>Number()</code> 将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，<code>Number.isFinite()</code>对于非数值一律返回 <code>false</code>, <code>Number.isNaN()</code> 只有对于 <code>NaN</code> 才返回 <code>true</code>，非<code>NaN</code> 一律返回 <code>false</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">1</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><h4 id=\"4-Number-parseInt-Number-parseFloat\"><a class=\"headerlink\"href=\"#4-Number-parseInt-Number-parseFloat\"></a>4.Number.parseInt(), Number.parseFloat()</h4><p> 和原来的全局方法 parseInt(),parseFloat()效果一样，只是从全局方法转移到了 Number 对象上 </p><h4 id=\"5-Number-isInteger\"><a class=\"headerlink\"href=\"#5-Number-isInteger\"></a>5.Number.isInteger()</h4><p><code>Number.isInteger()</code> 用来判断一个数值是否为整数。</p><p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25.0</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>注意数据如果超出数据范围，该方法失效，如果对数据精度的要求较高，不建议使用 </p><h4 id=\"6-Number-EPSILON\"><a class=\"headerlink\"href=\"#6-Number-EPSILON\"></a>6.Number.EPSILON</h4><p>ES6 在<code>Number</code> 对象上面，新增一个极小的常量 <code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。等于 2 的 -52 次方。<code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围。</p><h4 id=\"7- 安全整数和 -Number-isSafeInteger。\"><a class=\"headerlink\"href=\"#7- 安全整数和 -Number-isSafeInteger。\"></a>7. 安全整数和 Number.isSafeInteger。</h4><p>JavaScript 能够准确表示的整数范围在 <code>-2^53</code> 到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><h4 id=\"8-Math- 对象的扩展 \"><a class=\"headerlink\"href=\"#8-Math- 对象的扩展 \"></a>8.Math 对象的扩展 </h4><p><strong>Math.trunc()</strong></p><p> 用于去除一个数的小数部分，返回整数部分，对于非数值，<code>Math.trunc</code>内部使用 <code>Number</code> 方法将其先转为数值。对于空值和无法截取整数的值，返回 <code>NaN</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.1</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.9</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.1</span>) <span class=\"comment\">// -4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.9</span>) <span class=\"comment\">// -4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-0.1234</span>) <span class=\"comment\">// -0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"string\">'123.456'</span>) <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"literal\">true</span>) <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"literal\">false</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"literal\">null</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure><p><strong>Math.sign()</strong></p><p><code>Math.sign</code> 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><p>它会返回五种值。</p><ul><li>参数为正数，返回 <code>+1</code>；</li><li> 参数为负数，返回 <code>-1</code>；</li><li> 参数为 0，返回 <code>0</code>；</li><li> 参数为 -0，返回 <code>-0</code>;</li><li> 其他值，返回 <code>NaN</code>。</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"string\">''</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">true</span>)  <span class=\"comment\">// +1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">false</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">null</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"string\">'9'</span>)  <span class=\"comment\">// +1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"string\">'foo'</span>)  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign()  <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">undefined</span>)  <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>Math.cbrt()</strong></p><p> 计算一个数的立方根，对于非数值，<code>Math.cbrt()</code>方法内部也是先使用 <code>Number()</code> 方法将其转为数值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">-1</span>) <span class=\"comment\">// -1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">0</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">1</span>)  <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">2</span>)  <span class=\"comment\">// 1.2599210498948732</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'8'</span>) <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'hello'</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>Math.clz32()</strong></p><p>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.clz32(<span class=\"number\">0</span>) <span class=\"comment\">// 32</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.clz32(<span class=\"number\">1</span>) <span class=\"comment\">// 31</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.clz32(<span class=\"number\">1000</span>) <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.clz32(<span class=\"number\">0b01000000000000000000000000000000</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.clz32(<span class=\"number\">0b00100000000000000000000000000000</span>) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure><p><strong>Math.imul()</strong></p><p><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.imul(<span class=\"number\">2</span>, <span class=\"number\">4</span>)   <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.imul(<span class=\"number\">-1</span>, <span class=\"number\">8</span>)  <span class=\"comment\">// -8</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.imul(<span class=\"number\">-2</span>, <span class=\"number\">-2</span>) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure><p><strong>Math.fround()</strong></p><p><code>Math.fround</code>方法返回一个数的 32 位单精度浮点数形式。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.fround(<span class=\"number\">0</span>)   <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.fround(<span class=\"number\">1</span>)   <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.fround(<span class=\"number\">2</span> ** <span class=\"number\">24</span> - <span class=\"number\">1</span>)   <span class=\"comment\">// 16777215</span></span><br></pre></td></tr></table></figure><p><strong>Math.hypot()</strong></p><p>方法返回所有参数的平方和的平方根 </p><p> 如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>);        <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);     <span class=\"comment\">// 7.0710678118654755</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot();            <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"literal\">NaN</span>);         <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'foo'</span>); <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'5'</span>);   <span class=\"comment\">// 7.0710678118654755</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">-3</span>);          <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure><p><strong>Math.expml()</strong></p><p><code>Math.expm1(x)</code>返回 ex - 1，即 <code>Math.exp(x) - 1</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.expm1(<span class=\"number\">-1</span>) <span class=\"comment\">// -0.6321205588285577</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.expm1(<span class=\"number\">0</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.expm1(<span class=\"number\">1</span>)  <span class=\"comment\">// 1.718281828459045</span></span><br></pre></td></tr></table></figure><p><strong>Math.log1p()</strong></p><p><code>Math.log1p(x)</code> 方法返回 <code>1 + x</code> 的自然对数，即 <code>Math.log(1 + x)</code>。如果<code>x</code> 小于 -1，返回 <code>NaN</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.log1p(<span class=\"number\">1</span>)  <span class=\"comment\">// 0.6931471805599453</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log1p(<span class=\"number\">0</span>)  <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log1p(<span class=\"number\">-1</span>) <span class=\"comment\">// -Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log1p(<span class=\"number\">-2</span>) <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>Math.log10()</strong></p><p><code>Math.log10(x)</code> 返回以 10 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 NaN。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.log10(<span class=\"number\">2</span>)      <span class=\"comment\">// 0.3010299956639812</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log10(<span class=\"number\">1</span>)      <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log10(<span class=\"number\">0</span>)      <span class=\"comment\">// -Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log10(<span class=\"number\">-2</span>)     <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log10(<span class=\"number\">100000</span>) <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure><p><strong>Math.log2()</strong></p><p><code>Math.log2(x)</code>返回以 2 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 NaN。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">3</span>)       <span class=\"comment\">// 1.584962500721156</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">2</span>)       <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">1</span>)       <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">0</span>)       <span class=\"comment\">// -Infinity</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">-2</span>)      <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">1024</span>)    <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.log2(<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">29</span>) <span class=\"comment\">// 29</span></span><br></pre></td></tr></table></figure><h4 id=\"9-BigInt- 数据类型\"><a class=\"headerlink\" href=\"#9-BigInt- 数据类型\"></a>9.BigInt 数据类型 </h4><p>ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p><p> 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀 <code>n</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1234</span> <span class=\"comment\">// 普通整数</span></span><br><span class=\"line\"><span class=\"number\">1234n</span> <span class=\"comment\">// BigInt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BigInt 的运算</span></span><br><span class=\"line\"><span class=\"number\">1n</span> + <span class=\"number\">2n</span> <span class=\"comment\">// 3n</span></span><br></pre></td></tr></table></figure><p>BigInt 与普通整数是两种值，它们之间并不相等。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">42n</span> === <span class=\"number\">42</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p><code>typeof</code> 运算符对于 BigInt 类型的数据返回 <code>bigint</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123n</span> <span class=\"comment\">// 'bigint'</span></span><br></pre></td></tr></table></figure><p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">-42n</span> <span class=\"comment\">// 正确</span></span><br><span class=\"line\">+<span class=\"number\">42n</span> <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>BigInt 函数</strong></p><p>JavaScript 原生提供<code>BigInt</code> 函数，可以用它生成 BigInt 类型的数值。转换规则基本与 <code>Number()</code> 一致，将其他类型的值转为 BigInt。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInt(<span class=\"number\">123</span>) <span class=\"comment\">// 123n</span></span><br><span class=\"line\">BigInt(<span class=\"string\">'123'</span>) <span class=\"comment\">// 123n</span></span><br><span class=\"line\">BigInt(<span class=\"literal\">false</span>) <span class=\"comment\">// 0n</span></span><br><span class=\"line\">BigInt(<span class=\"literal\">true</span>) <span class=\"comment\">// 1n</span></span><br></pre></td></tr></table></figure><p><code>BigInt()</code>函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> BigInt() <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">BigInt(<span class=\"literal\">undefined</span>) <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">BigInt(<span class=\"literal\">null</span>) <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">BigInt(<span class=\"string\">'123n'</span>) <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">BigInt(<span class=\"string\">'abc'</span>) <span class=\"comment\">// SyntaxError</span></span><br></pre></td></tr></table></figure><p>上面代码中，尤其值得注意字符串 <code>123n</code> 无法解析成 Number 类型，所以会报错。</p><p>参数如果是小数，也会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInt(<span class=\"number\">1.5</span>) <span class=\"comment\">// RangeError</span></span><br><span class=\"line\">BigInt(<span class=\"string\">'1.5'</span>) <span class=\"comment\">// SyntaxError</span></span><br></pre></td></tr></table></figure><h3 id=\"函数的扩展\"><a class=\"headerlink\" href=\"# 函数的扩展\"></a>函数的扩展 </h3><h4 id=\"1 函数的默认参数\"><a class=\"headerlink\" href=\"#1 函数的默认参数\"></a>1 函数的默认参数</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y = <span class=\"string\">'World'</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">log(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// Hello World</span></span><br><span class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">'China'</span>) <span class=\"comment\">// Hello China</span></span><br><span class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">''</span>) <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure><p> 使用参数默认值时，函数不能有同名参数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不报错 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, x, y = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><h4 id=\" 与解构赋值默认值结合使用 \"><a class=\"headerlink\"href=\"# 与解构赋值默认值结合使用 \"></a> 与解构赋值默认值结合使用 </h4><p> 参数默认值可以与解构赋值的默认值，结合起来使用。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1 5</span></span><br><span class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1 2</span></span><br><span class=\"line\">foo() <span class=\"comment\">// TypeError: Cannot read property'x'of undefined</span></span><br><span class=\"line\"><span class=\"comment\">/////////////////////////////////////////////////// 改正 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() <span class=\"comment\">// undefined 5</span></span><br></pre></td></tr></table></figure><p> 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 <code>foo</code> 的参数是一个对象时，变量 <code>x</code> 和<code>y</code>才会通过解构赋值生成。如果函数 <code>foo</code> 调用时没提供参数，变量 <code>x</code> 和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">&#123;x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\" 函数的 length 属性 \"><a class=\"headerlink\"href=\"# 函数的 length 属性 \"></a>函数的 length 属性 </h4><p> 指定了默认值以后，函数的 <code>length</code> 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;&#125;).length <span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b, c = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure><h4 id=\" 作用域 \"><a class=\"headerlink\"href=\"# 作用域 \"></a>作用域 </h4><p> 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y = x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数 <code>y</code> 的默认值等于变量 <code>x</code>。调用函数<code>f</code> 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 <code>x</code> 指向第一个参数 <code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure><p> 上面代码中，函数 <code>f</code> 调用时，参数 <code>y = x</code> 形成一个单独的作用域。这个作用域里面，变量 <code>x</code> 本身没有定义，所以指向外层的全局变量 <code>x</code>。函数调用时，函数体内部的局部变量<code>x</code> 影响不到默认值变量 <code>x</code>。</p><p> 如果此时，全局变量 <code>x</code> 不存在，就会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><h4 id=\" 应用 \"><a class=\"headerlink\"href=\"# 应用 \"></a>应用 </h4><p> 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throwIfMissing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Missing parameter'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mustBeProvided;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo()</span><br><span class=\"line\"><span class=\"comment\">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的 <code>foo</code> 函数，如果调用的时候没有参数，就会调用默认值 <code>throwIfMissing</code> 函数，从而抛出一个错误。</p><h4 id=\"2-rest 参数 \"><a class=\"headerlink\"href=\"#2-rest 参数 \"></a>2.rest 参数 </h4><p>ES6 引入 rest 参数（形式为<code>... 变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code> 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> val <span class=\"keyword\">of</span> values) &#123;</span><br><span class=\"line\">    sum += val;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码的 <code>add</code> 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, ...b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 函数的 <code>length</code> 属性，不包括 rest 参数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 0</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, ...b</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure><h4 id=\"3- 严格模式 \"><a class=\"headerlink\"href=\"#3- 严格模式 \"></a>3. 严格模式 </h4><p> 从 ES5 开始，函数内部可以设定为严格模式。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b = a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// code</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\">(<span class=\"params\">...a</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// code</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  doSomething(&#123;a, b&#125;) &#123;</span><br><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// code</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h4 id=\"4-name- 属性 \"><a class=\"headerlink\"href=\"#4-name- 属性 \"></a><a href=\"http://4.name\"target=\"_blank\"rel=\"noopener external nofollow noreferrer\">4.name</a> 属性</h4><p> 函数的 <code>name</code> 属性，返回该函数的函数名。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">foo.name <span class=\"comment\">//\"foo\"</span></span><br></pre></td></tr></table></figure><h4 id=\"5- 箭头函数 \"><a class=\"headerlink\"href=\"#5- 箭头函数 \"></a>5. 箭头函数 </h4><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code> 语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p><strong> 使用注意点 </strong></p><p> 箭头函数有几个使用注意点。</p><p>（1）箭头函数没有自己的 <code>this</code> 对象（详见下文）。</p><p>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用 <code>new</code> 命令，否则会抛出一个错误。</p><p>（3）不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，最重要的是第一点。对于普通函数来说，内部的 <code>this</code> 指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的 <code>this</code> 对象，内部的 <code>this</code> 就是定义时上层作用域中的 <code>this</code>。也就是说，箭头函数内部的<code>this</code> 指向是固定的，相比之下，普通函数的 <code>this</code> 指向是可变的。</p><h4 id=\"6- 尾调用优化 \"><a class=\"headerlink\"href=\"#6- 尾调用优化 \"></a>6. 尾调用优化 </h4><p> 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>f</code> 的最后一步是调用函数 <code>g</code>，这就叫尾调用。</p><p> 以下三种情况，都不属于尾调用。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 情况一 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> y = g(x);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情况三</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  g(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m(x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>m</code> 和<code>n</code>都属于尾调用，因为它们都是函数 <code>f</code> 的最后一步操作。</p><h3 id=\" 数组的扩展 \"><a class=\"headerlink\"href=\"# 数组的扩展 \"></a>数组的扩展 </h3><h4 id=\"1- 扩展运算符 \"><a class=\"headerlink\"href=\"#1- 扩展运算符 \"></a>1. 扩展运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)]</span><br><span class=\"line\"><span class=\"comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><h4 id=\" 替代函数的 apply 方法 \"><a class=\"headerlink\"href=\"# 替代函数的 apply 方法 \"></a> 替代函数的 apply 方法 </h4><p> 由于扩展运算符可以展开数组，所以不再需要 <code>apply</code> 方法，将数组转为函数的参数了。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 的写法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f.apply(<span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f(...args);</span><br></pre></td></tr></table></figure><h4 id=\" 扩展运算符的应用 \"><a class=\"headerlink\"href=\"# 扩展运算符的应用 \"></a> 扩展运算符的应用 </h4><p><strong>（1）复制数组</strong></p><p> 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = a1;</span><br><span class=\"line\"></span><br><span class=\"line\">a2[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">a1 <span class=\"comment\">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a2</code>并不是 <code>a1</code> 的克隆，而是指向同一份数据的另一个指针。修改 <code>a2</code>，会直接导致<code>a1</code> 的变化。</p><p>ES5 只能用变通方法来复制数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = a1.concat();</span><br><span class=\"line\"></span><br><span class=\"line\">a2[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">a1 <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改 <code>a2</code> 就不会对 <code>a1</code> 产生影响。</p><p>扩展运算符提供了复制数组的简便写法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">// 写法一 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = [...a1];</span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p> 上面的两种写法，<code>a2</code>都是 <code>a1</code> 的克隆。</p><p><strong>（2）合并数组 </strong></p><p> 扩展运算符提供了数组合并的新写法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5 的合并数组 </span></span><br><span class=\"line\">arr1.concat(arr2, arr3);</span><br><span class=\"line\"><span class=\"comment\">// ['a','b','c','d','e']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的合并数组</span></span><br><span class=\"line\">[...arr1, ...arr2, ...arr3]</span><br><span class=\"line\"><span class=\"comment\">// ['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure><p> 不过，这两种方法都是浅拷贝，使用的时候需要注意。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a1 = [&#123; <span class=\"attr\">foo</span>: <span class=\"number\">1</span> &#125;];</span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = [&#123; <span class=\"attr\">bar</span>: <span class=\"number\">2</span> &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a3 = a1.concat(a2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> a4 = [...a1, ...a2];</span><br><span class=\"line\"></span><br><span class=\"line\">a3[<span class=\"number\">0</span>] === a1[<span class=\"number\">0</span>] <span class=\"comment\">// true</span></span><br><span class=\"line\">a4[<span class=\"number\">0</span>] === a1[<span class=\"number\">0</span>] <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a3</code>和 <code>a4</code> 是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p><p><strong>（3）与解构赋值结合 </strong></p><p> 扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\">a = list[<span class=\"number\">0</span>], rest = list.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\">[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些例子。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">first <span class=\"comment\">// 1</span></span><br><span class=\"line\">rest  <span class=\"comment\">// [2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [];</span><br><span class=\"line\">first <span class=\"comment\">// undefined</span></span><br><span class=\"line\">rest  <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"string\">\"foo\"</span>];</span><br><span class=\"line\">first  <span class=\"comment\">//\"foo\"</span></span><br><span class=\"line\">rest   <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [...butLast, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">// 报错 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [first, ...middle, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure><p><strong>（4）字符串</strong></p><p> 扩展运算符还可以将字符串转为真正的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...<span class=\"string\">'hello'</span>]</span><br><span class=\"line\"><span class=\"comment\">// [\"h\",\"e\",\"l\",\"l\",\"o\"]</span></span><br></pre></td></tr></table></figure><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'x\\uD83D\\uDE80y'</span>.length <span class=\"comment\">// 4</span></span><br><span class=\"line\">[...<span class=\"string\">'x\\uD83D\\uDE80y'</span>].length <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">length</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [...str].length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">length(<span class=\"string\">'x\\uD83D\\uDE80y'</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'x\\uD83D\\uDE80y'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">str.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</span><br><span class=\"line\"><span class=\"comment\">//'y\\uDE80\\uD83Dx'</span></span><br><span class=\"line\"></span><br><span class=\"line\">[...str].reverse().join(<span class=\"string\">''</span>)</span><br><span class=\"line\"><span class=\"comment\">// 'y\\uD83D\\uDE80x'</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不用扩展运算符，字符串的 <code>reverse</code> 操作就不正确。</p><p><strong>（5）实现了 Iterator 接口的对象 </strong></p><p> 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nodeList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个 <code>NodeList</code> 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 <code>NodeList</code> 对象实现了 Iterator 。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> num = <span class=\"keyword\">this</span>.valueOf();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; num) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([..<span class=\"number\">.5</span>]) <span class=\"comment\">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中，先定义了 <code>Number</code> 对象的遍历器接口，扩展运算符将 <code>5</code> 自动转成 <code>Number</code> 实例以后，就会调用这个接口，就会返回自定义的结果。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">  <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TypeError: Cannot spread non-iterable object.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 <code>Array.from</code> 方法将 <code>arrayLike</code> 转为真正的数组。</p><p><strong>（6）Map 和 Set 结构，Generator 函数 </strong></p><p> 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...map.keys()]; <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> go = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...go()] <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>go</code> 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...obj]; <span class=\"comment\">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><h4 id=\"2-Array-from\"><a class=\"headerlink\" href=\"#2-Array-from\"></a>2.Array.from()</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5 的写法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6 的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p> 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 <code>arguments</code> 对象。<code>Array.from</code>都可以将它们转为真正的数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NodeList 对象 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ps = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(ps).filter(<span class=\"function\"><span class=\"params\">p</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.textContent.length &gt; <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arguments 对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 <code>length</code> 属性。因此，任何有 <code>length</code> 属性的对象，都可以通过 <code>Array.from</code> 方法转为数组，而此时扩展运算符就无法转换。</p><h4 id=\"3-Array-of\"><a class=\"headerlink\" href=\"#3-Array-of\"></a>3.Array.of()</h4><p><code>Array.of()</code>方法用于将一组值，转换为数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>) <span class=\"comment\">// [3]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>).length <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数 <code>Array()</code> 的不足。因为参数个数的不同，会导致 <code>Array()</code> 的行为有差异。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h4 id=\"4- 实例方法：copyWithin\"><a class=\"headerlink\" href=\"#4- 实例方法：copyWithin\"></a>4. 实例方法：copyWithin()</h4><p>数组实例的 <code>copyWithin()</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.copyWithin(target, start = <span class=\"number\">0</span>, end = <span class=\"keyword\">this</span>.length)</span><br></pre></td></tr></table></figure><p>它接受三个参数。</p><ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><h4 id=\"5-find- 和 findIndex\"><a class=\"headerlink\" href=\"#5-find- 和 findIndex\"></a>5.find()和 findIndex()</h4><p>数组实例的 <code>find</code> 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <code>true</code> 的成员，然后返回该成员。如果没有符合条件的成员，则返回 <code>undefined</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure><h4 id=\"6- 实例方法：fill\"><a class=\"headerlink\" href=\"#6- 实例方法：fill\"></a>6. 实例方法：fill()</h4><p><code>fill</code> 方法使用给定值，填充一个数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"Mike\"</span>&#125;);</span><br><span class=\"line\">arr[<span class=\"number\">0</span>].name = <span class=\"string\">\"Ben\"</span>;</span><br><span class=\"line\">arr</span><br><span class=\"line\"><span class=\"comment\">// [&#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill([]);</span><br><span class=\"line\">arr[<span class=\"number\">0</span>].push(<span class=\"number\">5</span>);</span><br><span class=\"line\">arr</span><br><span class=\"line\"><span class=\"comment\">// [[5], [5], [5]]</span></span><br></pre></td></tr></table></figure><h4 id=\"7-entries-keys-values\"><a class=\"headerlink\" href=\"#7-entries-keys-values\"></a>7.entries() keys() values()</h4><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和 <code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code> 循环进行遍历，唯一的区别是 <code>keys()</code> 是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><h4 id=\"8-includes\"><a class=\"headerlink\" href=\"#8-includes\"></a>8.includes()</h4><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 <code>includes</code> 方法类似。ES2016 引入了该方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">2</span>)     <span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">4</span>)     <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><h4 id=\"9- 实例方法：flat-flatMap\"><a class=\"headerlink\" href=\"#9- 实例方法：flat-flatMap\"></a>9. 实例方法：flat(),flatMap()</h4><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].flat()</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 <code>flat()</code> 方法的参数写成一个整数，表示想要拉平的层数，默认为 1。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, [<span class=\"number\">4</span>, <span class=\"number\">5</span>]]].flat()</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, [4, 5]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, [<span class=\"number\">4</span>, <span class=\"number\">5</span>]]].flat(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>flat()</code>的参数为 2，表示要“拉平”两层的嵌套数组。</p><p>如果不管有多少层嵌套，都要转成一维数组，可以用 <code>Infinity</code> 关键字作为参数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>]]].flat(<span class=\"literal\">Infinity</span>)</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, , <span class=\"number\">4</span>, <span class=\"number\">5</span>].flat()</span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行 <code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code> 方法。该方法返回一个新数组，不改变原数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].flatMap(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> [x, x * <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"comment\">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>只能展开一层数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].flatMap(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> [[x * <span class=\"number\">2</span>]])</span><br><span class=\"line\"><span class=\"comment\">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此 <code>flatMap()</code> 返回的还是一个嵌套数组。</p><p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.flatMap(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;[, thisArg])</span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的 <code>this</code>。</p><h4 id=\"10- 数组的空位\"><a class=\"headerlink\" href=\"#10- 数组的空位\"></a>10. 数组的空位</h4><p> 数组的空位指的是，数组的某一个位置没有任何值，比如 <code>Array()</code> 构造函数返回的数组都是空位。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p><p>注意，空位不是 <code>undefined</code>，某一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code> 运算符可以说明这一点。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [, , ,] <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><h3 id=\"对象的扩展\"><a class=\"headerlink\" href=\"# 对象的扩展\"></a>对象的扩展 </h3><h4 id=\"1- 属性的简洁表示法\"><a class=\"headerlink\" href=\"#1- 属性的简洁表示法\"></a>1. 属性的简洁表示法</h4><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123;foo&#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// &#123;foo: \"bar\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123;<span class=\"attr\">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><p> 上面代码中，变量 <code>foo</code> 直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;x, y&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">x</span>: x, <span class=\"attr\">y</span>: y&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><p> 除了属性简写，方法也可以简写。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  method() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h4 id=\"2- 属性名表达式\"><a class=\"headerlink\" href=\"#2- 属性名表达式\"></a>2. 属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\">obj.foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\">obj[<span class=\"string\">'a'</span> + <span class=\"string\">'bc'</span>] = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure><p> 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 <code>[object Object]</code>，这一点要特别小心。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> keyA = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> keyB = &#123;<span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</span><br><span class=\"line\">  [keyA]: <span class=\"string\">'valueA'</span>,</span><br><span class=\"line\">  [keyB]: <span class=\"string\">'valueB'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject <span class=\"comment\">// Object &#123;[object Object]: \"valueB\"&#125;</span></span><br></pre></td></tr></table></figure><p> 上面代码中，<code>[keyA]</code>和 <code>[keyB]</code> 得到的都是 <code>[object Object]</code>，所以<code>[keyB]</code> 会把 <code>[keyA]</code> 覆盖掉，而 <code>myObject</code> 最后只有一个 <code>[object Object]</code> 属性。</p><h4 id=\"3- 方法的 name 属性\"><a class=\"headerlink\" href=\"#3- 方法的 name 属性\"></a>3. 方法的 name 属性 </h4><p> 函数的 <code>name</code> 属性，返回函数名。对象方法也是函数，因此也有 <code>name</code> 属性。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  sayName() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello!'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName.name   <span class=\"comment\">// \"sayName\"</span></span><br></pre></td></tr></table></figure><h4 id=\"4- 属性的可枚举性和遍历\"><a class=\"headerlink\" href=\"#4- 属性的可枚举性和遍历\"></a>4. 属性的可枚举性和遍历 </h4><p><strong> 可枚举性 </strong></p><p> 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">//  &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    value: 123,</span></span><br><span class=\"line\"><span class=\"comment\">//    writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//    configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的 <code>enumerable</code> 属性，称为“可枚举性”，如果该属性为 <code>false</code>，就表示某些操作会忽略当前属性。</p><p> 目前，有四个操作会忽略 <code>enumerable</code> 为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略 <code>enumerable</code> 为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p><strong>属性的遍历 </strong></p><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code> 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.ownKeys(&#123; [<span class=\"built_in\">Symbol</span>()]:<span class=\"number\">0</span>, <span class=\"attr\">b</span>:<span class=\"number\">0</span>, <span class=\"number\">10</span>:<span class=\"number\">0</span>, <span class=\"number\">2</span>:<span class=\"number\">0</span>, <span class=\"attr\">a</span>:<span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure><h4 id=\"5-super 关键字\"><a class=\"headerlink\" href=\"#5-super 关键字\"></a>5.super 关键字 </h4><p> 我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 <code>super</code>，指向当前对象的原型对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proto = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'world'</span>,</span><br><span class=\"line\">  find() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.foo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br><span class=\"line\">obj.find() <span class=\"comment\">// \"hello\"</span></span><br></pre></td></tr></table></figure><h4 id=\"对象的新增方法\"><a class=\"headerlink\" href=\"# 对象的新增方法\"></a> 对象的新增方法 </h4><h4 id=\"1-Object-is\"><a class=\"headerlink\" href=\"#1-Object-is\"></a><a href=\"http://1.Object.is\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">1.Object.is</a>()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code> 不等于自身，以及 <code>+0</code> 等于 <code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code> 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.is(<span class=\"string\">'foo'</span>, <span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是 <code>+0</code> 不等于 <code>-0</code>，二是<code>NaN</code> 等于自身。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0</span> === <span class=\"number\">-0</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, <span class=\"number\">-0</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署 <code>Object.is</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Object</span>, <span class=\"string\">'is'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === y) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 针对 +0 不等于 -0 的情况</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> x !== <span class=\"number\">0</span> || <span class=\"number\">1</span> / x === <span class=\"number\">1</span> / y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 针对 NaN 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x !== x &amp;&amp; y !== y;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  writable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><h4 id=\"2-Object-assign\"><a class=\"headerlink\" href=\"#2-Object-assign\"></a>2.Object.assign()</h4><p><code>Object.assign()</code> 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2);</span><br><span class=\"line\">target <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2);</span><br><span class=\"line\">target <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj) === obj <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.assign(<span class=\"number\">2</span>) <span class=\"comment\">// \"object\"</span></span><br></pre></td></tr></table></figure><p>由于 <code>undefined</code> 和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 报错 </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(<span class=\"literal\">null</span>) <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure><p> 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 <code>undefined</code> 和<code>null</code>不在首参数，就不会报错。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj, <span class=\"literal\">undefined</span>) === obj <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj, <span class=\"literal\">null</span>) === obj <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> v1 = <span class=\"string\">'abc'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> v2 = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> v3 = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">// &#123; \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><h4 id=\"常见用途\"><a class=\"headerlink\" href=\"# 常见用途\"></a>常见用途 </h4><p><strong> 为对象添加属性 </strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.assign(<span class=\"keyword\">this</span>, &#123;x, y&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong> 为对象添加方法 </strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class=\"line\">  someMethod(arg1, arg2) &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  anotherMethod() &#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于下面的写法</span></span><br><span class=\"line\">SomeClass.prototype.someMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">SomeClass.prototype.anotherMethod = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p><strong> 克隆对象 </strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">origin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, origin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong> 合并多个对象 </strong></p><p> 将多个对象合并到某个对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge =</span><br><span class=\"line\">  (target, ...sources) =&gt; <span class=\"built_in\">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge =</span><br><span class=\"line\">  (...sources) =&gt; <span class=\"built_in\">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><h4 id=\"3-Object-getOwnPropertyDescriptors\"><a class=\"headerlink\" href=\"#3-Object-getOwnPropertyDescriptors\"></a>3.Object.getOwnPropertyDescriptors()</h4><p>ES5 的 <code>Object.getOwnPropertyDescriptor()</code> 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">123</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> bar() &#123; <span class=\"keyword\">return</span> <span class=\"string\">'abc'</span> &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\"><span class=\"comment\">// &#123; foo:</span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; value: 123,</span></span><br><span class=\"line\"><span class=\"comment\">//      writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//      enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//      configurable: true &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   bar:</span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; get: [Function: get bar],</span></span><br><span class=\"line\"><span class=\"comment\">//      set: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//      enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><h4 id=\"4-proto\"><a class=\"headerlink\" href=\"#4-proto\"></a>4.<strong>proto</strong></h4><p><strong>Object.setPrototypeOf()</strong></p><p><code>Object.setPrototypeOf</code>方法的作用与 <code>__proto__</code> 相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 格式 </span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(object, prototype)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = <span class=\"built_in\">Object</span>.setPrototypeOf(&#123;&#125;, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure><p> 该方法等同于下面的函数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setPrototypeOf</span>(<span class=\"params\">obj, proto</span>) </span>&#123;</span><br><span class=\"line\">  obj.__proto__ = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> proto = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(obj, proto);</span><br><span class=\"line\"></span><br><span class=\"line\">proto.y = <span class=\"number\">20</span>;</span><br><span class=\"line\">proto.z = <span class=\"number\">40</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.x <span class=\"comment\">// 10</span></span><br><span class=\"line\">obj.y <span class=\"comment\">// 20</span></span><br><span class=\"line\">obj.z <span class=\"comment\">// 40</span></span><br></pre></td></tr></table></figure><h3 id=\"运算符的扩展\"><a class=\"headerlink\" href=\"# 运算符的扩展\"></a>运算符的扩展 </h3><h4 id=\"1- 指数运算符\"><a class=\"headerlink\" href=\"#1- 指数运算符\"></a>1. 指数运算符</h4><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span> <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure><p> 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 相当于 2 ** (3 ** 2)</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span> ** <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 512</span></span><br></pre></td></tr></table></figure><h4 id=\"2- 链判断运算符\"><a class=\"headerlink\" href=\"#2- 链判断运算符\"></a>2. 链判断运算符 </h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = message?.body?.user?.firstName || <span class=\"string\">'default'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fooValue = myForm.querySelector(<span class=\"string\">'input[name=foo]'</span>)?.value</span><br></pre></td></tr></table></figure><h4 id=\"3Null 判断运算符\"><a class=\"headerlink\" href=\"#3Null 判断运算符\"></a>3Null 判断运算符</h4><p> 这个运算符的一个目的，就是跟链判断运算符 <code>?.</code> 配合使用，为 <code>null</code> 或<code>undefined</code>的值设置默认值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animationDuration = response.settings?.animationDuration ?? <span class=\"number\">300</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>response.settings</code> 是<code>null</code>或 <code>undefined</code>，或者<code>response.settings.animationDuration</code> 是<code>null</code>或 <code>undefined</code>，就会返回默认值 300。也就是说，这一行代码包括了两级属性的判断。</p><h4 id=\"4- 逻辑赋值运算符\"><a class=\"headerlink\" href=\"#4- 逻辑赋值运算符\"></a>4. 逻辑赋值运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 或赋值运算符</span></span><br><span class=\"line\">x ||= y</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">x || (x = y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与赋值运算符</span></span><br><span class=\"line\">x &amp;&amp;= y</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">x &amp;&amp; (x = y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Null 赋值运算符</span></span><br><span class=\"line\">x ??= y</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">x ?? (x = y)</span><br></pre></td></tr></table></figure><p> 这三个运算符 <code>||=</code>、<code>&amp;&amp;=</code>、<code>??=</code> 相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</p><p>它们的一个用途是，为变量或属性设置默认值。</p><h3 id=\"Symbol\"><a class=\"headerlink\" href=\"#Symbol\"></a>Symbol</h3><h4 id=\"1- 概述\"><a class=\"headerlink\" href=\"#1- 概述\"></a>1. 概述 </h4><p>Symbol 值通过<code>Symbol</code> 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> s</span><br><span class=\"line\"><span class=\"comment\">// \"symbol\"</span></span><br></pre></td></tr></table></figure><h4 id=\"2-Symbol-prototype-description\"><a class=\"headerlink\" href=\"#2-Symbol-prototype-description\"></a>2.Symbol.prototype.description</h4><p>创建 Symbol 的时候，可以添加一个描述。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sym</code>的描述就是字符串 <code>foo</code>。</p><h4 id=\"3- 作为属性名的 Symbol\"><a class=\"headerlink\" href=\"#3- 作为属性名的 Symbol\"></a>3. 作为属性名的 Symbol</h4><p> 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种写法 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\">a[mySymbol] = <span class=\"string\">'Hello!'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  [mySymbol]: <span class=\"string\">'Hello!'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Hello!'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上写法都得到同样结果</span></span><br><span class=\"line\">a[mySymbol] <span class=\"comment\">// \"Hello!\"</span></span><br></pre></td></tr></table></figure><p> 上面代码通过方括号结构和 <code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p> 注意，Symbol 值作为对象属性名时，不能用点运算符。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a.mySymbol = <span class=\"string\">'Hello!'</span>;</span><br><span class=\"line\">a[mySymbol] <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a[<span class=\"string\">'mySymbol'</span>] <span class=\"comment\">// \"Hello!\"</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取 <code>mySymbol</code> 作为标识名所指代的那个值，导致 <code>a</code> 的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s]: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arg</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj[s](<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>s</code> 不放在方括号中，该属性的键名就是字符串 <code>s</code>，而不是<code>s</code> 所代表的那个 Symbol 值。</p><p>采用增强的对象写法，上面代码的 <code>obj</code> 对象可以写得更简洁一些。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [s](arg) &#123; ... &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">log.levels = &#123;</span><br><span class=\"line\">  DEBUG: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'debug'</span>),</span><br><span class=\"line\">  INFO: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'info'</span>),</span><br><span class=\"line\">  WARN: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'warn'</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(log.levels.DEBUG, <span class=\"string\">'debug message'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(log.levels.INFO, <span class=\"string\">'info message'</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> COLOR_RED    = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> COLOR_GREEN  = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getComplement</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (color) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COLOR_RED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> COLOR_GREEN;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COLOR_GREEN:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> COLOR_RED;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Undefined color'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的 <code>switch</code> 语句会按设计的方式工作。</p><p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><h4 id=\"4- 实例 - 消除魔术字符串\"><a class=\"headerlink\" href=\"#4- 实例 - 消除魔术字符串\"></a>4. 实例: 消除魔术字符串 </h4><p> 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shapeType = &#123;</span><br><span class=\"line\">  triangle: <span class=\"string\">'Triangle'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArea</span>(<span class=\"params\">shape, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (shape) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> shapeType.triangle:</span><br><span class=\"line\">      area = <span class=\"number\">.5</span> * options.width * options.height;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> area;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getArea(shapeType.triangle, &#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">height</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id=\"5- 属性名的遍历\"><a class=\"headerlink\" href=\"#5- 属性名的遍历\"></a>5. 属性名的遍历 </h4><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code> 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。</p><p>但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'a'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'b'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">obj[a] = <span class=\"string\">'Hello'</span>;</span><br><span class=\"line\">obj[b] = <span class=\"string\">'World'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">objectSymbols</span><br><span class=\"line\"><span class=\"comment\">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>上面代码是 <code>Object.getOwnPropertySymbols()</code> 方法的示例，可以获取所有 Symbol 属性名。</p><h4 id=\"6Symbol-for-Symbol-keyFor\"><a class=\"headerlink\" href=\"#6Symbol-for-Symbol-keyFor\"></a>6Symbol.for() Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2 <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和 <code>s2</code> 都是 Symbol 值，但是它们都是由同样参数的 <code>Symbol.for</code> 方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与 <code>Symbol()</code> 这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 <code>key</code> 是否已经存在，如果不存在才会新建一个值。比如，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"bar\"</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">\"bar\"</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p> 上面代码中，由于 <code>Symbol()</code> 写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的 <code>key</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>.keyFor(s1) <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>.keyFor(s2) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure><p> 上面代码中，变量 <code>s2</code> 属于未登记的 Symbol 值，所以返回 <code>undefined</code>。</p><p> 注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = foo();</span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === y); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.for('bar')</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行 <code>Symbol.for('bar')</code> 可以取到这个 Symbol 值。</p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">iframe.src = <span class=\"built_in\">String</span>(<span class=\"built_in\">window</span>.location);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">iframe.contentWindow.Symbol.for(<span class=\"string\">'foo'</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p><h3 id=\"Set 和 Map 数据结构\"><a class=\"headerlink\" href=\"#Set 和 Map 数据结构\"></a>Set 和 Map 数据结构 </h3><h4 id=\"1-set\"><a class=\"headerlink\" href=\"#1-set\"></a>1.set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code> 本身是一个构造函数，用来生成 Set 数据结构。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].forEach(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过 <code>add()</code> 方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例一 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class=\"line\">[...<span class=\"keyword\">set</span>]</span><br><span class=\"line\">// [1, 2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">// 例二</span><br><span class=\"line\">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class=\"line\">items.size // 5</span><br><span class=\"line\"></span><br><span class=\"line\">// 例三</span><br><span class=\"line\">const <span class=\"keyword\">set</span> = new Set(document.querySelectorAll('div'));</span><br><span class=\"line\"><span class=\"keyword\">set</span>.size // 56</span><br><span class=\"line\"></span><br><span class=\"line\">// 类似于</span><br><span class=\"line\">const <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\">document</span><br><span class=\"line\"> .querySelectorAll('div')</span><br><span class=\"line\"> .forEach(div =&gt; <span class=\"keyword\">set</span>.add(div));</span><br><span class=\"line\"><span class=\"keyword\">set</span>.size // 56</span><br></pre></td></tr></table></figure><p> 向 Set 加入值的时候，不会发生类型转换，所以 <code>5</code> 和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为 <code>NaN</code> 等于自身，而精确相等运算符认为 <code>NaN</code> 不等于自身。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\">let a = NaN;</span><br><span class=\"line\">let b = NaN;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(a);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(b);</span><br><span class=\"line\"><span class=\"keyword\">set</span> // Set &#123;<span class=\"literal\">NaN</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两次 <code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code> 是相等的。</p><p>另外，两个对象总是不相等的。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.size // 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>.add(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.size // 2</span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><p><strong>Set 实例的属性和方法 </strong></p><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code> 函数。</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为 <code>Set</code> 的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 注意 2 被加入了两次 </span></span><br><span class=\"line\"></span><br><span class=\"line\">s.size <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.has(<span class=\"number\">1</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">s.has(<span class=\"number\">3</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.delete(<span class=\"number\">2</span>);</span><br><span class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p><strong> 遍历操作 </strong></p><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p> 需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</span><br><span class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且，数组的 <code>map</code> 和<code>filter</code>方法也可以间接用于 Set 了。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3]);</span><br><span class=\"line\"><span class=\"keyword\">set</span> = new Set([...<span class=\"keyword\">set</span>].map(x =&gt; x * 2));</span><br><span class=\"line\">// 返回 Set 结构：&#123;<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class=\"line\"><span class=\"keyword\">set</span> = new Set([...<span class=\"keyword\">set</span>].filter(x =&gt; (x % 2) == 0));</span><br><span class=\"line\">// 返回 Set 结构：&#123;<span class=\"number\">2</span>, <span class=\"number\">4</span>&#125;</span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并集 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （a 相对于 b 的）差集</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</span><br><span class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p> 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用 <code>Array.from</code> 方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一 </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3]);</span><br><span class=\"line\"><span class=\"keyword\">set</span> = new Set([...<span class=\"keyword\">set</span>].map(val =&gt; val * 2));</span><br><span class=\"line\">// <span class=\"keyword\">set</span> 的值是 2, 4, 6</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二 </span><br><span class=\"line\">let <span class=\"keyword\">set</span> = new Set([1, 2, 3]);</span><br><span class=\"line\"><span class=\"keyword\">set</span> = new Set(Array.from(<span class=\"keyword\">set</span>, val =&gt; val * 2));</span><br><span class=\"line\">// <span class=\"keyword\">set</span> 的值是 2, 4, 6</span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。回调函数列表，调用时就能保证按照添加顺序调用。</p><h4 id=\"2-WeakSet\"><a class=\"headerlink\" href=\"#2-WeakSet\"></a>2.WeakSet</h4><p><strong>含义 </strong></p><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p> 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</span><br><span class=\"line\">ws.add(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Invalid value used in weak set</span></span><br><span class=\"line\">ws.add(<span class=\"built_in\">Symbol</span>())</span><br><span class=\"line\"><span class=\"comment\">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><h4 id=\"3-Map\"><a class=\"headerlink\" href=\"#3-Map\"></a>3.Map</h4><p><strong>含义 </strong></p><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myDiv'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">data[element] = <span class=\"string\">'metadata'</span>;</span><br><span class=\"line\">data[<span class=\"string\">'[object HTMLDivElement]'</span>] <span class=\"comment\">// \"metadata\"</span></span><br></pre></td></tr></table></figure><p> 上面代码原意是将一个 DOM 节点作为对象 <code>data</code> 的键，但是由于对象只接受字符串作为键名，所以 <code>element</code> 被自动转为字符串 <code>[object HTMLDivElement]</code>。</p><p> 为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;<span class=\"attr\">p</span>: <span class=\"string\">'Hello World'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(o, <span class=\"string\">'content'</span>)</span><br><span class=\"line\">m.get(o) <span class=\"comment\">// \"content\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.delete(o) <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(o) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的 <code>set</code> 方法，将对象 <code>o</code> 当作 <code>m</code> 的一个键，然后又使用 <code>get</code> 方法读取这个键，接着使用 <code>delete</code> 方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><p><strong>遍历方法 </strong></p><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p> 需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><h4 id=\"与其他数据的相互转化\"><a class=\"headerlink\" href=\"# 与其他数据的相互转化\"></a>与其他数据的相互转化 </h4><p><strong>（1）Map 转为数组</strong></p><p> 前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  .set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>)</span><br><span class=\"line\">  .set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</span><br><span class=\"line\">[...myMap]</span><br><span class=\"line\"><span class=\"comment\">// [[ true, 7], [&#123; foo: 3 &#125;, [ 'abc'] ] ]</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"literal\">true</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">  [&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]]</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   true =&gt; 7,</span></span><br><span class=\"line\"><span class=\"comment\">//   Object &#123;foo: 3&#125; =&gt; ['abc']</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象 </strong></p><p> 如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strMapToObj</span>(<span class=\"params\">strMap</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [k,v] <span class=\"keyword\">of</span> strMap) &#123;</span><br><span class=\"line\">    obj[k] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  .set(<span class=\"string\">'yes'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">  .set(<span class=\"string\">'no'</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">strMapToObj(myMap)</span><br><span class=\"line\"><span class=\"comment\">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过 <code>Object.entries()</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><p> 此外，也可以自己实现一个转换函数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objToStrMap</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> strMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.keys(obj)) &#123;</span><br><span class=\"line\">    strMap.set(k, obj[k]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> strMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToStrMap(&#123;<span class=\"attr\">yes</span>: <span class=\"literal\">true</span>, <span class=\"attr\">no</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strMapToJson</span>(<span class=\"params\">strMap</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"string\">'yes'</span>, <span class=\"literal\">true</span>).set(<span class=\"string\">'no'</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">strMapToJson(myMap)</span><br><span class=\"line\"><span class=\"comment\">// '&#123;\"yes\":true,\"no\":false&#125;'</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapToArrayJson</span>(<span class=\"params\">map</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify([...map]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>).set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</span><br><span class=\"line\">mapToArrayJson(myMap)</span><br><span class=\"line\"><span class=\"comment\">// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]'</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonToStrMap</span>(<span class=\"params\">jsonStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> objToStrMap(<span class=\"built_in\">JSON</span>.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap(<span class=\"string\">'&#123;\"yes\": true,\"no\": false&#125;'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">jsonToMap</span>(<span class=\"params\">jsonStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"built_in\">JSON</span>.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToMap(<span class=\"string\">'[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]'</span>)</span><br><span class=\"line\"><span class=\"comment\">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></span><br></pre></td></tr></table></figure><h3 id=\"Proxy\"><a class=\"headerlink\" href=\"#Proxy\"></a>Proxy</h3><h4 id=\"1- 概述 -v2\"><a class=\"headerlink\" href=\"#1- 概述 -v2\"></a>1. 概述 </h4><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function (target, propKey, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;propKey&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, propKey, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function (target, propKey, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;propKey&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p> 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 <code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">//  setting count!</span></span><br><span class=\"line\">++obj.count</span><br><span class=\"line\"><span class=\"comment\">//  getting count!</span></span><br><span class=\"line\"><span class=\"comment\">//  setting count!</span></span><br><span class=\"line\"><span class=\"comment\">//  2</span></span><br></pre></td></tr></table></figure><p> 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(target, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'prototype'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello,'</span> + name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  apply: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, thisBinding, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  construct: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: args[<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fproxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// &#123;value: 2&#125;</span></span><br><span class=\"line\">fproxy.prototype === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">fproxy.foo === <span class=\"string\">\"Hello, foo\"</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如 <code>proxy.foo</code> 和<code>proxy['foo']</code>。</li><li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或<code>proxy['foo'] = v</code>，返回一个布尔值。</li><li><strong>has(target, propKey)</strong>：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</li><li><strong>deleteProperty(target, propKey)</strong>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><strong>ownKeys(target)</strong>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li><li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><h4 id=\"2-Proxy-revocable\"><a class=\"headerlink\" href=\"#2-Proxy-revocable\"></a>2.Proxy.revocable()</h4><p><code>Proxy.revocable()</code> 方法返回一个可取消的 Proxy 实例。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;proxy, revoke&#125; = <span class=\"built_in\">Proxy</span>.revocable(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.foo = <span class=\"number\">123</span>;</span><br><span class=\"line\">proxy.foo <span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">revoke();</span><br><span class=\"line\">proxy.foo <span class=\"comment\">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><h4 id=\"3-this 问题\"><a class=\"headerlink\" href=\"#3-this 问题\"></a>3.this 问题 </h4><p> 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;</span><br><span class=\"line\">  m: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === proxy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">target.m() <span class=\"comment\">// false</span></span><br><span class=\"line\">proxy.m()  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><h3 id=\"Reflect\"><a class=\"headerlink\" href=\"#Reflect\"></a>Reflect</h3><h4 id=\"1- 概述 -v3\"><a class=\"headerlink\" href=\"#1- 概述 -v3\"></a>1. 概述 </h4><p><code>Reflect</code> 对象与 <code>Proxy</code> 对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code>），放到<code>Reflect</code> 对象上。现阶段，某些方法同时在 <code>Object</code> 和<code>Reflect</code>对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上。也就是说，从 <code>Reflect</code> 对象上可以拿到语言内部的方法。</p><p>（2） 修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>（3） 让<code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和<code>delete obj[name]</code>，而 <code>Reflect.has(obj, name)</code> 和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法 </span></span><br><span class=\"line\"><span class=\"string\">'assign'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">'assign'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure><p>（4）<code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管 <code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property'</span> + name + <span class=\"string\">'on'</span> + target + <span class=\"string\">'set to'</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截 <code>target</code> 对象的属性赋值行为。它采用 <code>Reflect.set</code> 方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loggedObj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, name) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'get'</span>, target, name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, name);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  deleteProperty(target, name) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'delete'</span> + name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.deleteProperty(target, name);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  has(target, name) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'has'</span> + name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.has(target, name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个 <code>Proxy</code> 对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的 <code>Reflect</code> 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了 <code>Reflect</code> 对象以后，很多操作会更易读。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法 </span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply.call(<span class=\"built_in\">Math</span>.floor, <span class=\"literal\">undefined</span>, [<span class=\"number\">1.75</span>]) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.apply(<span class=\"built_in\">Math</span>.floor, <span class=\"literal\">undefined</span>, [<span class=\"number\">1.75</span>]) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure><h4 id=\"2- 静态方法\"><a class=\"headerlink\" href=\"#2- 静态方法\"></a>2. 静态方法</h4><p><code>Reflect</code> 对象一共有 13 个静态方法。</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>上面这些方法的作用，大部分与 <code>Object</code> 对象的同名方法的作用都是相同的，而且它与 <code>Proxy</code> 对象的方法是一一对应的。下面是对它们的解释。</p><h3 id=\"Promise 对象\"><a class=\"headerlink\" href=\"#Promise 对象\"></a>Promise 对象 </h3><h4 id=\"1-Promise 的含义\"><a class=\"headerlink\" href=\"#1-Promise 的含义\"></a>1.Promise 的含义</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code> 对象。</p><p><code>Promise</code>对象有以下两个特点 </p><p>（1）对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code> 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code> 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><h4 id=\"2- 基本用法\"><a class=\"headerlink\" href=\"#2- 基本用法\"></a>2. 基本用法 </h4><p>ES6 规定，<code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。</p><p>下面代码创造了一个 <code>Promise</code> 实例。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>p1</code>和 <code>p2</code> 都是 Promise 的实例，但是 <code>p2</code> 的<code>resolve</code>方法将 <code>p1</code> 作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时 <code>p1</code> 的状态就会传递给 <code>p2</code>，也就是说，<code>p1</code> 的状态决定了 <code>p2</code> 的状态。如果 <code>p1</code> 的状态是 <code>pending</code>，那么<code>p2</code> 的回调函数就会等待 <code>p1</code> 的状态改变；如果 <code>p1</code> 的状态已经是 <code>resolved</code> 或者 <code>rejected</code>，那么<code>p2</code> 的回调函数将会立刻执行。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'fail'</span>)), <span class=\"number\">3000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(p1), <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">p2</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"built_in\">console</span>.log(result))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error))</span><br><span class=\"line\"><span class=\"comment\">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为 <code>rejected</code>。<code>p2</code> 的状态在 1 秒之后改变，<code>resolve</code>方法返回的是 <code>p1</code>。由于<code>p2</code> 返回的是另一个 Promise，导致 <code>p2</code> 自己的状态无效了，由 <code>p1</code> 的状态决定 <code>p2</code> 的状态。所以，后面的 <code>then</code> 语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为 <code>rejected</code>，导致触发<code>catch</code> 方法指定的回调函数。</p><p>注意，调用 <code>resolve</code> 或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><h4 id=\"3-Promise-prototype-then\"><a class=\"headerlink\" href=\"#3-Promise-prototype-then\"></a>3.Promise.prototype.then()</h4><p>Promise 实例具有 <code>then</code> 方法，也就是说，<code>then</code>方法是定义在原型对象 <code>Promise.prototype</code> 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是 <code>resolved</code> 状态的回调函数，第二个参数是 <code>rejected</code> 状态的回调函数，它们都是可选的。</p><p><code>then</code>方法返回的是一个新的 <code>Promise</code> 实例（注意，不是原来那个 <code>Promise</code> 实例）。因此可以采用链式写法，即 <code>then</code> 方法后面再调用另一个 <code>then</code> 方法。</p><h4 id=\"4-Promise-prototype-catch\"><a class=\"headerlink\" href=\"#4-Promise-prototype-catch\"></a>4.Promise.prototype.catch()</h4><p><code>Promise.prototype.catch()</code>方法是 <code>.then(null, rejection)</code> 或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误 </span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><h4 id=\"5-Promise-prototype-finally\"><a class=\"headerlink\" href=\"#5-Promise-prototype-finally\"></a>5.Promise.prototype.finally()</h4><p><code>finally()</code> 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class=\"line\">.finally(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管 <code>promise</code> 最后的状态，在执行完 <code>then</code> 或<code>catch</code>指定的回调函数以后，都会执行 <code>finally</code> 方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用 <code>finally</code> 方法关掉服务器。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.listen(port)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(server.stop);</span><br></pre></td></tr></table></figure><h4 id=\"6-Promise-all\"><a class=\"headerlink\" href=\"#6-Promise-all\"></a>6.Promise.all()</h4><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的 <code>Promise.resolve</code> 方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由 <code>p1</code>、<code>p2</code>、<code>p3</code> 决定，分成两种情况。</p><p>（1）只有 <code>p1</code>、<code>p2</code>、<code>p3</code> 的状态都变成 <code>fulfilled</code>，<code>p</code> 的状态才会变成 <code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code> 的返回值组成一个数组，传递给 <code>p</code> 的回调函数。</p><p>（2）只要 <code>p1</code>、<code>p2</code>、<code>p3</code> 之中有一个被 <code>rejected</code>，<code>p</code> 的状态就变成 <code>rejected</code>，此时第一个被<code>reject</code> 的实例的返回值，会传递给 <code>p</code> 的回调函数。</p><h4 id=\"7-Promise-race\"><a class=\"headerlink\" href=\"#7-Promise-race\"></a>7.Promise.race()</h4><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 <code>p1</code>、<code>p2</code>、<code>p3</code> 之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 <code>p</code> 的回调函数。</p><p><code>Promise.race()</code>方法的参数与 <code>Promise.all()</code> 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 <code>Promise.resolve()</code> 方法，将参数转为 Promise 实例，再进一步处理。</p><h4 id=\"8-Promise-allSettled\"><a class=\"headerlink\" href=\"#8-Promise-allSettled\"></a>8.Promise.allSettled()</h4><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p><p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是 <code>fulfilled</code> 还是 <code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p><h4 id=\"9-Promise-any\"><a class=\"headerlink\" href=\"#9-Promise-any\"></a>9.Promise.any()</h4><p>ES2021 引入了<code>Promise.any()</code> 方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><p>只要参数实例有一个变成 <code>fulfilled</code> 状态，包装实例就会变成 <code>fulfilled</code> 状态；如果所有参数实例都变成 <code>rejected</code> 状态，包装实例就会变成 <code>rejected</code> 状态。</p><p><code>Promise.any()</code>跟 <code>Promise.race()</code> 方法很像，只有一点不同，就是 <code>Promise.any()</code> 不会因为某个 Promise 变成 <code>rejected</code> 状态而结束，必须等到所有参数 Promise 变成 <code>rejected</code> 状态才会结束。</p><h4 id=\"10-Promise-resole\"><a class=\"headerlink\" href=\"#10-Promise-resole\"></a>10.Promise.resole()</h4><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用 </p><h4 id=\"11-Promise-reject\"><a class=\"headerlink\" href=\"#11-Promise-reject\"></a>11.Promise.reject()</h4><p><code>Promise.reject(reason)</code> 方法也会返回一个新的 Promise 实例，该实例的状态为 <code>rejected</code>。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"string\">'出错了'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br></pre></td></tr></table></figure><h4 id=\"12- 应用\"><a class=\"headerlink\" href=\"#12- 应用\"></a>12. 应用</h4><p><strong> 图片加载 </strong></p><p> 我们可以将图片的加载写成一个 <code>Promise</code>，一旦加载完成，<code>Promise</code> 的状态就发生变化。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> preloadImage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    image.onload  = resolve;</span><br><span class=\"line\">    image.onerror = reject;</span><br><span class=\"line\">    image.src = path;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Generator 函数 Promise 的结合</strong></p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFoo</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'foo'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> foo = <span class=\"keyword\">yield</span> getFoo();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(foo);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span> (<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> it = generator();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result.value.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> go(it.next(value));</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> go(it.throw(error));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  go(it.next());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(g);</span><br></pre></td></tr></table></figure><h4 id=\"13-Promise-try\"><a class=\"headerlink\" href=\"#13-Promise-try\"></a>13.Promise.try()</h4>","url":"/posts/13229/","min2read":87,"word4post":"20.7k","prev_post":{"title":"React 的生命周期验证","url":"/posts/36377/"},"next_post":{"title":"antd 中 Table 的 dataSource 不更新？？","url":"/posts/34168/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"ES6 小结\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">ES6 小结 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"let 和 const\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">let 和 const</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-let- 命令\" href = \"#\"><span class=\"toc-number\">1.1.1.</span> <span class=\"toc-text\">1.let 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"块级作用域\" href = \"#\"><span class=\"toc-number\">1.1.2.</span> <span class=\"toc-text\"> 块级作用域 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"不存在变量提升\" href = \"#\"><span class=\"toc-number\">1.1.3.</span> <span class=\"toc-text\"> 不存在变量提升 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"暂时性死区\" href = \"#\"><span class=\"toc-number\">1.1.4.</span> <span class=\"toc-text\"> 暂时性死区 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"不允许重复声明\" href = \"#\"><span class=\"toc-number\">1.1.5.</span> <span class=\"toc-text\"> 不允许重复声明 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 块级作用域\" href = \"#\"><span class=\"toc-number\">1.1.6.</span> <span class=\"toc-text\">2. 块级作用域</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"函数声明\" href = \"#\"><span class=\"toc-number\">1.1.7.</span> <span class=\"toc-text\"> 函数声明 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-const- 命令\" href = \"#\"><span class=\"toc-number\">1.1.8.</span> <span class=\"toc-text\">3.const 命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"ES6- 中声明变量有 6 中方法\" href = \"#\"><span class=\"toc-number\">1.1.9.</span> <span class=\"toc-text\">ES6 中声明变量有 6 中方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 顶层对象属性\" href = \"#\"><span class=\"toc-number\">1.1.10.</span> <span class=\"toc-text\">4. 顶层对象属性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"变量和结构赋值\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\"> 变量和结构赋值 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 数组的结构赋值\" href = \"#\"><span class=\"toc-number\">1.2.1.</span> <span class=\"toc-text\">1. 数组的结构赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"默认值\" href = \"#\"><span class=\"toc-number\">1.2.2.</span> <span class=\"toc-text\">默认值 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 对象的解构赋值\" href = \"#\"><span class=\"toc-number\">1.2.3.</span> <span class=\"toc-text\">2. 对象的解构赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"注意点\" href = \"#\"><span class=\"toc-number\">1.2.4.</span> <span class=\"toc-text\">注意点 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 字符串的解构赋值\" href = \"#\"><span class=\"toc-number\">1.2.5.</span> <span class=\"toc-text\">3. 字符串的解构赋值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 数值和布尔值的解构赋值\" href = \"#\"><span class=\"toc-number\">1.2.6.</span> <span class=\"toc-text\">4. 数值和布尔值的解构赋值 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5- 函数参数的解构赋值\" href = \"#\"><span class=\"toc-number\">1.2.7.</span> <span class=\"toc-text\">5. 函数参数的解构赋值 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6- 圆括号问题\" href = \"#\"><span class=\"toc-number\">1.2.8.</span> <span class=\"toc-text\">6. 圆括号问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7- 用途\" href = \"#\"><span class=\"toc-number\">1.2.9.</span> <span class=\"toc-text\">7. 用途</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"字符串的扩展\" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">字符串的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 字符的 Unicode 表示法\" href = \"#\"><span class=\"toc-number\">1.3.1.</span> <span class=\"toc-text\">1. 字符的 Unicode 表示法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 字符串的遍历器接口\" href = \"#\"><span class=\"toc-number\">1.3.2.</span> <span class=\"toc-text\">2. 字符串的遍历器接口 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 直接输入 -U-2028- 和 -U-2029\" href = \"#\"><span class=\"toc-number\">1.3.3.</span> <span class=\"toc-text\">3. 直接输入 U+2028 和 U+2029</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4-JSON-stringify- 的改造\" href = \"#\"><span class=\"toc-number\">1.3.4.</span> <span class=\"toc-text\">4.JSON.stringify() 的改造 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5- 模板字符串\" href = \"#\"><span class=\"toc-number\">1.3.5.</span> <span class=\"toc-text\">5. 模板字符串</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6- 实例：模板编译\" href = \"#\"><span class=\"toc-number\">1.3.6.</span> <span class=\"toc-text\">6. 实例：模板编译</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7- 标签模板\" href = \"#\"><span class=\"toc-number\">1.3.7.</span> <span class=\"toc-text\">7. 标签模板</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 字符串的新增方法 \" href = \"#\"><span class=\"toc-number\">1.4.</span> <span class=\"toc-text\"> 字符串的新增方法 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-String-fromCodePoint\" href = \"#\"><span class=\"toc-number\">1.4.1.</span> <span class=\"toc-text\">1. String.fromCodePoint()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-String-raw\" href = \"#\"><span class=\"toc-number\">1.4.2.</span> <span class=\"toc-text\">2.String.raw()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 实例方法：codePointAt\" href = \"#\"><span class=\"toc-number\">1.4.3.</span> <span class=\"toc-text\">3. 实例方法：codePointAt()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 实例方法 \" href = \"#\"><span class=\"toc-number\">1.4.4.</span> <span class=\"toc-text\">4. 实例方法 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5-repeat\" href = \"#\"><span class=\"toc-number\">1.4.5.</span> <span class=\"toc-text\">5. repeat()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6- 实例方法 -padStart-padEnd\" href = \"#\"><span class=\"toc-number\">1.4.6.</span> <span class=\"toc-text\">6. 实例方法 padStart(),padEnd()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7- 实例方法：trimStart-trimEnd\" href = \"#\"><span class=\"toc-number\">1.4.7.</span> <span class=\"toc-text\">7. 实例方法：trimStart(), trimEnd()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"8- 实例方法：-matchAll\" href = \"#\"><span class=\"toc-number\">1.4.8.</span> <span class=\"toc-text\">8. 实例方法： matchAll()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"9- 实例方法：replaceAll\" href = \"#\"><span class=\"toc-number\">1.4.9.</span> <span class=\"toc-text\">9. 实例方法：replaceAll()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"10-at\" href = \"#\"><span class=\"toc-number\">1.4.10.</span> <span class=\"toc-text\">10 at()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 正则的扩展 \" href = \"#\"><span class=\"toc-number\">1.4.11.</span> <span class=\"toc-text\"> 正则的扩展 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-RegExp- 构造函数 \" href = \"#\"><span class=\"toc-number\">1.4.12.</span> <span class=\"toc-text\">1.RegExp 构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-RegExp-prototype-sticky- 属性 \" href = \"#\"><span class=\"toc-number\">1.4.13.</span> <span class=\"toc-text\">2.RegExp.prototype.sticky 属性 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-RegExp-prototype-flags- 属性 \" href = \"#\"><span class=\"toc-number\">1.4.14.</span> <span class=\"toc-text\">3.RegExp.prototype.flags 属性 </span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 数值的扩展 \" href = \"#\"><span class=\"toc-number\">1.5.</span> <span class=\"toc-text\"> 数值的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 二进制和八进制表示法 \" href = \"#\"><span class=\"toc-number\">1.5.1.</span> <span class=\"toc-text\">1. 二进制和八进制表示法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 数值分隔符 \" href = \"#\"><span class=\"toc-number\">1.5.2.</span> <span class=\"toc-text\">2. 数值分隔符 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-Number-isFinite-，Number-isNaN\" href = \"#\"><span class=\"toc-number\">1.5.3.</span> <span class=\"toc-text\">3.Number.isFinite()，Number.isNaN()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4-Number-parseInt-Number-parseFloat\" href = \"#\"><span class=\"toc-number\">1.5.4.</span> <span class=\"toc-text\">4.Number.parseInt(), Number.parseFloat()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5-Number-isInteger\" href = \"#\"><span class=\"toc-number\">1.5.5.</span> <span class=\"toc-text\">5.Number.isInteger()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6-Number-EPSILON\" href = \"#\"><span class=\"toc-number\">1.5.6.</span> <span class=\"toc-text\">6.Number.EPSILON</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7- 安全整数和 -Number-isSafeInteger。\" href = \"#\"><span class=\"toc-number\">1.5.7.</span> <span class=\"toc-text\">7. 安全整数和 Number.isSafeInteger。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"8-Math- 对象的扩展 \" href = \"#\"><span class=\"toc-number\">1.5.8.</span> <span class=\"toc-text\">8.Math 对象的扩展 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"9-BigInt- 数据类型\" href = \"#\"><span class=\"toc-number\">1.5.9.</span> <span class=\"toc-text\">9.BigInt 数据类型 </span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"函数的扩展\" href = \"#\"><span class=\"toc-number\">1.6.</span> <span class=\"toc-text\">函数的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1 函数的默认参数\" href = \"#\"><span class=\"toc-number\">1.6.1.</span> <span class=\"toc-text\">1 函数的默认参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 与解构赋值默认值结合使用 \" href = \"#\"><span class=\"toc-number\">1.6.2.</span> <span class=\"toc-text\"> 与解构赋值默认值结合使用 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 函数的 length 属性 \" href = \"#\"><span class=\"toc-number\">1.6.3.</span> <span class=\"toc-text\">函数的 length 属性 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 作用域 \" href = \"#\"><span class=\"toc-number\">1.6.4.</span> <span class=\"toc-text\">作用域 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 应用 \" href = \"#\"><span class=\"toc-number\">1.6.5.</span> <span class=\"toc-text\">应用 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-rest 参数 \" href = \"#\"><span class=\"toc-number\">1.6.6.</span> <span class=\"toc-text\">2.rest 参数 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 严格模式 \" href = \"#\"><span class=\"toc-number\">1.6.7.</span> <span class=\"toc-text\">3. 严格模式 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4-name- 属性 \" href = \"#\"><span class=\"toc-number\">1.6.8.</span> <span class=\"toc-text\">4.name 属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5- 箭头函数 \" href = \"#\"><span class=\"toc-number\">1.6.9.</span> <span class=\"toc-text\">5. 箭头函数 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6- 尾调用优化 \" href = \"#\"><span class=\"toc-number\">1.6.10.</span> <span class=\"toc-text\">6. 尾调用优化 </span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\" 数组的扩展 \" href = \"#\"><span class=\"toc-number\">1.7.</span> <span class=\"toc-text\">数组的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 扩展运算符 \" href = \"#\"><span class=\"toc-number\">1.7.1.</span> <span class=\"toc-text\">1. 扩展运算符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 替代函数的 apply 方法 \" href = \"#\"><span class=\"toc-number\">1.7.2.</span> <span class=\"toc-text\"> 替代函数的 apply 方法 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\" 扩展运算符的应用 \" href = \"#\"><span class=\"toc-number\">1.7.3.</span> <span class=\"toc-text\"> 扩展运算符的应用 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-Array-from\" href = \"#\"><span class=\"toc-number\">1.7.4.</span> <span class=\"toc-text\">2.Array.from()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-Array-of\" href = \"#\"><span class=\"toc-number\">1.7.5.</span> <span class=\"toc-text\">3.Array.of()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 实例方法：copyWithin\" href = \"#\"><span class=\"toc-number\">1.7.6.</span> <span class=\"toc-text\">4. 实例方法：copyWithin()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5-find- 和 findIndex\" href = \"#\"><span class=\"toc-number\">1.7.7.</span> <span class=\"toc-text\">5.find()和 findIndex()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6- 实例方法：fill\" href = \"#\"><span class=\"toc-number\">1.7.8.</span> <span class=\"toc-text\">6. 实例方法：fill()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7-entries-keys-values\" href = \"#\"><span class=\"toc-number\">1.7.9.</span> <span class=\"toc-text\">7.entries() keys() values()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"8-includes\" href = \"#\"><span class=\"toc-number\">1.7.10.</span> <span class=\"toc-text\">8.includes()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"9- 实例方法：flat-flatMap\" href = \"#\"><span class=\"toc-number\">1.7.11.</span> <span class=\"toc-text\">9. 实例方法：flat(),flatMap()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"10- 数组的空位\" href = \"#\"><span class=\"toc-number\">1.7.12.</span> <span class=\"toc-text\">10. 数组的空位</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"对象的扩展\" href = \"#\"><span class=\"toc-number\">1.8.</span> <span class=\"toc-text\">对象的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 属性的简洁表示法\" href = \"#\"><span class=\"toc-number\">1.8.1.</span> <span class=\"toc-text\">1. 属性的简洁表示法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 属性名表达式\" href = \"#\"><span class=\"toc-number\">1.8.2.</span> <span class=\"toc-text\">2. 属性名表达式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 方法的 name 属性\" href = \"#\"><span class=\"toc-number\">1.8.3.</span> <span class=\"toc-text\">3. 方法的 name 属性 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 属性的可枚举性和遍历\" href = \"#\"><span class=\"toc-number\">1.8.4.</span> <span class=\"toc-text\">4. 属性的可枚举性和遍历 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5-super 关键字\" href = \"#\"><span class=\"toc-number\">1.8.5.</span> <span class=\"toc-text\">5.super 关键字 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"对象的新增方法\" href = \"#\"><span class=\"toc-number\">1.8.6.</span> <span class=\"toc-text\"> 对象的新增方法 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-Object-is\" href = \"#\"><span class=\"toc-number\">1.8.7.</span> <span class=\"toc-text\">1.Object.is()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-Object-assign\" href = \"#\"><span class=\"toc-number\">1.8.8.</span> <span class=\"toc-text\">2.Object.assign()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"常见用途\" href = \"#\"><span class=\"toc-number\">1.8.9.</span> <span class=\"toc-text\">常见用途 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-Object-getOwnPropertyDescriptors\" href = \"#\"><span class=\"toc-number\">1.8.10.</span> <span class=\"toc-text\">3.Object.getOwnPropertyDescriptors()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4-proto\" href = \"#\"><span class=\"toc-number\">1.8.11.</span> <span class=\"toc-text\">4.proto</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"运算符的扩展\" href = \"#\"><span class=\"toc-number\">1.9.</span> <span class=\"toc-text\">运算符的扩展 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 指数运算符\" href = \"#\"><span class=\"toc-number\">1.9.1.</span> <span class=\"toc-text\">1. 指数运算符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 链判断运算符\" href = \"#\"><span class=\"toc-number\">1.9.2.</span> <span class=\"toc-text\">2. 链判断运算符 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3Null 判断运算符\" href = \"#\"><span class=\"toc-number\">1.9.3.</span> <span class=\"toc-text\">3Null 判断运算符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 逻辑赋值运算符\" href = \"#\"><span class=\"toc-number\">1.9.4.</span> <span class=\"toc-text\">4. 逻辑赋值运算符</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Symbol\" href = \"#\"><span class=\"toc-number\">1.10.</span> <span class=\"toc-text\">Symbol</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 概述\" href = \"#\"><span class=\"toc-number\">1.10.1.</span> <span class=\"toc-text\">1. 概述 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-Symbol-prototype-description\" href = \"#\"><span class=\"toc-number\">1.10.2.</span> <span class=\"toc-text\">2.Symbol.prototype.description</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3- 作为属性名的 Symbol\" href = \"#\"><span class=\"toc-number\">1.10.3.</span> <span class=\"toc-text\">3. 作为属性名的 Symbol</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4- 实例 - 消除魔术字符串\" href = \"#\"><span class=\"toc-number\">1.10.4.</span> <span class=\"toc-text\">4. 实例: 消除魔术字符串 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5- 属性名的遍历\" href = \"#\"><span class=\"toc-number\">1.10.5.</span> <span class=\"toc-text\">5. 属性名的遍历 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6Symbol-for-Symbol-keyFor\" href = \"#\"><span class=\"toc-number\">1.10.6.</span> <span class=\"toc-text\">6Symbol.for() Symbol.keyFor()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Set 和 Map 数据结构\" href = \"#\"><span class=\"toc-number\">1.11.</span> <span class=\"toc-text\">Set 和 Map 数据结构 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-set\" href = \"#\"><span class=\"toc-number\">1.11.1.</span> <span class=\"toc-text\">1.set</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-WeakSet\" href = \"#\"><span class=\"toc-number\">1.11.2.</span> <span class=\"toc-text\">2.WeakSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-Map\" href = \"#\"><span class=\"toc-number\">1.11.3.</span> <span class=\"toc-text\">3.Map</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"与其他数据的相互转化\" href = \"#\"><span class=\"toc-number\">1.11.4.</span> <span class=\"toc-text\">与其他数据的相互转化 </span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Proxy\" href = \"#\"><span class=\"toc-number\">1.12.</span> <span class=\"toc-text\">Proxy</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 概述 -v2\" href = \"#\"><span class=\"toc-number\">1.12.1.</span> <span class=\"toc-text\">1. 概述 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2-Proxy-revocable\" href = \"#\"><span class=\"toc-number\">1.12.2.</span> <span class=\"toc-text\">2.Proxy.revocable()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-this 问题\" href = \"#\"><span class=\"toc-number\">1.12.3.</span> <span class=\"toc-text\">3.this 问题 </span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Reflect\" href = \"#\"><span class=\"toc-number\">1.13.</span> <span class=\"toc-text\">Reflect</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1- 概述 -v3\" href = \"#\"><span class=\"toc-number\">1.13.1.</span> <span class=\"toc-text\">1. 概述 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 静态方法\" href = \"#\"><span class=\"toc-number\">1.13.2.</span> <span class=\"toc-text\">2. 静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"Promise 对象\" href = \"#\"><span class=\"toc-number\">1.14.</span> <span class=\"toc-text\">Promise 对象 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"1-Promise 的含义\" href = \"#\"><span class=\"toc-number\">1.14.1.</span> <span class=\"toc-text\">1.Promise 的含义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"2- 基本用法\" href = \"#\"><span class=\"toc-number\">1.14.2.</span> <span class=\"toc-text\">2. 基本用法 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"3-Promise-prototype-then\" href = \"#\"><span class=\"toc-number\">1.14.3.</span> <span class=\"toc-text\">3.Promise.prototype.then()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"4-Promise-prototype-catch\" href = \"#\"><span class=\"toc-number\">1.14.4.</span> <span class=\"toc-text\">4.Promise.prototype.catch()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"5-Promise-prototype-finally\" href = \"#\"><span class=\"toc-number\">1.14.5.</span> <span class=\"toc-text\">5.Promise.prototype.finally()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"6-Promise-all\" href = \"#\"><span class=\"toc-number\">1.14.6.</span> <span class=\"toc-text\">6.Promise.all()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"7-Promise-race\" href = \"#\"><span class=\"toc-number\">1.14.7.</span> <span class=\"toc-text\">7.Promise.race()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"8-Promise-allSettled\" href = \"#\"><span class=\"toc-number\">1.14.8.</span> <span class=\"toc-text\">8.Promise.allSettled()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"9-Promise-any\" href = \"#\"><span class=\"toc-number\">1.14.9.</span> <span class=\"toc-text\">9.Promise.any()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"10-Promise-resole\" href = \"#\"><span class=\"toc-number\">1.14.10.</span> <span class=\"toc-text\">10.Promise.resole()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"11-Promise-reject\" href = \"#\"><span class=\"toc-number\">1.14.11.</span> <span class=\"toc-text\">11.Promise.reject()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"12- 应用\" href = \"#\"><span class=\"toc-number\">1.14.12.</span> <span class=\"toc-text\">12. 应用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"13-Promise-try\" href = \"#\"><span class=\"toc-number\">1.14.13.</span> <span class=\"toc-text\">13.Promise.try()</span></a></li></ol></li></ol></li></ol>","categories":[{"name":"-ES6","path":"api/categories/-ES6.json","url":"/categories/ES6/"}],"tags":[{"name":"小结","path":"api/tags/小结.json","url":"/tags/小结/"}]}