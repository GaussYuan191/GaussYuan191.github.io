{"title":"React 的生命周期验证","slug":"React的生命周期验证","date":"2022-01-24","updated":"2022-01-24","comments":true,"path":"api/posts/36377.json","excerpt":"<p></p>","cover":"/gallery/react-bg.jpeg","covers":["/gallery/react-bg.jpeg"],"content":"<p><img src=\"/gallery/react-bg.jpeg\" alt=\"\"></p><a id=\"more\"></a><p>今天我们来验证一下 <code>React</code> 类组件的声明周期，本文基于 <code>React17.2</code>。</p><p><img src=\"/gallery/react-life-constructor.png\"alt=\"\"></p><h1 id=\"单组件\"><a class=\"headerlink\" href=\"# 单组件\"></a> 单组件 </h1><h2 id=\"组件挂载\"><a class=\"headerlink\" href=\"# 组件挂载\"></a> 组件挂载 </h2><h3 id=\"constructor\"><a class=\"headerlink\" href=\"#constructor\"></a>constructor()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"constructor!!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong> 如果不初始化 state 或不进行方法的绑定，则不需要为 React 组件实现构造函数 </strong></p><p> 实现构造函数的时候要调用 super(), 初始化父类 </p><p> 在构造函数仅用于以下两种情况：</p><ul><li>通过 this.state 赋值对象来初始化内部的 state。</li><li>为事件处理函数绑定实例 </li></ul><p> 不要在 constructor()中调用 <strong>setState() 方法 </strong>，用 this.state 初始化 state</p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">  <span class=\"comment\">// 不要在这里调用 this.setState()</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">counter</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 避免在构造函数中引入任何副作用或订阅。如遇到此场景，请将对应的操作位置放到 <code>componentDidMount</code></p><h3 id=\"static-getDerivedStateFromProps\"><a class=\"headerlink\" href=\"#static-getDerivedStateFromProps\"></a>static getDerivedStateFromProps()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"getDerivedStateFromProps!!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>getDerivedStateFromPros</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它返回一个新的 state，如果是 null 则不更新任何内容，state 的值在任何时候都取决于 prop。</p><p> 派生状态会导致代码冗余，并使组件难以维护，可以使用以下代替方案：</p><ul><li>如果你需要执行副作用 (例如，数据提取或动画) 以响应 props 中的更改，请改用 componentDidUpdate。</li><li>如果只想在 props 更改时重新计算某些数据，请使用 menoization helper 代替 </li><li> 如果你想在 props 更改时“重置”某些 state，请考虑组件完全受控或使用 key 使组件完全不受控代替 </li></ul><p> 请注意，不管原因是什么，都会在 <em> 每次 </em> 渲染前触发此方法。这与 <code>UNSAFE_componentWillReceiveProps</code> 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 <code>setState</code> 时。</p><h3 id=\"render\"><a class=\"headerlink\" href=\"#render\"></a>render()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render()</span><br></pre></td></tr></table></figure><p><code>render</code>方法是 class 组件中唯一必需实现的方法 </p><p> 当<code>render</code>被调用时，它会检查 <code>this.props</code> 和<code>this.state</code>的变化返回以下类型之一：</p><ul><li>React 元素。通常通过 JSX 创建 </li><li> 数组或者 fragments</li><li>Portals 可以 渲染子节点到不同的 DOM 树上 </li><li> 字符串或者数值类型 它们在 DOM 树上渲染文本节点 </li><li> 布尔类型或 null 什么都不渲染 </li></ul><p><code>render()</code> 函数为纯函数 </p><p><strong> 注意 如果 shouldComponentUpdate() 返回 false，则不会调用 render()</strong></p><h3 id=\"componentDidMount\"><a class=\"headerlink\" href=\"#componentDidMount\"></a>componentDidMount()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount()</span><br></pre></td></tr></table></figure><p><code>componentDidMount</code>会在组件挂载后 (插到 DOM 树上) 立即调用。依赖于 DOM 节点的初始化应该放到在这里。</p><p>如果是通过网络请求获取的数据也应该放到这里请求。也可以在这里添加订阅，如果订阅了，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅 </p><p><img src=\"/gallery/react-constructor-life.png\" alt=\"\"></p><h2 id=\" 组件更新 \"><a class=\"headerlink\"href=\"# 组件更新 \"></a> 组件更新 </h2><p><strong>static getDerivedStateFromProps()</strong></p><h3 id=\"shouldComponentUpdate\"><a class=\"headerlink\"href=\"#shouldComponentUpdate\"></a>shouldComponentUpdate()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate(nextprops, nextState)</span><br></pre></td></tr></table></figure><p><img src=\"/gallery/shouldcomponentupdate.png\"alt=\"\"></p><p>nextprops, nextState 都是将要改变的值</p><p> 根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下都应遵守默认行为。当 props 或 state 发生改变时。<code>shouldComponentUpdate()</code>会在渲染执行前调用，返回值默认是 true。首次渲染或者使用 <code>forceUpdate()</code> 时不会调用。该方法仅作为 <strong> 性能优化 </strong> 的方式存在。</p><p><strong>render()</strong></p><h3 id=\"getSnapshotBeforeUpdate\"><a class=\"headerlink\" href=\"#getSnapshotBeforeUpdate\"></a>getSnapshotBeforeUpdate()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getSnapshotBeforeUpdate(prevProps, prevState)</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate()</code>在最近一次渲染输出 (提交到 DOM 节点) 之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息 (例如，滚动位置)。此生命周期方法的任何返回值将作为参数传递给<code>componentDidUpdate()</code>, 在 UI 处理中，如需以特殊方式处理滚动位置的聊天线程可用此生命周期，应返回 snapshot 的值(或 null)</p><h3 id=\"componentDidUpdate\"><a class=\"headerlink\" href=\"#componentDidUpdate\"></a>componentDidUpdate()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure><p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p><p>当组件更新后，可以在此处对 DOM 进行操作，如果你对更新的 props 进行了比较，也可以选择在此处进行网络请求。例如，当 props 未发生变化时，则不会执行网络请求。可以在这里使用 setState(), 但它必需被包裹在一个条件语句里，否则还会导死循环, 它还会导致额外的重新渲染，影响组件性能，不要将 props 镜像给 state</p><p><img src=\"/gallery/react-update-life.png\" alt=\"\"></p><h2 id=\" 组件卸载 \"><a class=\"headerlink\"href=\"# 组件卸载 \"></a>组件卸载 </h2><h3 id=\"componentWillUnmount\"><a class=\"headerlink\"href=\"#componentWillUnmount\"></a>componentWillUnmount()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillUnmount()</span><br></pre></td></tr></table></figure><p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer、网络请求、订阅，不能调用 setState(), 因为不会重新渲染。</p><p><img src=\"/gallery/react-willUnmount-life.png\"alt=\"\"></p><h1 id=\"同时渲染的父子组件\"><a class=\"headerlink\" href=\"# 同时渲染的父子组件\"></a>同时渲染的父子组件 </h1><h2 id=\"组件挂载 -v2\"><a class=\"headerlink\" href=\"# 组件挂载 -v2\"></a> 组件挂载 </h2><p><img src=\"/gallery/react-p-constructor-life.png\" alt=\"\"></p><h2 id=\" 父组件更新 \"><a class=\"headerlink\"href=\"# 父组件更新 \"></a> 父组件更新 </h2><p><img src=\"/gallery/react-p-update-life.png\"alt=\"\"></p><h2 id=\"组件卸载 -v2\"><a class=\"headerlink\" href=\"# 组件卸载 -v2\"></a> 组件卸载 </h2><p><img src=\"/gallery/react-p-willUnmount-life.png\" alt=\"\"></p><p><strong> 注意，先是显示要渲染的组件，当组件调用 render 方法时，上个组件才到卸载的生命周期 </strong></p><h1 id=\" 不同时渲染的父子组件 \"><a class=\"headerlink\"href=\"# 不同时渲染的父子组件 \"></a> 不同时渲染的父子组件 </h1><p> 该场景中，通过父组件的点击 modal 来控制子组件显示 </p><h2 id=\" 组件挂载 -v3\"><a class=\"headerlink\"href=\"# 组件挂载 -v3\"></a> 组件挂载 </h2><p><img src=\"/gallery/react-a-constructor-life.png\"alt=\"\"></p><h1 id=\"在父组件挂载的时候，请求数据\"><a class=\"headerlink\" href=\"# 在父组件挂载的时候，请求数据\"></a> 在父组件挂载的时候，请求数据 </h1><p><img src=\"/gallery/react-axios-constructor-life.png\" alt=\"\"></p><p> 最后附上本文的代码：<a href=\"https://github.com/GaussYuan191/react-life\"target=\"_blank\"rel=\"noopener external nofollow noreferrer\">代码</a></p>","url":"/posts/36377/","min2read":4,"word4post":"1.3k","prev_post":{"title":"JS 中 == 与 ===","url":"/posts/33716/"},"next_post":{"title":"ES6","url":"/posts/13229/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"单组件\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\"> 单组件 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"组件挂载\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\"> 组件挂载 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"constructor\" href = \"#\"><span class=\"toc-number\">1.1.1.</span> <span class=\"toc-text\">constructor()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"static-getDerivedStateFromProps\" href = \"#\"><span class=\"toc-number\">1.1.2.</span> <span class=\"toc-text\">static getDerivedStateFromProps()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"render\" href = \"#\"><span class=\"toc-number\">1.1.3.</span> <span class=\"toc-text\">render()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"componentDidMount\" href = \"#\"><span class=\"toc-number\">1.1.4.</span> <span class=\"toc-text\">componentDidMount()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\" 组件更新 \" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\"> 组件更新 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"shouldComponentUpdate\" href = \"#\"><span class=\"toc-number\">1.2.1.</span> <span class=\"toc-text\">shouldComponentUpdate()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"getSnapshotBeforeUpdate\" href = \"#\"><span class=\"toc-number\">1.2.2.</span> <span class=\"toc-text\">getSnapshotBeforeUpdate()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"componentDidUpdate\" href = \"#\"><span class=\"toc-number\">1.2.3.</span> <span class=\"toc-text\">componentDidUpdate()</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\" 组件卸载 \" href = \"#\"><span class=\"toc-number\">1.3.</span> <span class=\"toc-text\">组件卸载 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"componentWillUnmount\" href = \"#\"><span class=\"toc-number\">1.3.1.</span> <span class=\"toc-text\">componentWillUnmount()</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"同时渲染的父子组件\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">同时渲染的父子组件 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"组件挂载 -v2\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\"> 组件挂载 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\" 父组件更新 \" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\"> 父组件更新 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"组件卸载 -v2\" href = \"#\"><span class=\"toc-number\">2.3.</span> <span class=\"toc-text\"> 组件卸载 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\" 不同时渲染的父子组件 \" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\"> 不同时渲染的父子组件 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\" 组件挂载 -v3\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 组件挂载 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"在父组件挂载的时候，请求数据\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\"> 在父组件挂载的时候，请求数据 </span></a></li></ol>","categories":[{"name":"验证","path":"api/categories/验证.json","url":"/categories/验证/"}],"tags":[{"name":"React，父子组件","path":"api/tags/React，父子组件.json","url":"/tags/React，父子组件/"}]}