[{"title":"正则匹配真好用","url":"/posts/5947/","content":"\n```\ncreate table open_command_map (\n  id number(20) not null,\n  batch_no nvarchar2(20) not null,\n  seq_no nvarchar2(32) not null,\n  status nvarchar2(2),\n  update_user_id nvarchar2(50),\n  update_time date,\n  delete_flag number(20) not null,\n  create_user_id nvarchar2(50),\n  create_time date not null\n);\n\ncomment on table open_command_map is '批次流水映射表';\n\ncomment on column open_command_map.id is '主键id(记录唯一键；系统自动生成)';\n\ncomment on column open_command_map.batch_no is '批次号';\n\ncomment on column open_command_map.seq_no is '流水号';\n\ncomment on column open_command_map.status is '状态';\n\ncomment on column open_command_map.update_user_id is '修改人';\n\ncomment on column open_command_map.update_time is '更新时间';\n\ncomment on column open_command_map.delete_flag is '是否删除（时间戳-是；0-否）';\n\ncomment on column open_command_map.create_user_id is '创建人';\n\ncomment on column open_command_map.create_time is '创建时间';\n\ncreate index command_map_batch_no_index on open_command_map (batch_no);\n\ncreate unique index command_map_seq_no_index on open_command_map (seq_no);\n\nalter table\n  open_command_map\nadd\n  primary key (id);\n\n```\n\n<!-- more -->\n\n\n","categories":[],"tags":[]},{"title":"初识乾坤","url":"/posts/59471/","content":"\n![](https://pic.imgdb.cn/item/637c6a4a16f2c2beb1ceecf4.png)\n\n<!-- more -->\n\n项目是用的iframe做的微前端，想尝试一下用乾坤搭建一个微前端的环境。\n\n## 创建项目\n\n本项目以vite创建的react工程为父应用，分别用vite和webpack创建的vue、react工程为子应用，目录结构如下图\n\n![](https://pic.imgdb.cn/item/637c6b9716f2c2beb1d0c605.png)\n\n### 配置项目\n\n配置各个工程的端口，防止端口占用\n\n```js\nmain: 8001\nreact-vite: 8002\nreact-webpack: 8003\nvue-vite: 8004\nvue-webpack: 8005\n```\n\n配置父应用\n\n\n\n```\n\n```\n\n","categories":["qiankun"],"tags":["微前端"]},{"title":"工程合并优化","url":"/posts/6963/","content":"\n\n\n<!-- more -->\n\n## 背景\n\n​        前端的公共组件保存在8个项目的本地，如果要改动公共组件代码，则需要同步到8个项目的公共组件，非常麻烦。前端需要进行换肤，需要统一页面样式。\n\n## 解决措施\n\n1.合并前端代码（×）\n\n​        核心问题就是8个项目都有自己的前端公共组件，如果8个工程的前端业务代码和前端公共组件代码合并，这样修改公共组件的代码就不需要同步到其他项目了，但是前后端代码是一起的，如果前端代码都放到一起，则后端代码也要放一起，不符合后端要求的微服务架构。（前端代码本来就不应该放一起，貌似是为了前后端代码在一起，方便打成jar包交付客户）\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\系统结构.png)\n\n2.前端代码合并，后端代码不合并（√）\n\n新建一个前端仓库，放前端合并的代码，按照前端业务代码分发到不同的业务工程中，这样就实现了前端能实现公共代码统一，也能满足后端微服务架构的要求。\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\代码分发.png)\n\n## 技术难点\n\n1.如何与用户交互，可以选择想要同步的业务工程\n\n2.在Windows上如果操作git命令\n\n3.如果自动生成提交信息\n\n## 具体实现\n\n使用node实现，主要使用的库为shelljs：用于实现shell命令的执行、chalk：颜色插件、inquirer：处理用户交互。具体流程如图。使用shelljs执行git命令。\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\分发流程.png)\n\n### 选择分发工程\n\n使用inquirer处理与用户的交互，用户可以选择分发到全部工程，也可以选择某个工程\n\n```js\ninquirer\n  .prompt(\n    [\n      {\n        type: 'list',\n        name: 'selectName',\n        message: colorMap.warn('请选择要分发的组件:'),\n        choices: ['all-project', ...Object.values(PROJECTS)],\n        pageSize: 10\n      }\n    ]\n  )\n```\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\选择分发项目.png)\n\n### 获取当前分支\n\n使用git命令获取当前分支\n\n```js\nconst branch = shell.exec('git branch --show-current', { silent: true }).trim();\n```\n\n### 重置代码仓库\n\n```js\nshell.exec(`git reset .`, { silent: true });  //git （--soft，--mixed（默认），--hard）,soft退回到暂存区，mixed回退到工作区，hard则不会保留代码,这里的作用是回退到工作区\nshell.exec(`git checkout .`, { silent: true }); // 撤销工作区文件\nshell.exec(`git clean -df`, { silent: true });  //清除不受git控制的文件和文件夹\n```\n\n### 切换本地分支\n\n先检查目标分支本地是否存在\n\n```js\nhasLocalBranch = shell\n    .exec('git branch -l', { silent: true })\n    .stdout.split('\\n')\n    .map(item => item.trim().replace('* ', ''))\n    .includes(branch);\n```\n\n如果不存在，则从远端检出\n\n```js\nshell.exec(`git fetch`, { silent: true });\nshell.exec(`git checkout --track origin/${branch}`, { silent: true })\n```\n\n本地存在则切换分支\n\n```js\nshell.exec(`git checkout ${branch}`, { silent: true })\n```\n\n### 拉取最新代码\n\n```js\nshell.exec(`git pull origin ${branch}`, { silent: true })\n```\n\n### 更新目标仓库\n\n同上，但是一般会检测目标仓库有没有本地没有提交的代码\n\n```js\nshell.exec(`git status`, { silent: true })\n```\n\n### 生成提交信息\n\n用git log获取提交信息\n\n```js\nlet result = assertShell(\n    shell.exec(\n        `git log -100 --name-only --format=\"#hash#%H{%cn}[%cd]#message#%s#messageContent#%b#files#\"${\n        grepStr ? ' --grep=\"' + grepStr + '\"' : ''\n        } ${targetFileName ? ' -- ' + targetFileName : ''}`,\n        {\n            silent: true\n        }\n    )\n);\n```\n\n利用正则处理提交信息\n\n```js\n// git log 结果转为对象数组\nlet commitList = result.map((item = '') => {\n    const commit =\n          /(^[0-9a-f]+)\\{(.+)\\}\\[(.+)\\]#message#(.+)#messageContent#([\\s\\S]*)#files#([\\s\\S]*$)/m.exec(\n              item\n          );\n    return {\n        hash: commit[1] || '',\n        author: commit[2] || '',\n        time: commit[3] || '',\n        message: commit[4] || '',\n        messageContent: commit[5] || '',\n        files: commit[6].trim().split('\\n')\n    };\n});\n```\n\n获取门户工程提交最新hash，获取门户工程提交历史， 获取业务工程分发记录，判断业务工程分发记录是否记录分发源hash。根据分发源hash在门户工程查找提交记录，如果没有找到则分发失败，找到了则从记录源头之后的提交信息。(在分发之前要确保分发源是否存在，不在则在业务工程手动创建)\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\查找提交记录.png)\n\n```js\n// 处理生成提交信息\nconst portalLatestCommitHash = GitLog(SOURCE)[0].hash; // 门户工程最新hash\nlet commitMessage = '';\nif (GenerateMessage) {\n    let portalCommitList = GitLog(SOURCE); // 获取门户工程提交历史\n    const projectCommitList = GitLog(TARGET, 'delivered from'); // 获取业务工程分发记录\n    assertShell(\n        { code: projectCommitList.length < 1, stderr: '未找到有记录分发源hash的提交' },\n        '',\n        '生成提交信息失败'\n    );\n    const latestDeliverFromHash = (\n        projectCommitList[0].messageContent || projectCommitList[0].message\n    ).match(/(?<=delivered from )[0-9a-f]+/)[0]; // 上次分发源\n    const idx = portalCommitList.findIndex(item => item.hash === latestDeliverFromHash);\n    if (idx === 0) {\n        logColor(\n            `合并工程没有需要分发的更新!\n          工程：${projectName}上次分发源：${latestDeliverFromHash}, 合并工程最新提交：${portalLatestCommitHash}`,\n            'warn'\n        );\n        logColor(`分发结束: ${projectName}`, 'success', ' ');\n        return;\n    } else if (idx === -1) {\n        logColor(\n            `合并工程提交历史中, 无法定位到该分发源, 跳过!\n          工程：${projectName}上次分发源：${latestDeliverFromHash}`,\n            'warn'\n        );\n        logColor(`分发结束: ${projectName}`, 'success');\n        return;\n    }\n```\n\n根据修改代码文件地址确定要提交的记录,即修改了cash工程的代码，但是分发的工程选的是settle,则cash修改的记录会被过滤掉(每个业务工程除了业务代码不同，其他的都相同)\n\n```js\nportalCommitList = portalCommitList.filter(item => {\n    const filesStr = item.files.join(';');\n    if (/Merge branch/.test(item.message)) {\n        return false; // 自动merge的产生的信息\n    } else if (/frontend\\/(?!src)/.test(filesStr)) {\n        return true; // 改了包含非src代码\n    } else if (/frontend\\/src\\/(?!page)/.test(filesStr)) {\n        return true; // 改了包含非页面代码\n    } else if (/frontend\\/src\\/page\\/(?!bmtp|dfas)/.test(filesStr)) {\n        return true; // 改了包含非业务页面代码\n    } else if (filesStr.includes(`src/page/${projectName}`)) {\n        return true; // 改了该工程页面代码\n    } else {\n        return false;\n    }\n});\n```\n\n### 分发目标代码\n\n删除没有选中的业务目录代码，再将业务工程删除，再复制门户工程到业务工程\n\n```js\n// 定位到中转仓page并删除非目标代码\nassertShell(shell.cd(path.join(SOURCE, './src/page')), '', '找不到page页面代码');\nassertShell(\n    shell.rm(\n        '-Rf',\n        Object.values(PROJECTS).filter(item => item !== projectName)\n    ),\n    '',\n    '页面代码删除出现错误'\n);\n\n// 定位到业务工程并清除frontend\nassertShell(shell.cd(path.join(TARGET, './frontend')), '', '找不到frontend代码');\nconst deleteFileList = shell\n.ls('-A')\n.filter(item => !['.vscode', 'node_modules'].includes(item));\nassertShell(shell.rm('-Rf', deleteFileList), '', '清空业务工程代码失败');\n\n// 代码复制\nassertShell(shell.cp('-Rf', SOURCE, TARGET), '复制更新代码成功', '复制更新代码时出现错误');\n```\n\n### 创建本地提交\n\n通过git commit判断是否有提交的文件\n\n```js\nassertShell(shell.cd(projectPath), '', '推送分支: 找不到page页面代码');\nlogColor(`提交信息:\\n${commitMsg}`, 'info');\nassertShell({ code: !commitMsg.length }, '', '提交信息不可为空');\nassertShell(shell.exec(`git add .`, { silent: true }));\nlet P = shell.ShellString(commitMsg || ' ').exec(`git commit --file -`, { silent: true });\nif (P.code && P.stdout.indexOf('up to date') > -1) {\n    logColor(`没有变更的文件需要提交: ${projectPath}`, 'warn');\n    return;\n} else {\n    assertShell(P, '', '提交失败');\n}\n```\n\n### 手动提交\n\n![](E:\\Code\\BlogCode\\Blog\\source\\gallery\\代码提交.png)\n","categories":[],"tags":[]},{"title":"'一次 vue 项目的性能优化'","url":"/posts/27490/","content":"\n\n\n<!-- more -->\n\n\n","categories":[],"tags":[]},{"title":"ts 学习笔记 1","url":"/posts/61000/","content":"\n\n\n<!-- more -->\n\n整理一下最近学的ts知识\n\n## 对比原理\n\n- 他是JavaScript的一个超集，在原有的基础上，添加了可选静态类型和基于类的面向对象编程方式\n\n## TS的使用场景 \n\n-  面向项目\n\nTS - 面向解决大型复杂项目，复杂架构以及代码维护场景\n\nJS - 脚本化语言，用于面向简单页面场景\n\n- 自主检测\nTS - 编译期间，主动发现并指出错误\nJS - 无编译阶段\n\n- 类型检测\nTS - 强类型\nJS - 弱类型\n\n- 运行流程\nTS - 依赖编译，依靠编译打包后，编译成JS\nJS - 可以直接运行与浏览器中\n\n- 复杂特性\nTS - 模块化、泛型、接口\n\n考点：ts相较于js优势 功能 => 以上4个点，ts如何实现这个功能 => 多了编译时 => ts官方编译器  / babel\n\n## TS的基础类型与写法\n\n### 布尔值(boolean)\n\n```tsx\nlet idDone: boolean = false\n```\n\n### 枚举(enmu)\n\nenum类型是对JavaScript的标准类型的一个补充\n\n- 数字类型枚举，默认情况下，从0开始为元素编号，依次递增，也可以手动指定成员的数值\n\n```tsx\nenum Score {\n    BAD,\n    NG,\n    GOOD = 4,\n    PERFET\n}\n```\n\n- 字符串类型枚举,有值取值\n\n```tsx\nenum Score {\n    BAD = \"BAD\",\n    NG = \"NG\",\n    GOOD = \"GOOD\",\n    PERFET = \"PERFET\"\n}\n```\n\n- 反向映射 - 正反向双重mapping\n\n```tsx\nenum Score {\n    BAD,\n    NG,\n    GOOD,\n    PERFET\n}\n```\n\n- 异构类型\n\n```tsx\nenum ENUM {\n    A,\n    B,\n    C = \"C\",\n    D = \"D\",\n    E = \"6\",\n    F\n}\n```\n\n\n\n### 数字(number)\n\n和JavaScript一样，TypeScirpt里所有的数字都是浮点数，`0b1010`和`0o744`在ES6中会被编译成十进制数字\n\n```js\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0o744\n```\n\n#### 元组\n\n\n\n\n\n### 字符串(string)\n\n使用`string`定义字符串类型：\n\n```js\nlet myName: string = 'Tom'\nlet sentence: string = `Hello, my name is ${myName}`\n```\n\n### 空值(void)\n\nJavaScript没有空值（Void）的概念，在TypeScript中，可以用`void`表示没有任何返回值的函数\n\n```js\nfunction alterName(): void {\n    alter('My name is Tom');\n}\n```\n\n### Null和Undefined\n\n与`void `的区别是，`undefined`和`null`是所有类型的子类型。也就是说`undefined`类型的变量，可以赋值给`number`\n\n类型的变量，而`void`类型的变量不能赋值给`number`类型的变量\n\n```js\nlet u:undefined;\nlet num: number = u;\nlet u:void;\nlet num:number = u \n// Type 'void' is not assignable to type 'number'.\n```\n\n### any和unknown、never\n\n1.`any`绕过所有类型检查 => 类型检测和编译筛查功能全部取消。2.`unknown` 绕过赋值检查 => 禁止更改传递\n\n#### Object / ObjectConstructor / {}\n\n`Object` -> Object.prototype 上的属性，`ObjectConstructor`->定义了Object本身的属性, `{}`-定义空属性\n\n## 接口(interface)\n\n他是对行为的一种抽象，具体行动由类去实现\n\n```tsx\ninterface Person {\n    readonly id: number;  //只读\n    name: string,\n    age?: number， // 可选\n    [propName: string]: any //任意\n}\nlet tom:Person = {\n    name: 'Tom',\n    age: 25\n}\n```\n\n### 交叉类型\n\n```tsx\ninterface A {\n  x: D;\n}\ninterface B {\n  x: E;\n}\ninterface C {\n  x: F;\n}\ninterface D {\n  d: boolean;\n}\ninterface E {\n  e: string;\n}\ninterface F {\n  f: number;\n}\ntype ABC = A & B & C;\nlet abc: ABC = {\n  x: {\n    d: false,\n    e: \"class\",\n    f: 5,\n  },\n};\n```\n\n合并冲突\n\n```\n\n```\n\n","categories":["typescript"],"tags":["学习笔记"]},{"title":"1 前端面试准备的副本","url":"/posts/6872/","content":"\n## 一、面试准备\n\n### 1. 利用脑图来梳理知识点\n\n对于统一校招类的面试，要重点梳理前端的所有知识点，校招面试一般是为了做人才储备，所以看的是候选人的可塑性和学习能力；对于社招类面试，则看重的是业务能力和 JD 匹配程度，所以要针对性地整理前端知识点，针对性的内容包括：项目用到的技术细节、个人技能部分需要加强或提升的常考知识点。\n\n\n\n所以，不仅仅简历要针对性地来写，知识点也要根据自己的经历、准备的简历、公司和职位描述来针对性地梳理。\n\n\n\n基础知识来自于自己平时的储备，一般对着一本系统的书籍或者自己平时的笔记过一遍即可，但是提到自己做到的项目是没有固定的复习套路的，而且围绕项目可以衍生出来各种问题，都需要了解，项目讲清楚对于候选人也特别重要。基础是固定的，任何人经过一段时间都可以学完的，但是项目经历是实打实的经验。\n\n\n\n对于项目的复习和准备，建议**列思维导图（脑图）**，针对自己重点需要讲的项目，列出用到的技术点（知识点），介绍背景、项目上线后的收益以及后续优化点。这是第一层，第二层就是针对技术点（知识点）做各种发散的问题。\n\n\n\n注：JD（job description），是指职位描述，是其缩写。一般在招聘中，最常用到的意思就是岗位介绍和工作职责描述的意思。\n\n### 2. 程序员应该具备哪些软技能？\n\n程序员除了业务技能外，应该具有下面的软技能：\n\n- 韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题\n- 责任心：对于自己做过的项目，能够出现 bug 之类主动解决\n- 持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要\n- 团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗\n- 交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享\n\n### 3. 准备合适的技术型简历\n\n**（1）技术型简历的重要组成部分**\n\n一份合适的技术型简历最重要的三部分是：\n\n- 个人掌握的技能，是否有岗位需要用到的技能，及其技能掌握的熟练程度：熟悉、了解还是精通\n- 项目经历，项目经历是否对现在岗位有用或者有重叠，是否能够驾驭大型项目\n- 实习经历，对于没有经验的应届生来说，实习经历是很重要的部分，是否有大公司或者具体项目的实习经历是筛选简历的重要参考\n\n\n\n技术型简历一般不要太花俏，关键要语言表达通顺清楚，让语言准确和容易理解，在 HR 筛选简历的时候，可以瞬间抓住他的眼球。另外如果有一些特殊奖项，也可以在简历中突出出来，比如：季度之星、最佳个人之类的奖项，应届生会有优秀毕业生、全额奖学金等。\n\n\n\n**（2）推荐使用 PDF 版本的简历**\n\n一般来说简历会有 Word、Markdown、PDF 等版本，这里推荐使用 PDF 版本的简历，主要原因如下：\n\n- 内容丰富，布局调整方便\n- 字体等格式有保障，你不知道收到你简历的人用的是什么环境，PDF 版本不会因为不同操作系统等原因而受限\n- 便于携带和传播，始终存一份简历在手机或者邮箱内，随时发送\n- 不容易被涂改\n\n\n\n一般 Windows 系统的 Word、Mac 系统的 Pages 都支持导出 PDF 格式的文件，原稿可以保存到云端或者 iCloud，方便以后修改。\n\n\n\n虽然我们是 Web 前端工程师，但是不推荐使用 HTML 格式的简历，HTML 版本的简历容易受浏览器等环境因素影响，而且接收方不一定是技术人员，炫酷的效果对方不一定能被看到。\n\n\n\n**（3）简历最好要有针对性地来写**\n\n简历是「**敲门砖**」，建议根据想要找的公司、岗位和职位描述来有针对性地写简历。尤其是个人技能和项目（实习）经验部分，要根据岗位要求来写，这样才能增加受邀面试的机会。\n\n> 举个例子：好友给你推荐了百度地图部门的一个 Web 前端工程师工作，并且把职位描述（JD）发给你了，里面有要求哪些技能，用到哪些技术，还有加分项。那么你写简历就应该思考自己有没有这些技能。如果没有 JD，那么至少你应该知道：地图部门肯定做一些跟地图相关的工作，如果恰巧你之前研究过地图定位，了解 HTML5 Geolocation 定位接口，那么你可以在简历里提一下。\n\n很多时候我们并不知道简历会被谁看到，也不知道简历会被朋友/猎头投递到什么公司或者职位，那么这样的简历应该是一种「通用简历」。所谓通用简历，应该是与我们找的职位和期望的级别相匹配的简历，比如想找大概 T4 水平的 Web 前端工作，那么就应该在简历体现出来自己的技能能够达到 T4 的水平。不要拿着一两年前的简历去找工作，前端这两年发展速度很快，只靠一两年前简历上面「精通、熟悉」的库和框架，可能已经找不到工作了。\n\n\n\n所以，写简历也是个技术活，而且是一个辛苦活！不要用千篇一律的模板！\n\n\n\n**（4）简历是面试时「点菜」用的菜单**\n\n简历除了是「敲门砖」之外，还是供面试官提问用的「菜单」。面试官会从简历上面写的技能、项目进行提问。所以简历是候选人「反客为主」的重要工具，这也是我们一直提到的：**不要造假或者描述太出格**，而应该实事求是地写简历。简历中的技能和项目都要做好知识点梳理，尽量多地梳理出面试官可能问到的问题，并且想出怎么回答应对，**千万不要在简历上自己给自己挖坑**。\n\n\n\n另外简历中不要出现错误的单词拼写，注意单词的大小写，比如`jQuery`之类。并且，作为一个前端工程师，简历的布局一定要合理，美观。\n\n### 4. 收到面试邀请之后的准备\n\n当有公司邀请我们去面试的时候，应该针对性地做一些功课。\n\n**（1）了解部门和团队**\n\n了解部门做的事情，团队用的技术栈，前文提到这部分信息一般从 JD 当中就可以看到，如果 JD 并没有这些信息，那么可以根据面试的部门搜索下，总会找到一些零星的信息，如果实在没有任何信息，就准备岗位需要的通用技术。\n\n**（2）了解面试官**\n\n通过邀请电话或者面试邀请邮件，可以找到面试官信息。通过这些信息查找面试官技术博客、GitHub 等，了解面试官最近关注的技术和擅长的技术，因为面试官往往会在面试的过程中问自己擅长的技术。\n\n## 二、面试过程：\n\n### 1. 面试过程中要注意社交礼仪\n\n- **注意社交礼仪：**虽然说 IT 行业不怎么注重工作环境，上下级也没有繁文缛节，但是在面试中还是应该注意一些社交礼仪的。像进门敲门、出门关门、站着迎人这类基本礼仪还是要做的。\n- **舒适但不随意的着装：**首先着装方面，不要太随意，也不要太正式，太正式的衣服可能会使人紧张，所以建议穿自己平时喜欢的衣服，关键是干净整洁。\n- **约个双方都舒服的面试时间：**如果 HR 打电话预约面试时间，记得一定要约个双方都舒服的时间，宁愿请假也要安排好面试时间。面试时间很重要，**提前十分钟到面试地点**，熟悉下环境，做个登记之类的，留下个守时的好印象。如果因为堵车之类的原因不能按时到达，则要在约定时间之前电话通知对方。\n\n### 2 面试中出现的常规问题\n\n对于面试中出现的常规问题要做好准备，比如：介绍下自己，为什么跳槽，面试最后一般会问有什么要问的。\n\n**（1）介绍自己**\n\n介绍自己时，切忌从自己大学实习一直到最新公司全部毫无侧重地介绍，这些在简历当中都有，最好的方式是在介绍中铺垫自己的技术特长、做的项目，引导面试官问自己准备好的问题。\n\n**（2） 为什么跳槽**\n\n这个问题一定要慎重和认真思考，诚实回答。一般这个问题是想评估你入职能够待多长时间，是否能够融入团队。每个人跳槽前肯定想了很多原因，最终才走出这一步，不管现在工作怎样，**切忌抱怨，不要吐槽，更不要说和现在领导不和睦之类的话**。 多从自身发展找原因，可以表达寻找自己心目中的好的技术团队氛围和平台机会，比如：个人遇见了天花板，希望找个更好的发展机会。\n\n### 3. 如何介绍自己的项目经历\n\n**（1）介绍项目背景**\n\n这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。\n\n> 比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。\n\n**（2） 承担角色**\n\n项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？\n\n\n\n这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。\n\n**（3）最终的结果和收益**\n\n项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。\n\n**（4）有始有终：项目总结和反思**\n\n有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：\n\n- 收获有哪些？\n- 是否有做得不足的地方，怎么改进？\n- 是否具有可迁移性？\n\n\n\n比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。\n\n\n\n介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。\n\n\n\n按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。\n\n### 4. 项目细节和技术点的追问\n\n介绍项目的过程中，面试官可能会追问技术细节，所以在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：\n\n- 技术选型方案：当时做技术选型所面临的状况\n- 技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？\n- 项目数据和收益\n- 项目中最难的地方\n- 遇见的坑：如使用某种框架遇见哪些坑\n\n\n\n一般来说，做技术选型的时候需要考虑下面几个因素：\n\n- 时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？\n- 团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？\n- 业务需求：需求是怎样的，能否套用现在的成熟解决方案/库来快速解决？\n- 维护成本：一个解决方案的是否再能够 cover 住的范围之内？\n\n\n\n在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备\n\n下。\n\n### 5. 没有做过大型项目怎么办\n\n对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章/书，提到的某个项目，抒发下自己的想法。\n\n\n\n如果是对于面试官提出来需要你设计的项目/系统，可以按照下面几步思考：\n\n1. 有没有遇见过类似的项目\n2. 有没有读过类似解决方案的文章\n3. 项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用\n4. 项目解决的问题是什么，这类问题有没有更好的解决方案\n\n\n\n总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。\n\n### 6. 当被分配一个几乎不可能完成的任务时，会怎么做\n\n这种情况下，一般通过下面方式来解决：\n\n1. 自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间\n2. 能不能借助周围同事来解决问题\n3. 拿着分析结果跟上级反馈，寻求帮助或者资源\n\n突出的软技能：分析和解决问题，沟通寻求帮助。\n\n### 7. 提问环节\n\n面试是一个双向选择的事情，所以面试后一般会有提问环节。在提问环节，候选人最好不要什么都不问，更不要只问薪水待遇、是否加班之类的问题。\n\n\n\n其实这个时候可以反问面试官了解团队情况、团队做的业务、本职位具体做的工作、工作的规划，甚至一些数据（可能有些问题不会直面回答）。\n\n\n\n还可以问一些关于公司培训机会和晋升机会之类的问题。如果是一些高端职位，则可以问一下：自己的 leader 想把这个职位安排给什么样的人，希望多久的时间内可以达到怎样的水平。\n\n## 三、HR面试：\n\n### 1. 谈薪资——准确定位和自我估值\n\n在准备跳槽时，每个人肯定会对自己有一个预估，做好足够的心理准备。下面谈下怎么对自己的薪酬做个评估。一般来说跳槽的薪水是根据现在薪酬的基础上浮 15~30%，具体看个人面试的情况。对于应届毕业生，大公司基本都有标准薪水，同期的应届生差别不会特别大。\n\n\n\n除了上面的方法，还应该按照公司的技术职级进行估值。每个公司都有对应的技术职级，不同的技术职级薪酬范围是固定的，如果是小公司，则可以参考大公司的职级范围来确定薪资范围。根据职级薪资范围和自己现在薪酬基础上浮后的薪酬，做个比较，取其较高的结果。\n\n\n\n除此之外，我们可以在**微信小程序****offershow****、牛客网**等平台看看网友分享的各个公司的薪酬体系。\n\n\n\n当然如果面试结果很好，可以适当地提高下薪酬预期。除了这种情况，应该针对不同的性质来对 offer先做好不同的估值。这里的预期估值只是心理预期，也就是自己的「底牌」。\n\n所谓不同性质的 offer 指的是：\n\n- 是否是自己真心喜欢的工作岗位： 如果是自己真心喜欢的工作岗位，比如对于个人成长有利，或者希望进入某个公司部门，从事某个专业方向的工作，而你自己对于薪酬又不是特别在意，这时候可以适当调低薪酬预期，以拿到这个工作机会为主。\n- 是否只是做 backup 的岗位：面试可能不止面试一家，对于不是特别喜欢的公司部门，那么可以把这个 offer 做为 backup，后面遇见喜欢的公司可以以此基础来谈薪水。\n\n\n\n这时候分两种情况：如果面试结果不是很好，这种情况应该优先拿到 offer，所以可以适当降低期望薪酬；如果面试结果很好，这种情况应该多要一些薪酬，增加的薪酬可以让你加入这家公司也心里很舒服。\n\n对于自己真正的目标职位，面试之前应该先找 backup 岗位练练手，一是为了找出面试的感觉，二是为了拿到几个 offer 做好 backup。\n\n### 2. 跟 HR 沟通的技巧\n\n跟 HR 沟通的时候，不要夸大现在的薪酬，HR 知道的信息往往会超出你的认知，尤其大公司还会有背景调查，所以不要撒谎，实事求是。跟 HR 沟通的技巧有以下几点：\n\n- **不要急于出价**\n\n不要急于亮出自己的底牌，一旦你说出一个薪酬范围，自己就不能增加薪酬了，还给了对方砍价的空间。而且一个不合理的价格反而会让对方直接放弃。所以不要着急出价，先让对方出价。\n\n同时，对于公司级别也是，不要一开始就奔着某个目标去面试，这样会加大面试的难度，比如：\n\n> 目标是拿到阿里 P7 的职位，不要说不给 P7 我就不去面试之类的，这样的要求会让对方一开始就拿 P7 的标准来面试，可能会找 P8+ 的面试官来面试你，这样会大大提升面试难度。\n\n- **要有底气足够自信**\n\n要有底气，自信，自己按照上面的估值盘算好了想要的薪酬，那么应该有底气地说出来，并且给出具体的原因，比如：\n\n> 1. 我已经对贵公司的薪酬范围和级别有了大概的了解，我现在的水平大概范围是多少\n> 2. 现在公司很快就有调薪机会，自己已经很久没有调薪，年前跳槽会损失年终奖等情况\n> 3. 现在我已经有某个公司多少 K 的 offer\n\n如果 HR 表示你想要的薪酬不能满足，这时候你应该给出自己评估的依据，是根据行业职级标准还是自己现有薪酬范围，这样做到有理有据。\n\n- **谈好 offer 就要尽快落实**\n\n对于已经谈拢的薪酬待遇，一定要 HR 以发邮件 offer 的形式来确认。\n\n## 四、其他\n\n### 1. 总结和思考\n\n- 面试完了多总结自己哪里做得不好，哪里做得好，都记录下来，后续扬长避短\n- 通过面试肯定亲身体会到了公司团队文化、面试官体现出来的技术能力、专业性以及职位将来所做的事情，跟自己预期是否有差距，多个 offer 的话多做对比\n\n\n\n每次面试应该都有所收获，毕竟花费了时间和精力。即使面不上也可以知道自己哪方面做得不好，继续加强。\n\n### 2. 面试注意点\n\n在面试过程中，我们经常会被问及各种问题，在回答的过程中，这里简单列举了一些“坑”。\n\n- “对不起，我真的很紧张”，即使紧张也不要说出来；\n- “我想知道这个职位的具体收入有多少”一开始就谈钱，你的理想、价值观、使命、目标呢？\n- “我的缺点是斤斤计较，不能加班，承受不了工作压力太大”不要主动告诉别人你的缺点，你来是展示你的优势的；\n- “我真的很想要这份工作”不要太过于表现你的欲望或绝望，这是你软弱的表现；\n- “我现在（之前）的老板太不好了……”向 HR 说你老板的话会变成对方对你的看法；\n- “我需要……能实现工作目标”招聘是为了满足公司需求，不是为你搭建舞台；\n- “请问面试什么时候结束”不要表现赶时间，你不尊重公司，自然不会录用你；\n- “我喜欢贵公司的福利待遇”你是来工作的，不是因为福利待遇才来的；“无可奉告”不违法不涉及隐私，如实告知，有准备的话不会“无可奉告”；\n- “工作第一年的福利待遇及带薪年假和病假等情况是什么样的”这是入职时才可以问的规定，先问只会被误会；\n- “我在离婚或者怀孕期间经历了非常艰难的时期”不要主动告诉对方隐私情况，你个人的事情处理不好会容易联想到工作表现；\n- “我没有什么问题要问”最后被问到时这样回答等同于“再也不见”。","categories":[],"tags":[]},{"title":"常见的功能函数","url":"/posts/19005/","content":"\n![](/gallery/js-2022-2-16.jpeg)\n\n<!-- more -->\n\n# 对象扁平化\n\n主要是通过递归，使嵌套的数据扁平\n\n```js\n// 创建判断对象的函数\nfunction isObject(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1) === 'Object'\n}\nfunction flatObject (obj, pre = '', res = {}) {\n    if (!obj) return;\n    Reflect.ownKeys(obj).forEach((key) => {\n        let perKey = pre + key;\n        if (isObject(obj[key])) {\n            flatObject(obj[key], perKey + '.', res);\n        } else {\n            res[perKey] = obj[key];\n        }\n    })  \n    return res;\n}\n```\n\n# 数组偏平化\n\nlet arr = [[1, 2, 3],[1,3,[4]],3];\n\n**1.Array.flat**\n\nflat 默认只会拉平一层,Infinity,全拉平\n\n```js\narr.flat(Infinity) // [ 1, 2, 3, 1, 3, 4, 3 ]\n```\n\n**2.reduce**\n\n```js\nvar flat_reduce = (arr) => {\n  return arr.reduce((pre, cur) => {\n    return Array.isArray(cur) ? pre.concat(flat_reduce(cur)) : pre.concat(cur)\n  }, [])\n}\nflat_reduce(arr1)\n```\n\n**3.forEach()**\n\n```js\nvar flat_forEach = (arr) => {\n  var ans = [];\n  arr.forEach(item => {\n    Array.isArray(item) ? ans = ans.concat(flat_forEach(item)) : ans.push(item);\n  })\n  return ans;\n}\n```\n\n**4.toString()**\n\n```js\nvar flat_toString = (arr) => {\n  return arr.toString().split(',').map(item => Number(item))\n}\nflat_toString(arr)\n```\n\n**5.join(),split()**\n\n和toString的方法相同\n\n```js\nlet flat_join = (arr) => {\n  return arr.join(',').split(',').map(item => Number(item))\n}\nflat_join(arr)\n```\n\n**6.拓展运算符**\n\n```js\nvar flat_ = (arr) => {\n  // 判断数组中是否包含对象 some\n  while (arr.some(item => Array.isArray(item))) {\n    arr = [].concat(...arr)\n  }\n  return arr;\n}\nflat_(arr)\n```\n\n# 扁平化数据结构转Tree\n\n```js\nlet arr = [\n  { id: 1, name: \"部门1\", pid: 0 },\n  { id: 2, name: \"部门2\", pid: 1 },\n  { id: 3, name: \"部门3\", pid: 1 },\n  { id: 4, name: \"部门4\", pid: 3 },\n  { id: 5, name: \"部门5\", pid: 4 },\n];\n```\n\n**1.递归**\n\n```\nfunction arrayToTree(arr, pid) {\n  let result = [];\n  getChildren(arr, result, pid);\n  return result;\n}\n\nconst getChildren = (data, result, pid) => {\n  data.forEach( item => {\n    if (item.pid === pid) {\n      let newItem = {...item, children:[]};\n      result.push(newItem);\n      // 递归\n      getChildren(data, newItem.children, item.pid)\n    }\n  })\n};\n```\n\n**2.迭代**\n\n```js\nfunction arrayToTree(arr, pid) {\n  // 先把数据变成map格式\n  let map = new Map();\n  arr.forEach((item) => {\n    let newNode = { ...item, children: [] };\n    map.set(item.id, newNode\n  });\n  let res = [];\n  arr.forEach((item) => {\n    let id = item.id;\n    let itemPid = item.pid;\n    let treeItem = map.get(id);\n    // 找到根节点\n    if (itemPid === pid) {\n      res.push(treeItem);\n    } else {\n      map.get(itemPid).children.push(treeItem);\n    }\n  });\n  return res;\n}\n```\n\n\n\n# 数组去重\n\nlet arr = [1, 2, 3, 3, 2, 4, 2, 7, 5, 9];\n\n**1.Set**\n\n```js\nlet deDuplication_set = (arr) => {\n  return Array.from(new Set(arr));\n};\n```\n\n**2.利用对象**\n\n```js\nlet deDuplication_object = (arr) => {\n  let obj = {};\n  let res = [];\n  arr.forEach((item) => {\n    if (!obj[item]) {\n      res.push(item);\n      obj[item] = 1;\n    }\n  });\n  return res;\n};\n```\n\n**3.利用map**\n\n如果map中不存在，就放在map中，最后取map的keys\n\n```js\nlet deDuplication_map = (arr) => {\n  let map = new Map();\n  arr.forEach((item) => {\n    if (!map.has(item)) {\n      map.set(item, true);\n    }\n  });\n  return Array.from(map.keys());\n};\n```\n\n**4.filter indexOf**\n\n```js\nlet deDuplication_filter = (arr) => {\n  return arr.filter((item, index, arr) => {\n    return arr.indexOf(item) == index;\n  });\n};\n```\n\n**5.新建数组 + sort**\n\n```js\nlet deDuplication_sort = (arr) => {\n  arr.sort((a, b) => a - b);\n  let res = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] !== arr[i - 1]) {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n};\n```\n\n**6.reduce + includes**\n\n```js\nlet deDuplication_reduce = (arr) => {\n  return arr.reduce((pre, cur) => {\n    return pre.includes(cur) === -1 ? [...pre, cur] : pre;\n  }, []);\n};\n```\n\n# 防抖\n\n场景：输入框输入搜索的时候\n\n效果：输入的时间间隔大于规定的时间间隔，执行相关的功能函数\n\n```js\n// 第一次不执行\nfunction debounce(fn, ms) {\n    let timer = null;\n    return function(..args) {\n        if (timer) {\n            clearTimeout(timer);\n        }  //如果在一段时间频繁触发，之前的定时器就会被清空\n        timer = setTimeout(() => {\n            fn.apply(this, args)\n        }, time)\n    }\n}\n// 第一次执行\nfunction debounce(fn, ms) {\n    let timer = null;\n    let flag = true;\n    return funciton(...args) {\n        if (timer) {\n            clearTimeout(timer);\n        }\n        if (flag && !timer) {\n            fn.apply(this, args);\n        }\n        timer = setTimeout(()=> {\n            fn.apply(this, args);\n        }, ms);\n        \n    }\n}\n```\n\n# 节流\n\n场景：下拉框滑动时\n\n效果：一段时间函数只执行一次，高频事件会稀释函数\n\n```js\n// 基于闭包\nfunction throttle(fn, ms) {\n    let timer = null;\n    return function (..args) {\n        if (!timer) {\n            timer = setTimeout(()=> {\n                fn.apply(this, args);\n                timer = null;\n            }, ms);\n            \n        }\n    }\n}\n// 基于时间戳\nfunction throllte(fn, ms) {\n    let pre = null;\n    return function(...args) {\n        let now = Date.now();\n        if (now - pre > ms) {\n            fn.apply(this, args);\n            pre = now;\n        }\n    }\n}\n```\n\n# call、apply、bind\n\nthis的绑定规则， 分为以下四种：\n\n1.默认绑定\n\n​     默认情况下，this指向全局对象，不过在严格模式下，this无法指向全局对象，this会绑定到undefined\n\n2.隐式绑定\n\n​    当函数作为方法被调用，需考虑运行时上下文环境\n\n3.显示绑定\n\n​     call、apply、bind\n\n4.new 绑定\n\n​     如果使用new构造函数，在函数的内部，this会指向新构造的函数\n\n**call**\n\n核心：就是把函数挂载到obj上，执行obj.f()的时候，f中的this就指向obj，执行完后删除挂载在obj上的函数f\n\n```js\nFunction.prototype.myCall = function(thisArg, ...args) {\n    // 判断挂载的是不是函数\n    if (typeof this != \"function\") {\n        throw new Error(\"The caller must be a fucntion\");\n    }\n    // 没有传入对象,就挂载在全局对象上\n    if (thisArg === undefined || thisArg === null) {\n        thisArg = globalThis;\n    } else {\n        // 将参数转成对象\n        thisArg = Object(thisArg);\n        \n    }\n    // 把函数挂载到对象上， this指向被调用的函数\n    thisArg.fn = this;\n    // 执行该函数\n    let res = thisArg.fn(...args);\n    // 删除挂载的函数\n    delete thisArg.fn;\n    //返回结果\n    return res;\n}\n```\n\n**apply**\n\n核心：同call，但是apply传的参数是数组\n\n```js\nFunction.prototype.myApply = function (thisArg, args = []) {\n    // 判断挂载的是不是函数\n    if (typeof this != \"function\") {\n        throw new Error(\"apply must be a fucntion\");\n    }\n    if (thisArg === undefined || thisArg === null) {\n        thisArg = globalThis;\n    } else {\n        thisArg = Object(thisArg);\n    }\n    // 判断参数是不是数组\n    if(!Array.isArray(args)) {\n        throw new Error(\"second argument to Fucntion.prototype.apply argument must be an array\")\n    }\n    thisArg.fn = this;\n    let res = thisArg.fn(...args);\n    delete thisArg.fn;\n    return res;\n}\n```\n\n**bind**\n\n核心：但是bind返回的是一个函数，且this的指向已经改变，之后不会发生变化。\n\n```js\nFunction.prototype.myBind = function (thisArg, ...args1) {\n    if (typeof this != \"function\") {\n        throw new Error(\"the caller must be a funciton\");\n    }\n    const fnBind = this;\n    return function fnBound(...args2) {\n        // 如果是通过new调用的\n        if (this instanceof fnBound) {\n            return new fnBound(...args1, ...args2)\n        } else {\n            return fnBind.apply(this, [...args1, ...args2]);\n        }\n    }\n}\n```\n\n","categories":["功能函数"],"tags":["js"]},{"title":"Reflect 对象解析","url":"/posts/60673/","content":"\n![](/gallery/js-2022-2-16.jpeg)\n\n<!-- more -->\n\n# Reflect\n\nReflect是一个内置对象，其原型是Object.prototype。它不是一个函数，不能执行函数的调用和构造函数调用。\n\nReflect对象的设计目的主要有：\n\n1、将Object对象的一些明显属于语言层面的方法放到了Reflect对象上。\n\n2、修改某些Object方法的返回结果，使其根据合理。\n\n3、让对象操作都变成函数行为。\n\n4、Reflect对象的方法和Proxy对象的方法一一对应，只要是Proxy对象的方法，都能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便的调用对应的Reflect方法完成默认行为。\n\n# 静态方法\n\n## 1、Reflect.apply(target, thisArgument, argumentsList)\n\n等同于Function.prototype.apply.call( target, thisArgument, argumentsList )。一般来说，如果要绑定一个函数的this对象，可以写成fn.apply(obj, args)。但如果函数自己定义了apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)。而采用Reflect对象可以简化这种操作。\n\n```js\nvar obj = {a:1}\nfunction test(b) {\n  return this.a + b;\n}\nReflect.apply(test, obj, [2])\n// 3\n```\n\n没有**Reflect.call**()\n\n## 2、Reflect.construct(target, argumentList)\n\n这里提供了一种不使用new来调用构造函数的方法。\n\n```js\nnew Array(1,2,3); // [1,2,3] \n// 等价于\nReflect.construct(Array, [1,2,3]); // [1,2,3]\n```\n\n## 3、Reflect.defineProperty ( target, propertyKey, attributes )\n\n用于定义或修改对象属性，返回一个布尔值表示是否操作成功。其对应的Object方法如果操作失败的话，会抛出异常。\n\n```js\nvar obj = { a: 1 };\nObject.getOwnPropertyDescriptor(obj, 'a'); \n// {value: 1, writable: true, enumerable: true, configurable: true}\n// 现在将其修改为不可配置\nObject.defineProperty(obj, 'a', {configurable: false});\n// 再将其改回可配置\nObject.defineProperty(obj, 'a', {configurable: true});\n// TypeError: Cannot redefine property\n// 如果使用Reflect.defineProperty将返回一个布尔值，而不是抛出异常。\nReflect.defineProperty(obj, 'a', {configurable: true}); // false\n```\n\n## 4、Reflect.deleteProperty(target, propertyKey)\n\n该方法主要是将Object操作变成函数行为。等同于delete obj[name];\n\n```js\nvar obj = { a: 1 };\nReflect.deleteProperty(obj, 'a'); // true\nobj.a; // undefined\n```\n\n## 5、Reflect.get ( target, propertyKey [ , receiver ] )\n\n查找并返回target对象的propertyKey属性。如果没有该属性，则返回undefined。如果propertyKey属性部署了读取函数，则读取函数的this绑定到receiver。\n\n```js\nvar obj = {\n    get foo() { return this.bar(); },\n    bar() { return 1; }\n};\n\nReflect.get(obj, 'foo'); // 1\n\nvar wrapper = { bar() { return 2; }};\nReflect.get(obj, 'foo', wrapper); // 2\n```\n\n## 6、Reflect.getOwnPropertyDescriptor ( target, propertyKey )\n\n```js\nvar obj = { a: 1 };\nObject.getOwnPropertyDescriptor(obj, 'a');\n// {value: 1, writable: true, enumerable: true, configurable: true}\nReflect.getOwnPropertyDescriptor(obj, 'a');\n// {value: 1, writable: true, enumerable: true, configurable: true}\n\n```\n\n## 7、Reflect.getPrototypeOf ( target )\n\n获取对象的原型。相当于Object.getPrototypeOf(target);\n\n```js\nvar obj = {};\nObject.getPrototypeOf(obj) === Object.prototype;  // true\nReflect.getPrototypeOf(obj) === Object.prototype; // true\n```\n\n## 8、Reflect.has ( target, propertyKey )\n\n相当于propertyKey in target，将该操作变成函数行为。\n\n```js\nvar obj = { a:1 };\n'a' in obj; // true\nReflect.has(obj, 'a'); // true\n```\n\n## 9、Reflect.isExtensible ( target )\n\n等同于Object.isExtensible ( target )，判断对象是不是可拓展的\n\n```js\nvar obj = {};\nObject.isExtensible(obj);  // true\nReflect.isExtensible(obj); // true\n```\n\n## 10、Reflect.ownKeys ( target )\n\n等同于Object.getOwnPropertyNames(target)和Object.getOwnPropertySymbols(target)的返回值组合。\n\n```js\nvar obj = { a: 1 };\nobj[Symbol('b')] = 2;\nObject.getOwnPropertyNames(obj); // ['a'];\nObject.getOwnPropertySymbols(obj); // [Symbol(b)]\nReflect.ownKeys(obj); // [\"a\", Symbol(b)]\n```\n\n**与Object.keys()的区别**\n\nObject.keys()返回属性key,但不包括不可枚举的属性\n\nReflect.ownKeys()返回所有属性的key\n\n## 11、Reflect.preventExtensions ( target )\n\n禁止对象扩展，相当于Object.preventExtensions ( target )\n\n```js\nvar obj = { a: 1 };\nReflect.preventExtensions ( obj );\nobj.b = 2;\nobj.b; // undefined\n```\n\n## 12、Reflect.set ( target, propertyKey, V [ , receiver ] )\n\n设置target对象propertyKey属性的值等于V。如果propertyKey属性设置了赋值函数，则赋值函数的this绑定到receiver上。\n\n```js\nvar obj = { a: 1 };\nReflect.set(obj, 'a', 2);\nobj.a; // 2\n\nvar obj2 = {\n    set foo(a) {\n        this.a = a;\n    }\n};\nvar wrapper = { a: 3 };\nReflect.set(target, 'foo', 4, wrapper);\nwrapper.a; // 4\n```\n\n## 13、Reflect.setPrototypeOf ( target, proto )\n\n将target的原型对象设置为proto，等同于Object.setPropertyOf方法。\n\n```js\nvar array = {};\nReflect.setPrototypeOf(array, Array.prototype);\narray.length; // 0\n```\n\n","categories":[],"tags":[]},{"title":"传统 diff 与 diff 优化","url":"/posts/49936/","content":"\n![](/gallery/nor-diff-01.jpeg)\n\n<!-- more -->\n\n# 传统的diff\n\n计算两颗树形结构差异并进行转换，传统diff算法是这样做的：循环递归每一个节点\n\n![](/gallery/nor-diff-02.webp)\n\n比如说左侧的树会依次和右侧的树比较，时间复杂度为O(n^2),找到不同后，还需要对不同的地方做出处理，时间复杂度为O(n),所以总的时间复杂度为O(n^3)，非常消耗性能\n\n# diff的优化\n\n- 只比较同一层，不跨级比较\n- tag不相同，则会直接删除重建，不做深度比较\n- tag和key都相同，则认为其为相同的节点，不再深度比较\n\n","categories":["总结"],"tags":["diff"]},{"title":"详解 js 继承","url":"/posts/31746/","content":"\n![](/gallery/js-extend-01.png)\n\n<!-- more -->\n\n# 预备知识\n\n# 1、构造函数属性\n\n```js\nfunction A(name) {\n    this.name = name; // 实例基本的属性（该属性，强调私有，不共享）\n    this.arr = [1] // 实例引用属性（该属性，强调私有，不共享）\n    this.say = function () {\n        // 实例引用属性吗，强调共享\n        console.log('hello')\n    }\n}\n```\n\n## 2、什么是原型对象\n\n简单来说，每个函数都有prototype属性，它就是原型对象，通过函数实例化出来的对象有个**__proto__**属性，指向原型对象\n\n```js\nlet a = new A()\na.__proto__ == A.prototype\n// prototype的结构如下\nA.prototype = {\n    constructor: A\n    ...其他属性和方法\n}\n```\n\n## 3、原型链\n\n每个对象都有原型，当访问这个变量的时候，这个变量不存在就访问他的原型，就这样一直循环下去就产生了原型链！\n\n![](/gallery/js-extend-02.png)\n\n首先，fn的构造函数是Foo()。所以：\nfn._ _ proto _ _=== Foo.prototype\n又因为Foo.prototype是一个普通的对象，它的构造函数是Object，所以：\nFoo.prototype._ _ proto _ _=== Object.prototype\n通过上面的代码，我们知道这个toString()方法是在Object.prototype里面的，当调用这个对象的本身并不存在的方法时，它会一层一层地往上去找，一直到null为止。\n\n\n所以当fn调用toString()时，JS发现fn中没有这个方法，于是它就去Foo.prototype中去找，发现还是没有这个方法，然后就去Object.prototype中去找，找到了，就调用Object.prototype中的toString()方法。\n\n\n这就是原型链，fn能够调用Object.prototype中的方法正是因为存在原型链的机制。\n\n另外，在使用原型的时候，一般推荐将需要扩展的方法写在构造函数的prototype属性中，避免写在_ _ proto _ _属性里面。\n\n## 4、原型对象的作用\n\n原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通的对象而已。并且所有的实例是共享同一个原型对象,因此有别于实例方法或属性，原型对象仅一份。实例对象有很多份且实例属性和⽅法是独⽴的。在构造函数中：为了属性(实例基本属性)的私有性、以及⽅法(实例引⽤属性)的复⽤、共享。我们提倡： \n\n- 将属性封装在构造函数中\n- 将方法定义在原型对象上\n\n```js\nfunction A(name) {\n  this.name = name; // (该属性，强调私有，不共享)\n}\nA.prototype.say = function () {\n  // 定义在原型对象上的⽅法 (强调复⽤，需要共享)\n  console.log(\"hello\");\n};\n// 不推荐的写法：[原因](https://blog.csdn.net/kkkkkxiaofei/article/details/46474303)\nA.prototype = {\n  say: function () {\n    console.log(\"hello\");\n  },\n};\n\n```\n\n# 继承方式\n\n## 方式1、原型链继承\n\n**核心：将父类实例作为子类的原型**\n\n优点： 方法复用\n\n​             由于方法定义在父类的原型上，复用了父类构造函数的方法。比如说say方法。\n\n缺点：\n\n-    创建子类的时候，不能向父类传递参数，比如说name。\n- ​    子类实例共享了父类构造函数的引用属性，比如说arr属性。\n- ​    无法实现多继承（同时继承多个父类）\n\n```js\n// 父类\nfunction Parent(name) {\n  this.name = name || \"父亲\"; //实例基本属性(该属性，强调私有，不共享)\n  this.arr = [1]; //(该属性，强调私有)\n}\nParent.prototype.say = function () {\n  // 将要复用，共享方法定义在父类原型上\n  console.log(\"hello\");\n};\n// 子类\nfunction Child(like) {\n  this.like = like;\n}\n// 1.原型链继承\nChild.prototype = new Parent(); //核心\nChild.prototype.constructor = Child; // 修正constructor指向\nlet boy1 = new Child();\nlet boy2 = new Child();\n// 优点：共享了父类构造函数的say方法\nboy1.say();\nboy2.say();\nconsole.log(boy1.say === boy2.say); // hello , hello , true\n// 缺点1：不能向父类的构造函数传参\nconsole.log(boy1.name, boy2.name, boy1.name == boy2.name);\n// 缺点2：子类实例共享了父类构造函数的应用属性，比如说arr\nboy1.arr.push(2);\nconsole.log(boy2.arr); // 注意修改boy1的name，boy2的name不影响\n//注意要修改child类实例的constructor的指向\n\n```\n\n## 方式2、借用构造函数\n\n**核心：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。**\n\n优点：实例之间独立\n\n-   创建子类实例，可以向父类构造函数传递参数。\n-   子类实例不共享父类构造函数中的应用属性，比如说arr属性\n-   可以实现多继承（通过多个call或者apply继承多个父类）\n\n缺点：\n\n-   父类的方法不能复用\n-  子类实例，继承不了父类原型上的属性（应为没有用到原型）\n\n```js\n// 父类\nfunction Parent(name) {\n  this.name = name || \"父亲\"; //实例基本属性(该属性，强调私有，不共享)\n  this.arr = [1]; //(该属性，强调私有)\n}\nParent.prototype.say = function () {\n  // 将要复用，共享方法定义在父类原型上\n  console.log(\"hello\");\n};\n// 子类\nfunction Child(name, like) {\n  Parent.call(this, name); //核心 拷贝了父类的实例属性和方法\n  this.like = like;\n}\n\nlet boy1 = new Child(\"小红\", \"apple\");\nlet boy2 = new Child(\"小明\", \"orange\");\n// 优点1: 可向父类构造函数传参\nconsole.log(boy1.name, boy2.name); // 小红 小明\n// 优点2: 不共享父类构造函数的引用类型\nboy1.arr.push(2);\nconsole.log(boy1.arr, boy2.arr);\n// 缺点1：方法不能复用\nconsole.log(boy1.say === boy2.say);\n// 缺点2: 不能继承父类原型上的方法\nboy1.say();   // boy1.say is not a function\n\n```\n\n## 方式3、组合继承\n\n**核心：通过调用父类的构造函数，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数的复用。**\n\n优点：\n\n保留构造函数的优点：创建子类可以传递参数。\n\n保留原型链的优点：父类的方法定义在父类的原型对象上，可以实现方法的复用。\n\n不共享父类的应用属性。比如arr属性。\n\n缺点：\n\n由于调用了两次父类的构造方法，会存在一份多余的父类实例属性。\n\n第⼀次Parent.call(this);从⽗类拷⻉⼀份⽗类实例属性，作为⼦类的实例属性，第⼆次 Child.prototype = new Parent();创建⽗类实例作为⼦类原型，Child.protype中的⽗类属性和⽅法会被第⼀次拷⻉来的实例属性屏蔽掉，所以多余。\n\n```js\nfunction Parent(name) {\n  this.name = name || \"父亲\"; //实例基本属性(该属性，强调私有，不共享)\n  this.arr = [1]; //(该属性，强调私有)\n}\nParent.prototype.say = function () {\n  // 将要复用，共享方法定义在父类原型上\n  console.log(\"hello\");\n};\n// 子类\nfunction Child(name, like) {\n  Parent.call(this, name); //核心 拷贝了父类的实例属性和方法\n  this.like = like;\n}\nChild.prototype = new Parent(); // 核心\nChild.prototype.constructor = Child; // 修正constructor的指向\n\nlet boy1 = new Child(\"小红\", \"apple\");\nlet boy2 = new Child(\"小明\", \"orange\");\n\n// 优点1: 可向父类构造函数传参\nconsole.log(boy1.name, boy2.name); // 小红 小明\n// 优点2: 不共享父类构造函数的引用类型\nboy1.arr.push(2);\nconsole.log(boy1.arr, boy2.arr);\n// 优点3：方法能复用\nconsole.log(boy1.say === boy2.say);\n// 优点4: 能继承父类原型上的方法\nboy1.say();\n// 缺点1：由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性\nconsole.log(Child.prototype.__proto__ === Parent.prototype);\nconsole.log(Child.prototype);\n\n```\n\n## 方式4、组合继承优化1\n\n**核心：通过这种方式，砍掉父类的实例属性，这样在调用父类构造函数的时候，就不会初始化两次实例，**\n\n**避免组合继承的缺点。**\n\n优点：\n\n- 只调用一次父类构造函数。\n- 保留构造函数的优点：创建子类实例，可以向父类构造函数传递参数。\n- 保留原型链的优点\n\n缺点：\n\n修正构造函数的指向后，父类实例的构造函数指向，同时也发生变化\n\n原因是：不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数。\n\n```js\nfunction Parent(name) {\n  this.name = name || \"父亲\"; //实例基本属性(该属性，强调私有，不共享)\n  this.arr = [1]; //(该属性，强调私有)\n}\nParent.prototype.say = function () {\n  // 将要复用，共享方法定义在父类原型上\n  console.log(\"hello\");\n};\n// 子类\nfunction Child(name, like) {\n  Parent.call(this, name); //核心 拷贝了父类的实例属性和方法\n  this.like = like;\n}\nChild.prototype = Parent.prototype; // 核⼼ ⼦类原型和⽗类原型，实质上是同⼀个\nChild.prototype.constructor = Child;\n// 缺点1：当修复⼦类构造函数的指向后，⽗类实例的构造函数指向也会跟着变了。 没修复之前：\nconsole.log(boy1.constructor); // Parent 修复代码：\nChild.prototype.constructor = Child; //修复之后：\nconsole.log(boy1.constructor); // Child\nconsole.log(p1.constructor); // Child 这⾥就是存在的问题(我们希望是Parent) 具体原因：因为是通过原型来实现继承的，Child.prototype的上⾯是没有constructor属性的， 就会往上找，这样就找到了Parent.prototype上⾯的constructor属性；当你修改了⼦类实例的 construtor属性，所有的constructor的指向都会发⽣变化。\n\n```\n\n## 方式5、组合寄生继承--完美方式\n\n```js\nfunction Parent(name) {\n  this.name = name || \"父亲\"; //实例基本属性(该属性，强调私有，不共享)\n  this.arr = [1]; //(该属性，强调私有)\n}\nParent.prototype.say = function () {\n  // 将要复用，共享方法定义在父类原型上\n  console.log(\"hello\");\n};\n// 子类\nfunction Child(name, like) {\n  Parent.call(this, name); //核心 拷贝了父类的实例属性和方法\n  this.like = like;\n}\n// 核⼼ 通过创建中间对象，⼦类原型和⽗类原型，就会隔离开。不是同⼀个啦，有效避免了⽅式4的缺点。\nChild.prototype = Object.create(Parent.prototype);\n// 这⾥是修复构造函数指向的代码\nChild.prototype.constructor = Child;\nlet boy1 = new Child(\"⼩红\", \"apple\");\nlet boy2 = new Child(\"⼩明\", \"orange\");\nlet p1 = new Parent(\"⼩爸爸\");\n\n```\n\n## 为什么要修正constructor的指向\n\n```js\n\nfunction People(name){\n    this.eat = function(){\n        alert(\"eat\");\n    }\n}\nfunction Woman(){\n    this.dance = function(){\n        alert(\"dance\");\n    }\n}\nWoman.prototype = new People();\nWomen.prototype.constructor = Women;\n```\n\n1、不更正constructor的情形\n\n```js\n\nvar man;\nvar gril;\n(function(){\n    function People(name){\n        this.eat = function(){\n            alert(\"eat\");\n        }\n    }\n    function Woman(){\n        this.dance = function(){\n            alert(\"dance\");\n        }\n    }\n    Woman.prototype = new People();\n    //Women.prototype.constructor = Women;//不更正\n    People.prototype.sayName = function(){\n        alert(this.name);\n    }\n    man = new People(\"lili\");\n    gril = new Women();\n})()\nman.constructor.prototype.sayHi = function(){\n    alert(\"hi\");\n}\ngril.constructor.prototype.sayLove = function(){\n    alert(\"i love u\");\n}\ngril.sayHi();//\"hi\"\ngril.sayLove();//\"i love u\"\nman.sayHi();//\"hi\"\t\t\nman.sayLove();//\"i love u\"   (不应该添加到People类)\n\n```\n\n可以看到，这里给父类添加了方法sayHi，给子类添加了方法sayLove，但是并未更正constructor的时候，没有达到我们想要的效果，把sayLove也添加到了父类people中，这是因为存在如下的关系\n\n![](/gallery/js-extend-03.png)\n\n可以看出，gril.constructor.prototype = man.constructor.protype=People.prototype，所以sayLove被添加到父类People中也是情理之中的了。\n\n2、更正后\n\n```js\nvar man;\nvar gril;\n(function(){\n    function People(name){\n        this.eat = function(){\n            alert(\"eat\");\n        }\n    }\n    function Woman(){\n        this.dance = function(){\n            alert(\"dance\");\n        }\n    }\n    Woman.prototype = new People();\n    Women.prototype.constructor = Women;//更正\n    People.prototype.sayName = function(){\n        alert(this.name);\n    }\n    man = new People(\"lili\");\n    gril = new Women();\n})()\nman.constructor.prototype.sayHi = function(){\n    alert(\"hi\");\n}\ngril.constructor.prototype.sayLove = function(){\n    alert(\"i love u\");\n}\ngril.sayHi();//\"hi\"\ngril.sayLove();//\"i love u\"\nman.sayHi();//\"hi\"\t\t\nman.sayLove();//报错\n\n```\n\n现在我们的目的就实现啦！那么我们再来看看此时的原型图吧： \n\n![](/gallery/js-extend-04.png)\n\nconstructor更正后就可以通过child.constructor.prototype在原型上添加方法了\n\n# 其他问题\n\n## 1、Object.create(object, propertiesObject)\n\nObject.create()⽅法创建⼀个新对象，使⽤第⼀个参数来提供新创建对象的__proto__（以第⼀个参 \n\n数作为新对象的构造函数的原型对象）； ⽅法还有第⼆个可选参数，是添加到新创建对象的属性，写法如下。\n\n```js\nconst a = Object.create(Person.prototype, {\n  age: { value: 12, writable: true, configurable: true },\n});\n```\n\n- new 与 Object.create() 的区别？\n\nnew 产⽣的实例，优先获取构造函数上的属性；构造函数上没有对应的属性，才会去原型上查找； \n\n如果构造函数中以及原型中都没有对应的属性，就会报错。Object.create() 产⽣的对象，只会在原 \n\n型上进⾏查找属性，原型上没有对应的属性，就会报错。 \n\n```js\nlet Base1 = function () {\n  this.a = 1;\n};\nlet o1 = new Base1();\nlet o2 = Object.create(Base1.prototype);\nconsole.log(o1.a); // 1\nconsole.log(o2.a); // undefined\nlet Base2 = function () {};\nBase2.prototype.a = \"aa\";\nlet o3 = new Base2();\nlet o4 = Object.create(Base2.prototype);\nconsole.log(o3.a); // aa\nconsole.log(o4.a); // aa\nlet Base3 = function () {\n  this.a = 1;\n};\nBase3.prototype.a = \"aa\";\nlet o5 = new Base3();\nlet o6 = Object.create(Base3.prototype);\nconsole.log(o5.a); // 1\nconsole.log(o6.a); // aa\n\n```\n\n## 2、new的过程\n\n创建新的对象（如object）\n\n将新的对象的--proto--指向构造函数的prototype对象\n\n执行构造函数，为这个新对象添加属性，并将this指向创建的新对象object\n\n当构建函数本身返回值为对象时，返回该对象，否则返回新对象\n\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nfunction _new(fn, ...args) {\n  // 创建一个空对象obj,并让其继承fn.prototype\n  let obj = Object.create(fn.prototype);\n  // 执行构造函数，并让this指向创建的空对象obj\n  let result = fn.call(obj, ...args);\n  // 当返回值为对象时，返回该对象，否则返回新的对象obj\n  return result instanceof Object ? result : obj;\n}\nlet ming = _new(Person, \"小明\", 18);\nconsole.log(ming);\n```\n\nObject.create创建obj,使得obj.__proto__==Fn.prototype\n\n## 3、为什么‘组合继承’这种方式，会执行两次父类函数\n\n- 第一次：new Parent()\n\n'new'的过程的第三步，其实就是执行父类的构造函数。\n\n- 第二次Parent.call(this,name,like)\n\ncall的作⽤是改变函数执⾏时的上下⽂。⽐如：A.call(B)。其实，最终执⾏的还是A函数，只不过是 \n\n⽤B来调⽤⽽已。所以，你就懂了Parent.call(this,name,like) ,也就是执⾏了⽗类构造函数Person。\n","categories":["继承"],"tags":["JavaScript"]},{"title":"JS 中 == 与 ===","url":"/posts/33716/","content":"\n![](/gallery/js-2022-2-12.jpeg)\n\n<!-- more -->\n\n```js\nif(a == 1 && a == 2 && a == 3) { \n\tconsole.log('成功');\t\t// 成功\n}\n```\n\n问：a取什么值的时候会输出**成功**\n\n解答：明显这道题考了“==”的判断，先复习一下“===”和“==”的比较过程\n\n**===**\n\n1.如果类型不同，就**不相等**\n\n2.如果两个都是数值，并且是同一个值，那么**相等**，如果数值是NaN,则**不相等**\n\n3.如果两个是字符串，每个位置的字符都是一样的，那么**相等**，否则**不相等**\n\n4.如果两个都是true、false、null、undefined，那么**相等**，否则**不相等**\n\n5.如果两个值都是引用同一个对象或者函数，那么**相等**，否则**不相等**\n\n**==**\n\n1.如果两个值类型形同，进行===比较\n\n2.如果两个类型不同，他们可能相等，规则如下\n\na、如果是一个null、一个undefined，那么相等\n\nb、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较\n\nc、如果任一值是true，把它变成1再比较；如果任一值是false，把它转换成0再比较\n\n(undefined、null、false、-0、NaN,'' ,这个6个值会解释成false，其他的值都会被解释为true)\n\nd、如果是一个对象，另一个是数值或者字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toSting或者valueOf方法。js核心内置类，会尝试valueOf先于toString;例外的是Date，Date利用的是toString转换。\n\ne、其他组合都不相等\n\n所以，改写a的toString方法即可，每次进行“==”判断的时候动态改变a的值\n\n```js\n\nlet a = { \n\ti: 1,\n\ttoString () { \t\t//或者valueOf \n\t\treturn a.i++ \t//根据逻辑，这里是先返return后加 \n\t} \n} \n\nif(a == 1 && a == 2 && a == 3) { \n\tconsole.log('成功');\t\t// 成功\n}\n\nconsole.log(a.i)  // 4  每调用一次toString方法i自增，证明确实有在自动调用toString方法\n```\n\n","categories":[],"tags":[]},{"title":"React 的生命周期验证","url":"/posts/36377/","content":"\n![](/gallery/react-bg.jpeg)\n\n<!-- more -->\n\n今天我们来验证一下`React`类组件的声明周期，本文基于`React17.2`。\n\n![](/gallery/react-life-constructor.png)\n\n# 单组件\n\n## 组件挂载\n\n### constructor()\n\n```js\nconstructor(props) {\n    super(props);\n    this.state = {}\n    console.log(\"constructor!!\");\n}\n```\n\n**如果不初始化state或不进行方法的绑定，则不需要为React组件实现构造函数**\n\n实现构造函数的时候要调用super(),初始化父类\n\n在构造函数仅用于以下两种情况：\n\n- 通过this.state赋值对象来初始化内部的state。\n- 为事件处理函数绑定实例\n\n不要在constructor()中调用**setState()方法**，用this.state初始化state\n\n```js\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免在构造函数中引入任何副作用或订阅。如遇到此场景，请将对应的操作位置放到`componentDidMount`\n\n### static getDerivedStateFromProps()\n\n```js\nstatic getDerivedStateFromProps(props, state) {\n    console.log(\"getDerivedStateFromProps!!\");\n    return null;\n}\n```\n\n`getDerivedStateFromPros` 会在调用render方法之前调用，并且在初始挂载及后续更新时都会被调用。它返回一个新的state，如果是null则不更新任何内容，state的值在任何时候都取决于prop。\n\n派生状态会导致代码冗余，并使组件难以维护，可以使用以下代替方案：\n\n- 如果你需要执行副作用(例如，数据提取或动画)以响应props中的更改，请改用componentDidUpdate。\n- 如果只想在props更改时重新计算某些数据，请使用menoization helper代替\n- 如果你想在props更改时“重置”某些state，请考虑组件完全受控或使用key使组件完全不受控代替\n\n请注意，不管原因是什么，都会在*每次*渲染前触发此方法。这与 `UNSAFE_componentWillReceiveProps` 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 `setState` 时。\n\n### render()\n\n```js\nrender()\n```\n\n`render`方法是class组件中唯一必需实现的方法\n\n当`render`被调用时，它会检查`this.props`和`this.state`的变化返回以下类型之一：\n\n- React元素。通常通过JSX创建\n- 数组或者fragments\n- Portals 可以 渲染子节点到不同的DOM树上\n- 字符串或者数值类型  它们在DOM树上渲染文本节点\n- 布尔类型或null 什么都不渲染\n\n`render()`函数为纯函数\n\n**注意 如果shouldComponentUpdate() 返回false，则不会调用render()**\n\n### componentDidMount()\n\n```js\ncomponentDidMount()\n```\n\n`componentDidMount`会在组件挂载后(插到DOM树上)立即调用。依赖于DOM节点的初始化应该放到在这里。\n\n如果是通过网络请求获取的数据也应该放到这里请求。也可以在这里添加订阅，如果订阅了，请不要忘记在`componentWillUnmount()`里取消订阅\n\n![](/gallery/react-constructor-life.png)\n\n## 组件更新\n\n**static getDerivedStateFromProps()**\n\n### shouldComponentUpdate()\n\n```\nshouldComponentUpdate(nextprops, nextState)\n```\n\n![](/gallery/shouldcomponentupdate.png)\n\nnextprops, nextState都是将要改变的值\n\n根据`shouldComponentUpdate()`的返回值，判断React组件的输出是否受当前state或props更改的影响。默认行为是state每次发生变化组件都会重新渲染。大部分情况下都应遵守默认行为。当props或state发生改变时。`shouldComponentUpdate()`会在渲染执行前调用，返回值默认是true。首次渲染或者使用`forceUpdate()`时不会调用。该方法仅作为**性能优化**的方式存在。\n\n**render()**\n\n### getSnapshotBeforeUpdate()\n\n```js\ngetSnapshotBeforeUpdate(prevProps, prevState)\n```\n\n`getSnapshotBeforeUpdate()`在最近一次渲染输出(提交到DOM节点)之前调用。它使得组件能在发生更改之前从DOM 中捕获一些信息(例如，滚动位置)。此生命周期方法的任何返回值将作为参数传递给`componentDidUpdate()`,在UI处理中，如需以特殊方式处理滚动位置的聊天线程可用此生命周期，应返回snapshot的值(或null)\n\n### componentDidUpdate()\n```js\ncomponentDidUpdate(prevProps, prevState, snapshot)\n```\n\n`componentDidUpdate()`会在更新后会被立即调用。首次渲染不会执行此方法。\n\n当组件更新后，可以在此处对DOM进行操作，如果你对更新的props进行了比较，也可以选择在此处进行网络请求。例如，当props未发生变化时，则不会执行网络请求。可以在这里使用setState(), 但它必需被包裹在一个条件语句里，否则还会导死循环,它还会导致额外的重新渲染，影响组件性能，不要将props镜像给state\n\n![](/gallery/react-update-life.png)\n\n## 组件卸载\n\n### componentWillUnmount()\n\n```\ncomponentWillUnmount()\n```\n\n`componentWillUnmount()`会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除timer、网络请求、订阅，不能调用setState(),因为不会重新渲染。\n\n![](/gallery/react-willUnmount-life.png)\n\n# 同时渲染的父子组件\n\n## 组件挂载\n\n![](/gallery/react-p-constructor-life.png)\n\n## 父组件更新\n\n![](/gallery/react-p-update-life.png)\n\n## 组件卸载\n\n![](/gallery/react-p-willUnmount-life.png)\n\n**注意，先是显示要渲染的组件，当组件调用render方法时，上个组件才到卸载的生命周期**\n\n# 不同时渲染的父子组件\n\n该场景中，通过父组件的点击modal来控制子组件显示\n\n## 组件挂载\n\n![](/gallery/react-a-constructor-life.png)\n\n# 在父组件挂载的时候，请求数据\n\n![](/gallery/react-axios-constructor-life.png)\n\n最后附上本文的代码：[代码](https://github.com/GaussYuan191/react-life)\n\n","categories":["验证"],"tags":["React，父子组件"]},{"title":"ES6","url":"/posts/13229/","content":"\n\n\n<!-- more -->\n\n## ES6小结\n\n### let和const\n#### 1.let 命令\n\n#### 块级作用域\n\n```js\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n\n\n\nfor循环有一个特别之处，就是设置环境变量的那个部分是一个父级作用域，而循环体内部是一个单独的字作用域\n\n```js\nfor (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n```\n\n#### 不存在变量提升\n\nvar命令会发生变量提升，那么什么是变量提升呢？变量提升就是变量可以在声明之前使用，值为undefined，这多多少少是会有些奇怪的，let命令就不会有这种问题\n\n```js\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n#### 暂时性死区\n\n只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响\n\n```js\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n```\n\n在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”\n\n“暂时性死区”也意味着typeof不再是一个百分百安全的操作\n\n```js\ntypeof x; // ReferenceError\nlet x;\ntypeof undeclared_variable // \"undefined\"\n```\n\n有些“死区”比较隐藏，不太容易发现\n\n```js\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n```\n\n应为函数也有自己的作用域，x和y是参数，形参不是变量，也不会提升成全局变量，执行 x = y 时 y没有定义 则会发生\"死区\"问题\n\n```js\n// 修改\nfunction bar(x = 2, y = x) {\n  return [x, y];\n}\nbar(); // [2, 2]\n```\n\n#### 不允许重复声明\n\nlet不允许在相同的作用域中，重复声明同一个变量\n\n```js\n// 报错\nfunction func() {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction func() {\n  let a = 10;\n  let a = 1;\n}\n```\n\n因此，不能在函数内部重新声明参数。\n\n```js\nfunction func(arg) {\n  let arg;\n}\nfunc() // 报错\n\nfunction func(arg) {\n  {\n    let arg;\n  }\n}\nfunc() // 不报错\n```\n\n#### 2.块级作用域\n\nES5 只有全局作用域和函数作用域，没有块级作用域，这就带来很多不合理的场景\n\n第一种场景，内层变量可能会覆盖外层变量\n\n```js\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = 'hello world';\n  }\n}\n\nf(); // undefined\n```\n\n因为 if 中 用var声明了变量tmp, 所以变量tmp提升了，相当于\n\n```js\nvar tmp = new Date();\n\nfunction f() {\n  var tmp\n  console.log(tmp);\n  if (false) {\n   tmp  = 'hello world';\n  }\n}\n\nf(); // undefined\n```\n\n第二种场景，用来计数的循环变量泄露成全局变量\n\n```js\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n\n```\n\n上面的i只是用来循环计数的变量，但在循环结束之后，它并没有消失，泄露成了全局变量\n\n在es6中引入了块级作用域\n\nlet 实际上为js新增的跨级作用域\n\n```\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n```\n\n块级作用域可以嵌套\n\n#### 函数声明\n\nES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明\n\n- 在ES6中，允许在块级作用域中声明函数\n- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部\n- 同时，函数声明还会提升到所在块级作用域的头部\n\n```js\n// 浏览器的 ES6 环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  var f = undefined;\n  if (false) {\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n\n#### 3.const 命令\n\nconst声明一个只读的变量，一旦声明，常量的值就不能改变，它是指变量保存的地址存的数据不得改动\n\n```js\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: \"foo\" is read-only\n```\n\n冻结对象可以使用Object.freeze() 方法\n\n#### ES6 中声明变量有6中方法 \n\nES6之前 var、function，ES6之后let、const、import、class\n\n#### 4.顶层对象属性\n\n浏览器环境指windows对象，在node中指global对象，es5的时候顶层对象的属性与全局变量的赋值，是同一件事\n\nweb worker里面， self也指向顶层对象\n\n### 变量和结构赋值\n\n#### 1.数组的结构赋值\n\n```js\nlet a = 1;\nlet b = 2;\nlet c = 3;\n///////////\nlet [a, b, c] = [1, 2, 3];\n```\n\n如果解构不成功，变量的值就等于undefined\n\n如果等号右边不是一个可遍历的结构，也会报错，对于Set结构，也可以使用数组的解构赋值\n\n```js\nlet [x, y, z] = new Set(['a', 'b', 'c']);\nx // \"a\"\n```\n\n事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。\n\n```js\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n#### 默认值\n\n解构赋值允许指定默认值\n\n```js\nlet [foo = true] = [];\nfoo // true\n\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n```\n\n没有传值相当于undefined，也只有当一个数组的成员变量严格等于undefined，默认值才会生效\n\n```js\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n```\n\n#### 2.对象的解构赋值\n\n```js\nlet { bar, foo } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // undefined\n```\n\n解构失败，变量的值等于undefined\n\n```js\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n\n#### 注意点\n\n1.如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n```\n// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n// 正确的写法\nlet x;\n({x} = {x: 1})\n```\n\n上面这种语法会报错，JavaScript引擎会将{X}理解成一个代码块，从而发生语法错误，正确的做法是加个大括号\n\n2.解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。\n\n```js\n({} = [true, false]);\n({} = 'abc');\n({} = []);\n```\n\n虽然奇怪，但是可以语法是合法的，可以运行\n\n3.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\n```js\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n```\n\n#### 3.字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\n```js\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n#### 4.数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\n\n```js\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n```\n\n#### 5.函数参数的解构赋值\n\n```js\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n///////////////////////\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n#### 6.圆括号问题\n\n以下三种解构赋值不得使用圆括号。\n\n模式中\n\n```js\n// 全部报错\nlet [(a)] = [1]; //不能在声明中使用\n\nlet {x: (c)} = {};\nlet ({x: c}) = {};\nlet {(x: c)} = {};\nlet {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n```\n\n函数参数\n\n```js\n// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n```\n\n赋值语句的模式\n\n````js\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n````\n\n可以在赋值语句的非模式的时候使用\n\n```js\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n```\n\n#### 7.用途\n\n1.交换变量\n\n```js\nlet x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n```\n\n2.从函数中返回多个值\n\n```js\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n```\n\n3.函数参数的定义\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n```js\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n4.提取JSON数据\n\n```js\nlet jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n5.函数参数的默认值\n\n```js\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};\n```\n\n6.遍历Map解构\n\n```js\nconst map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n//////////////////////////////\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n7.输入模块的指定方法\n\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\n\n```js\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n### 字符串的扩展\n\n#### 1.字符的Unicode表示法\n\nES6 加强了对 Unicode 的支持，允许采用`\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\n\n```\n\"\\u0061\"\n// \"a\"\n```\n\n但是，这种表示法只限于码点在`\\u0000`~`\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\n\n```\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\n\"\\u20BB7\"\n// \" 7\"\n```\n\n上面代码表示，如果直接在`\\u`后面跟上超过`0xFFFF`的数值（比如`\\u20BB7`），JavaScript 会理解成`\\u20BB+7`。由于`\\u20BB`是一个不可打印字符，所以只会显示一个空格，后面跟着一个`7`。\n\nES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。\n\n```\n\"\\u{20BB7}\"\n// \"𠮷\"\n\n\"\\u{41}\\u{42}\\u{43}\"\n// \"ABC\"\n\nlet hello = 123;\nhell\\u{6F} // 123\n\n'\\u{1F680}' === '\\uD83D\\uDE80'\n// true\n\n```\n\n上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。\n\n有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。\n\n```\n'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n```\n\n#### 2.字符串的遍历器接口\n\nES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被`for...of`循环遍历。\n\n```js\nfor (let codePoint of 'foo') {\n  console.log(codePoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n```\n\n#### 3.直接输入 U+2028 和 U+2029 \n\n#### 4.JSON.stringify() 的改造 \n\n#### 5.模板字符串\n\n```js\n// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n如果需要引用模板字符串本身，在需要时执行，可以写成函数。\n\n```javascript\nlet func = (name) => `Hello ${name}!`;\nfunc('Jack') // \"Hello Jack!\"\n```\n\n上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了\n\n#### 6.实例：模板编译\n\n#### 7.标签模板\n\n```js\nlet a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n```\n\n### 字符串的新增方法\n\n#### 1. String.fromCodePoint()\n\n可识别大于`0xFFFF`的码点\n\n注意，`fromCodePoint`方法定义在`String`对象上，而`codePointAt`方法定义在字符串的实例对象上。\n\n#### 2.String.raw()\n\nES6 还为原生的 String 对象，提供了一个`raw()`方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。\n\n```js\nString.raw`Hi\\n${2+3}!`\n// 实际返回 \"Hi\\\\n5!\"，显示的是转义后的结果 \"Hi\\n5!\"\n\nString.raw`Hi\\u000A!`;\n// 实际返回 \"Hi\\\\u000A!\"，显示的是转义后的结果 \"Hi\\u000A!\"\n```\n\n#### 3.实例方法：codePointAt()\n\n#### 4.实例方法\n\n传统上，JavaScript 只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\n\n- **includes()**：返回布尔值，表示是否找到了参数字符串。\n- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。\n- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n#### 5. repeat()\n\nrepeat() 用于返回一个新字符串，表示将原字符串重复n次\n\n```\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\n```\n\n参数如果是小数，会被下取整数, 如果参数是负数或者infinity\n\n```js\n'na'.repeat(2.9) // \"nana\"\n'na'.repeat(0.5) //''\n'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n```\n\n但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于`-0`，`repeat`视同为 0。\n\n```javascript\n'na'.repeat(-0.9) // \"\"\n```\n\n参数`NaN`等同于 0。\n\n```javascript\n'na'.repeat(NaN) // \"\"\n```\n\n如果`repeat`的参数是字符串，则会先转换成数字。\n\n```javascript\n'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n```\n\n#### 6.实例方法 padStart(),padEnd()\n\n字符串补全，padStart()在头部补全，padEnd()在尾部补全，一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。\n\n```\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n```\n\n`padStart()`和`padEnd()`一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。\n\n```js\n'xxx'.padStart(2, 'ab') // 'xxx'\n'xxx'.padEnd(2, 'ab') // 'xxx'\n'abc'.padStart(10, '0123456789')\n// '0123456abc'\n'x'.padStart(4) // '   x'\n'x'.padEnd(4) // 'x   '\n'1'.padStart(10, '0') // \"0000000001\"\n'12'.padStart(10, '0') // \"0000000012\"\n'123456'.padStart(10, '0') // \"0000123456\"\n```\n\n另一个用途是提示字符串格式。\n\n```javascript\n'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\n'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\n```\n\n#### 7.实例方法：trimStart(), trimEnd()\n\ntrimStart() 消除开头的空格，trimEnd() 消除尾部空格，他们都是返回新的字符串，不会修改原字符串\n\n```javascript\nconst s = '  abc  ';\n\ns.trim() // \"abc\"\ns.trimStart() // \"abc  \"\ns.trimEnd() // \"  abc\"\n```\n\n除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。\n\n浏览器还部署了额外的两个方法，`trimLeft()`是`trimStart()`的别名，`trimRight()`是`trimEnd()`的别名。\n\n#### 8.实例方法： matchAll()\n\n#### 9.实例方法：replaceAll()\n\n在正则中要加g,开启全局搜索\n\n#### 10 at()\n\n`at()`方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。\n\n```javascript\nconst str = 'hello';\nstr.at(1) // \"e\"\nstr.at(-1) // \"o\"\n```\n\n如果参数位置超出了字符串范围，`at()`返回`undefined`。\n\n该方法来自数组添加的`at()`方法，目前还是一个第三阶段的提案\n\n#### 正则的扩展\n\n#### 1.RegExp 构造函数\n\nES5 不允许此时使用第二个参数添加修饰符，否则会报错。\n\n```javascript\nvar regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n```\n\nES6 改变了这种行为。如果`RegExp`构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。\n\n```javascript\nnew RegExp(/abc/ig, 'i').flags\n// \"i\"\n```\n\n上面代码中，原有正则对象的修饰符是`ig`，它会被第二个参数`i`覆盖。\n\n#### 2.RegExp.prototype.sticky 属性\n\n与`y`修饰符相匹配，ES6 的正则实例对象多了`sticky`属性，表示是否设置了`y`修饰符。\n\n```javascript\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n#### 3.RegExp.prototype.flags 属性\n\nES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。\n\n```javascript\n// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n```\n\n### 数值的扩展\n\n#### 1.二进制和八进制表示法\n\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\n\n```javascript\n0b111110111 === 503 // true\n0o767 === 503 // true\n```\n\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\n\n```javascript\n// 非严格模式\n(function(){\n  console.log(0o11 === 011);\n})() // true\n\n// 严格模式\n(function(){\n  'use strict';\n  console.log(0o11 === 011);\n})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n```\n\n如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。\n\n```javascript\nNumber('0b111')  // 7\nNumber('0o10')  // 8\n```\n\n#### 2.数值分隔符\n\n[ES2021](https://github.com/tc39/proposal-numeric-separator)，允许 JavaScript 的数值使用下划线（`_`）作为分隔符。\n\n```javascript\nlet budget = 1_000_000_000_000;\nbudget === 10 ** 12 // true\n```\n\n这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。\n\n```javascript\n123_00 === 12_300 // true\n\n12345_00 === 123_4500 // true\n12345_00 === 1_234_500 // true\n```\n\n小数和科学计数法也可以使用数值分隔符。\n\n```javascript\n// 小数\n0.000_001\n\n// 科学计数法\n1e10_000\n```\n\n数值分隔符有几个使用注意点。\n\n- 不能放在数值的最前面（leading）或最后面（trailing）。\n- 不能两个或两个以上的分隔符连在一起。\n- 小数点的前后不能有分隔符。\n- 科学计数法里面，表示指数的`e`或`E`前后不能有分隔符。\n\n#### 3.Number.isFinite()，Number.isNaN()\n\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）`Number.isNaN()`用来检查一个值是否为`NaN`。\n\n它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回`false`, `Number.isNaN()`只有对于`NaN`才返回`true`，非`NaN`一律返回`false`。\n\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\nNumber.isNaN(1) // false\n```\n\n#### 4.Number.parseInt(), Number.parseFloat()\n\n和原来的全局方法parseInt(),parseFloat()效果一样，只是从全局方法转移到了Number对象上\n\n#### 5.Number.isInteger()\n\n`Number.isInteger()`用来判断一个数值是否为整数。\n\nJavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。\n\n```javascript\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\n```\n\n注意数据如果超出数据范围，该方法失效，如果对数据精度的要求较高，不建议使用\n\n#### 6.Number.EPSILON\n\nES6 在`Number`对象上面，新增一个极小的常量`Number.EPSILON`。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。等于 2 的 -52 次方。`Number.EPSILON`的实质是一个可以接受的最小误差范围。\n\n#### 7.安全整数和 Number.isSafeInteger。\n\nJavaScript 能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\n#### 8.Math 对象的扩展\n\n**Math.trunc()**\n\n 用于去除一个数的小数部分，返回整数部分，对于非数值，`Math.trunc`内部使用`Number`方法将其先转为数值。对于空值和无法截取整数的值，返回`NaN`。\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\nMath.trunc('123.456') // 123\nMath.trunc(true) //1\nMath.trunc(false) // 0\nMath.trunc(null) // 0\n```\n\n**Math.sign()**\n\n `Math.sign`方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。\n\n它会返回五种值。\n\n- 参数为正数，返回`+1`；\n- 参数为负数，返回`-1`；\n- 参数为 0，返回`0`；\n- 参数为-0，返回`-0`;\n- 其他值，返回`NaN`。\n\n```javascript\nMath.sign('')  // 0\nMath.sign(true)  // +1\nMath.sign(false)  // 0\nMath.sign(null)  // 0\nMath.sign('9')  // +1\nMath.sign('foo')  // NaN\nMath.sign()  // NaN\nMath.sign(undefined)  // NaN\n```\n\n**Math.cbrt()** \n\n计算一个数的立方根，对于非数值，`Math.cbrt()`方法内部也是先使用`Number()`方法将其转为数值。\n\n```javascript\nMath.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948732\nMath.cbrt('8') // 2\nMath.cbrt('hello') // NaN\n```\n\n**Math.clz32()**\n\n 方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。\n\n```javascript\nMath.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1000) // 22\nMath.clz32(0b01000000000000000000000000000000) // 1\nMath.clz32(0b00100000000000000000000000000000) // 2\n```\n\n**Math.imul()** \n\n`Math.imul`方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。\n\n```javascript\nMath.imul(2, 4)   // 8\nMath.imul(-1, 8)  // -8\nMath.imul(-2, -2) // 4\n```\n\n**Math.fround()** \n\n`Math.fround`方法返回一个数的32位单精度浮点数形式。\n\n```javascript\nMath.fround(0)   // 0\nMath.fround(1)   // 1\nMath.fround(2 ** 24 - 1)   // 16777215\n```\n\n**Math.hypot()** \n\n方法返回所有参数的平方和的平方根\n\n如果参数不是数值，`Math.hypot`方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。\n\n```javascript\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755\nMath.hypot(-3);          // 3\n```\n\n**Math.expml()** \n\n`Math.expm1(x)`返回 ex - 1，即`Math.exp(x) - 1`。\n\n```javascript\nMath.expm1(-1) // -0.6321205588285577\nMath.expm1(0)  // 0\nMath.expm1(1)  // 1.718281828459045\n```\n\n**Math.log1p()**\n\n`Math.log1p(x)`方法返回`1 + x`的自然对数，即`Math.log(1 + x)`。如果`x`小于-1，返回`NaN`。\n\n```javascript\nMath.log1p(1)  // 0.6931471805599453\nMath.log1p(0)  // 0\nMath.log1p(-1) // -Infinity\nMath.log1p(-2) // NaN\n```\n\n**Math.log10()**\n\n`Math.log10(x)`返回以 10 为底的`x`的对数。如果`x`小于 0，则返回 NaN。\n\n```javascript\nMath.log10(2)      // 0.3010299956639812\nMath.log10(1)      // 0\nMath.log10(0)      // -Infinity\nMath.log10(-2)     // NaN\nMath.log10(100000) // 5\n```\n\n**Math.log2()**\n\n`Math.log2(x)`返回以 2 为底的`x`的对数。如果`x`小于 0，则返回 NaN。\n\n```javascript\nMath.log2(3)       // 1.584962500721156\nMath.log2(2)       // 1\nMath.log2(1)       // 0\nMath.log2(0)       // -Infinity\nMath.log2(-2)      // NaN\nMath.log2(1024)    // 10\nMath.log2(1 << 29) // 29\n```\n\n#### 9.BigInt 数据类型\n\nES2020引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。\n\n为了与 Number 类型区别，BigInt 类型的数据必须添加后缀`n`。\n\n```javascript\n1234 // 普通整数\n1234n // BigInt\n\n// BigInt 的运算\n1n + 2n // 3n\n```\n\nBigInt 与普通整数是两种值，它们之间并不相等。\n\n```javascript\n42n === 42 // false\n```\n\n`typeof`运算符对于 BigInt 类型的数据返回`bigint`。\n\n```javascript\ntypeof 123n // 'bigint'\n```\n\nBigInt 可以使用负号（`-`），但是不能使用正号（`+`），因为会与 asm.js 冲突。\n\n```javascript\n-42n // 正确\n+42n // 报错\n```\n\n**BigInt函数**\n\nJavaScript 原生提供`BigInt`函数，可以用它生成 BigInt 类型的数值。转换规则基本与`Number()`一致，将其他类型的值转为 BigInt。\n\n```javascript\nBigInt(123) // 123n\nBigInt('123') // 123n\nBigInt(false) // 0n\nBigInt(true) // 1n\n```\n\n`BigInt()`函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。\n\n```javascript\nnew BigInt() // TypeError\nBigInt(undefined) //TypeError\nBigInt(null) // TypeError\nBigInt('123n') // SyntaxError\nBigInt('abc') // SyntaxError\n```\n\n上面代码中，尤其值得注意字符串`123n`无法解析成 Number 类型，所以会报错。\n\n参数如果是小数，也会报错。\n\n```javascript\nBigInt(1.5) // RangeError\nBigInt('1.5') // SyntaxError\n```\n\n### 函数的扩展\n\n#### 1函数的默认参数\n\n```javascript\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n使用参数默认值时，函数不能有同名参数。\n\n```javascript\n// 不报错\nfunction foo(x, x, y) {\n  // ...\n}\n\n// 报错\nfunction foo(x, x, y = 1) {\n  // ...\n}\n// SyntaxError: Duplicate parameter name not allowed in this context\n```\n\n#### 与解构赋值默认值结合使用\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\n```javascript\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n/////////////////////////////////////////////////// 改正\nfunction foo({x, y = 5} = {}) {\n  console.log(x, y);\n}\n\nfoo() // undefined 5\n```\n\n上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数`foo`的参数是一个对象时，变量`x`和`y`才会通过解构赋值生成。如果函数`foo`调用时没提供参数，变量`x`和`y`就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\n```javascript\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n```\n\n#### 函数的length属性\n\n指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真。\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n#### 作用域\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n```\n\n上面代码中，参数`y`的默认值等于变量`x`。调用函数`f`时，参数形成一个单独的作用域。在这个作用域里面，默认值变量`x`指向第一个参数`x`，而不是全局变量`x`，所以输出是`2`。\n\n```javascript\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n```\n\n上面代码中，函数`f`调用时，参数`y = x`形成一个单独的作用域。这个作用域里面，变量`x`本身没有定义，所以指向外层的全局变量`x`。函数调用时，函数体内部的局部变量`x`影响不到默认值变量`x`。\n\n如果此时，全局变量`x`不存在，就会报错。\n\n```javascript\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // ReferenceError: x is not defined\n```\n\n#### 应用\n\n利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。\n\n```javascript\nfunction throwIfMissing() {\n  throw new Error('Missing parameter');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n  return mustBeProvided;\n}\n\nfoo()\n// Error: Missing parameter\n```\n\n上面代码的`foo`函数，如果调用的时候没有参数，就会调用默认值`throwIfMissing`函数，从而抛出一个错误。\n\n#### 2.rest参数\n\nES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n```\n\n上面代码的`add`函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。\n\n注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n```javascript\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n```\n\n函数的`length`属性，不包括 rest 参数。\n\n```javascript\n(function(a) {}).length  // 1\n(function(...a) {}).length  // 0\n(function(a, ...b) {}).length  // 1\n```\n\n#### 3.严格模式\n\n从 ES5 开始，函数内部可以设定为严格模式。\n\n```javascript\nfunction doSomething(a, b) {\n  'use strict';\n  // code\n}\n```\n\nES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n```javascript\n// 报错\nfunction doSomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n```\n\n#### 4.name 属性\n\n函数的`name`属性，返回该函数的函数名。\n\n```javascript\nfunction foo() {}\nfoo.name // \"foo\"\n```\n\n#### 5.箭头函数\n\nES6 允许使用“箭头”（`=>`）定义函数。如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n**使用注意点**\n\n箭头函数有几个使用注意点。\n\n（1）箭头函数没有自己的`this`对象（详见下文）。\n\n（2）不可以当作构造函数，也就是说，不可以对箭头函数使用`new`命令，否则会抛出一个错误。\n\n（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n（4）不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。\n\n上面四点中，最重要的是第一点。对于普通函数来说，内部的`this`指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的`this`对象，内部的`this`就是定义时上层作用域中的`this`。也就是说，箭头函数内部的`this`指向是固定的，相比之下，普通函数的`this`指向是可变的。\n\n#### 6.尾调用优化\n\n尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n```javascript\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数`f`的最后一步是调用函数`g`，这就叫尾调用。\n\n以下三种情况，都不属于尾调用。\n\n```javascript\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n```javascript\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数`m`和`n`都属于尾调用，因为它们都是函数`f`的最后一步操作。\n\n### 数组的扩展\n\n#### 1.扩展运算符\n\n```javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n```\n\n#### 替代函数的apply方法\n\n由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。\n\n```javascript\n// ES5 的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) {\n  // ...\n}\nlet args = [0, 1, 2];\nf(...args);\n```\n\n#### 扩展运算符的应用\n\n**（1）复制数组**\n\n数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。\n\n```javascript\nconst a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n```\n\n上面代码中，`a2`并不是`a1`的克隆，而是指向同一份数据的另一个指针。修改`a2`，会直接导致`a1`的变化。\n\nES5 只能用变通方法来复制数组。\n\n```javascript\nconst a1 = [1, 2];\nconst a2 = a1.concat();\n\na2[0] = 2;\na1 // [1, 2]\n```\n\n上面代码中，`a1`会返回原数组的克隆，再修改`a2`就不会对`a1`产生影响。\n\n扩展运算符提供了复制数组的简便写法。\n\n```javascript\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n```\n\n上面的两种写法，`a2`都是`a1`的克隆。\n\n**（2）合并数组**\n\n扩展运算符提供了数组合并的新写法。\n\n```javascript\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c'];\nconst arr3 = ['d', 'e'];\n\n// ES5 的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n// ES6 的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\n不过，这两种方法都是浅拷贝，使用的时候需要注意。\n\n```javascript\nconst a1 = [{ foo: 1 }];\nconst a2 = [{ bar: 2 }];\n\nconst a3 = a1.concat(a2);\nconst a4 = [...a1, ...a2];\n\na3[0] === a1[0] // true\na4[0] === a1[0] // true\n```\n\n上面代码中，`a3`和`a4`是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。\n\n**（3）与解构赋值结合**\n\n扩展运算符可以与解构赋值结合起来，用于生成数组。\n\n```javascript\n// ES5\na = list[0], rest = list.slice(1)\n// ES6\n[a, ...rest] = list\n```\n\n下面是另外一些例子。\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\n```javascript\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n```\n\n**（4）字符串**\n\n扩展运算符还可以将字符串转为真正的数组。\n\n```javascript\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n```\n\n上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。\n\n```javascript\n'x\\uD83D\\uDE80y'.length // 4\n[...'x\\uD83D\\uDE80y'].length // 3\n```\n\n上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。\n\n```javascript\nfunction length(str) {\n  return [...str].length;\n}\n\nlength('x\\uD83D\\uDE80y') // 3\n```\n\n凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。\n\n```javascript\nlet str = 'x\\uD83D\\uDE80y';\n\nstr.split('').reverse().join('')\n// 'y\\uDE80\\uD83Dx'\n\n[...str].reverse().join('')\n// 'y\\uD83D\\uDE80x'\n```\n\n上面代码中，如果不用扩展运算符，字符串的`reverse`操作就不正确。\n\n**（5）实现了 Iterator 接口的对象**\n\n任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。\n\n```javascript\nlet nodeList = document.querySelectorAll('div');\nlet array = [...nodeList];\n```\n\n上面代码中，`querySelectorAll`方法返回的是一个`NodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了 Iterator 。\n\n```javascript\nNumber.prototype[Symbol.iterator] = function*() {\n  let i = 0;\n  let num = this.valueOf();\n  while (i < num) {\n    yield i++;\n  }\n}\n\nconsole.log([...5]) // [0, 1, 2, 3, 4]\n```\n\n上面代码中，先定义了`Number`对象的遍历器接口，扩展运算符将`5`自动转成`Number`实例以后，就会调用这个接口，就会返回自定义的结果。\n\n对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\n\n```javascript\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n```\n\n上面代码中，`arrayLike`是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用`Array.from`方法将`arrayLike`转为真正的数组。\n\n**（6）Map 和 Set 结构，Generator 函数**\n\n扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。\n\n```javascript\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n```\n\nGenerator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。\n\n```javascript\nconst go = function*(){\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...go()] // [1, 2, 3]\n```\n\n上面代码中，变量`go`是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。\n\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。\n\n```javascript\nconst obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n```\n\n#### 2.Array.from()\n\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。\n\n下面是一个类似数组的对象，`Array.from`将它转为真正的数组。\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。\n\n```javascript\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).filter(p => {\n  return p.textContent.length > 100;\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n```\n\n扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。\n\n#### 3.Array.of()\n\n`Array.of()`方法用于将一组值，转换为数组。\n\n```javascript\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n```\n\n这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。\n\n```javascript\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n```\n\n#### 4.实例方法：copyWithin()\n\n数组实例的`copyWithin()`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n```\n\n它接受三个参数。\n\n- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n#### 5.find()和findIndex()\n\n数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。\n\n```javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n```\n\n#### 6.实例方法：fill()\n\n`fill`方法使用给定值，填充一个数组。\n\n```javascript\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n```\n\n上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\n\n`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n```javascript\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n\n上面代码表示，`fill`方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。\n\n注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。\n\n```javascript\nlet arr = new Array(3).fill({name: \"Mike\"});\narr[0].name = \"Ben\";\narr\n// [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}]\n\nlet arr = new Array(3).fill([]);\narr[0].push(5);\narr\n// [[5], [5], [5]]\n```\n\n#### 7.entries() keys() values()\n\nES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。\n\n#### 8.includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。ES2016 引入了该方法。\n\n```javascript\n[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n```\n\n#### 9.实例方法：flat(),flatMap()\n\n数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。\n\n```javascript\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n```\n\n上面代码中，原数组的成员里面有一个数组，`flat()`方法将子数组的成员取出来，添加在原来的位置。\n\n`flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。\n\n```javascript\n[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n```\n\n上面代码中，`flat()`的参数为2，表示要“拉平”两层的嵌套数组。\n\n如果不管有多少层嵌套，都要转成一维数组，可以用`Infinity`关键字作为参数。\n\n```javascript\n[1, [2, [3]]].flat(Infinity)\n// [1, 2, 3]\n```\n\n如果原数组有空位，`flat()`方法会跳过空位。\n\n```javascript\n[1, 2, , 4, 5].flat()\n// [1, 2, 4, 5]\n```\n\n`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。\n\n```javascript\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n`flatMap()`只能展开一层数组。\n\n```javascript\n// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()\n[1, 2, 3, 4].flatMap(x => [[x * 2]])\n// [[2], [4], [6], [8]]\n```\n\n上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此`flatMap()`返回的还是一个嵌套数组。\n\n`flatMap()`方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。\n\n```javascript\narr.flatMap(function callback(currentValue[, index[, array]]) {\n  // ...\n}[, thisArg])\n```\n\n`flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this`。\n\n#### 10.数组的空位\n\n数组的空位指的是，数组的某一个位置没有任何值，比如`Array()`构造函数返回的数组都是空位。\n\n```javascript\nArray(3) // [, , ,]\n```\n\n上面代码中，`Array(3)`返回一个具有 3 个空位的数组。\n\n注意，空位不是`undefined`，某一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。\n\n```javascript\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n```\n\n### 对象的扩展\n\n#### 1.属性的简洁表示法\n\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\n\n```javascript\nconst foo = 'bar';\nconst baz = {foo};\nbaz // {foo: \"bar\"}\n\n// 等同于\nconst baz = {foo: foo};\n```\n\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\n\n```javascript\nfunction f(x, y) {\n  return {x, y};\n}\n\n// 等同于\n\nfunction f(x, y) {\n  return {x: x, y: y};\n}\n\nf(1, 2) // Object {x: 1, y: 2}\n```\n\n除了属性简写，方法也可以简写。\n\n```javascript\nconst o = {\n  method() {\n    return \"Hello!\";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return \"Hello!\";\n  }\n};\n```\n\n#### 2.属性名表达式\n\nJavaScript 定义对象的属性，有两种方法。\n\n```javascript\n// 方法一\nobj.foo = true;\n\n// 方法二\nobj['a' + 'bc'] = 123;\n```\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串`[object Object]`，这一点要特别小心。\n\n```javascript\nconst keyA = {a: 1};\nconst keyB = {b: 2};\n\nconst myObject = {\n  [keyA]: 'valueA',\n  [keyB]: 'valueB'\n};\n\nmyObject // Object {[object Object]: \"valueB\"}\n```\n\n上面代码中，`[keyA]`和`[keyB]`得到的都是`[object Object]`，所以`[keyB]`会把`[keyA]`覆盖掉，而`myObject`最后只有一个`[object Object]`属性。\n\n#### 3.方法的name属性\n\n函数的`name`属性，返回函数名。对象方法也是函数，因此也有`name`属性。\n\n```javascript\nconst person = {\n  sayName() {\n    console.log('hello!');\n  },\n};\n\nperson.sayName.name   // \"sayName\"\n```\n\n#### 4.属性的可枚举性和遍历\n\n**可枚举性**\n\n对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。\n\n```javascript\nlet obj = { foo: 123 };\nObject.getOwnPropertyDescriptor(obj, 'foo')\n//  {\n//    value: 123,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n//  }\n```\n\n描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。\n\n目前，有四个操作会忽略`enumerable`为`false`的属性。\n\n- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。\n- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。\n- `JSON.stringify()`：只串行化对象自身的可枚举的属性。\n- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。\n\n**属性的遍历**\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n**（1）for...in**\n\n`for...in`循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。\n\n**（2）Object.keys(obj)**\n\n`Object.keys`返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。\n\n**（3）Object.getOwnPropertyNames(obj)**\n\n`Object.getOwnPropertyNames`返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。\n\n**（4）Object.getOwnPropertySymbols(obj)**\n\n`Object.getOwnPropertySymbols`返回一个数组，包含对象自身的所有 Symbol 属性的键名。\n\n**（5）Reflect.ownKeys(obj)**\n\n`Reflect.ownKeys`返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。\n\n以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。\n\n- 首先遍历所有数值键，按照数值升序排列。\n- 其次遍历所有字符串键，按照加入时间升序排列。\n- 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\n```javascript\nReflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })\n// ['2', '10', 'b', 'a', Symbol()]\n```\n\n#### 5.super关键字\n\n我们知道，`this`关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字`super`，指向当前对象的原型对象。\n\n```javascript\nconst proto = {\n  foo: 'hello'\n};\n\nconst obj = {\n  foo: 'world',\n  find() {\n    return super.foo;\n  }\n};\n\nObject.setPrototypeOf(obj, proto);\nobj.find() // \"hello\"\n```\n\n#### 对象的新增方法\n\n#### 1.Object.is()\n\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\n```javascript\nObject.is('foo', 'foo')\n// true\nObject.is({}, {})\n// false\n```\n\n不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身。\n\n```javascript\n+0 === -0 //true\nNaN === NaN // false\n\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n```\n\nES5 可以通过下面的代码，部署`Object.is`。\n\n```javascript\nObject.defineProperty(Object, 'is', {\n  value: function(x, y) {\n    if (x === y) {\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    }\n    // 针对NaN的情况\n    return x !== x && y !== y;\n  },\n  configurable: true,\n  enumerable: false,\n  writable: true\n});\n```\n\n#### 2.Object.assign()\n\n`Object.assign()`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\n```javascript\nconst target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n`Object.assign()`方法的第一个参数是目标对象，后面的参数都是源对象。\n\n注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\n```javascript\nconst target = { a: 1, b: 1 };\n\nconst source1 = { b: 2, c: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n\n如果只有一个参数，`Object.assign()`会直接返回该参数。\n\n```javascript\nconst obj = {a: 1};\nObject.assign(obj) === obj // true\n```\n\n如果该参数不是对象，则会先转成对象，然后返回。\n\n```javascript\ntypeof Object.assign(2) // \"object\"\n```\n\n由于`undefined`和`null`无法转成对象，所以如果它们作为参数，就会报错。\n\n```javascript\nObject.assign(undefined) // 报错\nObject.assign(null) // 报错\n```\n\n如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果`undefined`和`null`不在首参数，就不会报错。\n\n```javascript\nlet obj = {a: 1};\nObject.assign(obj, undefined) === obj // true\nObject.assign(obj, null) === obj // true\n```\n\n其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\n\n```javascript\nconst v1 = 'abc';\nconst v2 = true;\nconst v3 = 10;\n\nconst obj = Object.assign({}, v1, v2, v3);\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n```\n\n上面代码中，`v1`、`v2`、`v3`分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。\n\n#### 常见用途\n\n**为对象添加属性**\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    Object.assign(this, {x, y});\n  }\n}\n```\n\n**为对象添加方法**\n\n```javascript\nObject.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    ···\n  },\n  anotherMethod() {\n    ···\n  }\n});\n\n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) {\n  ···\n};\nSomeClass.prototype.anotherMethod = function () {\n  ···\n};\n```\n\n**克隆对象**\n\n```javascript\nfunction clone(origin) {\n  return Object.assign({}, origin);\n}\n```\n\n**合并多个对象**\n\n将多个对象合并到某个对象。\n\n```javascript\nconst merge =\n  (target, ...sources) => Object.assign(target, ...sources);\n```\n\n如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。\n\n```javascript\nconst merge =\n  (...sources) => Object.assign({}, ...sources);\n```\n\n#### 3.Object.getOwnPropertyDescriptors()\n\nES5 的`Object.getOwnPropertyDescriptor()`方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了`Object.getOwnPropertyDescriptors()`方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n\n```javascript\nconst obj = {\n  foo: 123,\n  get bar() { return 'abc' }\n};\n\nObject.getOwnPropertyDescriptors(obj)\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [Function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }\n```\n\n#### 4.__proto__\n\n**Object.setPrototypeOf()**\n\n`Object.setPrototypeOf`方法的作用与`__proto__`相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。\n\n```javascript\n// 格式\nObject.setPrototypeOf(object, prototype)\n\n// 用法\nconst o = Object.setPrototypeOf({}, null);\n```\n\n该方法等同于下面的函数。\n\n```javascript\nfunction setPrototypeOf(obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n```\n\n下面是一个例子。\n\n```javascript\nlet proto = {};\nlet obj = { x: 10 };\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nobj.x // 10\nobj.y // 20\nobj.z // 40\n```\n\n### 运算符的扩展\n\n#### 1.指数运算符\n\nES2016 新增了一个指数运算符（`**`）。\n\n```javascript\n2 ** 2 // 4\n2 ** 3 // 8\n```\n\n这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。\n\n```javascript\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n```\n\n#### 2.链判断运算符\n\n```javascript\nconst firstName = message?.body?.user?.firstName || 'default';\nconst fooValue = myForm.querySelector('input[name=foo]')?.value\n```\n\n#### 3Null判断运算符\n\n这个运算符的一个目的，就是跟链判断运算符`?.`配合使用，为`null`或`undefined`的值设置默认值。\n\n```javascript\nconst animationDuration = response.settings?.animationDuration ?? 300;\n```\n\n上面代码中，如果`response.settings`是`null`或`undefined`，或者`response.settings.animationDuration`是`null`或`undefined`，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。\n\n#### 4.逻辑赋值运算符\n\n```javascript\n// 或赋值运算符\nx ||= y\n// 等同于\nx || (x = y)\n\n// 与赋值运算符\nx &&= y\n// 等同于\nx && (x = y)\n\n// Null 赋值运算符\nx ??= y\n// 等同于\nx ?? (x = y)\n```\n\n这三个运算符`||=`、`&&=`、`??=`相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。\n\n它们的一个用途是，为变量或属性设置默认值。\n\n### Symbol\n\n#### 1.概述\n\nSymbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n```javascript\nlet s = Symbol();\n\ntypeof s\n// \"symbol\"\n```\n\n#### 2.Symbol.prototype.description\n\n创建 Symbol 的时候，可以添加一个描述。\n\n```javascript\nconst sym = Symbol('foo');\n```\n\n上面代码中，`sym`的描述就是字符串`foo`。\n\n#### 3.作为属性名的Symbol\n\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n\n```javascript\nlet mySymbol = Symbol();\n\n// 第一种写法\nlet a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nlet a = {\n  [mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nlet a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n```\n\n上面代码通过方括号结构和`Object.defineProperty`，将对象的属性名指定为一个 Symbol 值。\n\n注意，Symbol 值作为对象属性名时，不能用点运算符。\n\n```javascript\nconst mySymbol = Symbol();\nconst a = {};\n\na.mySymbol = 'Hello!';\na[mySymbol] // undefined\na['mySymbol'] // \"Hello!\"\n```\n\n上面代码中，因为点运算符后面总是字符串，所以不会读取`mySymbol`作为标识名所指代的那个值，导致`a`的属性名实际上是一个字符串，而不是一个 Symbol 值。\n\n同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\n\n```javascript\nlet s = Symbol();\n\nlet obj = {\n  [s]: function (arg) { ... }\n};\n\nobj[s](123);\n```\n\n上面代码中，如果`s`不放在方括号中，该属性的键名就是字符串`s`，而不是`s`所代表的那个 Symbol 值。\n\n采用增强的对象写法，上面代码的`obj`对象可以写得更简洁一些。\n\n```javascript\nlet obj = {\n  [s](arg) { ... }\n};\n```\n\nSymbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。\n\n```javascript\nconst log = {};\n\nlog.levels = {\n  DEBUG: Symbol('debug'),\n  INFO: Symbol('info'),\n  WARN: Symbol('warn')\n};\nconsole.log(log.levels.DEBUG, 'debug message');\nconsole.log(log.levels.INFO, 'info message');\n```\n\n下面是另外一个例子。\n\n```javascript\nconst COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) {\n  switch (color) {\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error('Undefined color');\n    }\n}\n```\n\n常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的`switch`语句会按设计的方式工作。\n\n还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。\n\n#### 4.实例:消除魔术字符串\n\n魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。\n\n常用的消除魔术字符串的方法，就是把它写成一个变量。\n\n```javascript\nconst shapeType = {\n  triangle: 'Triangle'\n};\n\nfunction getArea(shape, options) {\n  let area = 0;\n  switch (shape) {\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  }\n  return area;\n}\n\ngetArea(shapeType.triangle, { width: 100, height: 100 });\n```\n\n#### 5.属性名的遍历\n\nSymbol 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。\n\n但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n\n```javascript\nconst obj = {};\nlet a = Symbol('a');\nlet b = Symbol('b');\n\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nconst objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjectSymbols\n// [Symbol(a), Symbol(b)]\n```\n\n上面代码是`Object.getOwnPropertySymbols()`方法的示例，可以获取所有 Symbol 属性名。\n\n#### 6Symbol.for() Symbol.keyFor()\n\n有时，我们希望重新使用同一个 Symbol 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n\n```javascript\nlet s1 = Symbol.for('foo');\nlet s2 = Symbol.for('foo');\n\ns1 === s2 // true\n```\n\n上面代码中，`s1`和`s2`都是 Symbol 值，但是它们都是由同样参数的`Symbol.for`方法生成的，所以实际上是同一个值。\n\n`Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。比如，如果你调用`Symbol.for(\"cat\")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol(\"cat\")`30 次，会返回 30 个不同的 Symbol 值。\n\n```javascript\nSymbol.for(\"bar\") === Symbol.for(\"bar\")\n// true\n\nSymbol(\"bar\") === Symbol(\"bar\")\n// false\n```\n\n上面代码中，由于`Symbol()`写法没有登记机制，所以每次调用都会返回一个不同的值。\n\n`Symbol.keyFor()`方法返回一个已登记的 Symbol 类型值的`key`。\n\n```javascript\nlet s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n\nlet s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n上面代码中，变量`s2`属于未登记的 Symbol 值，所以返回`undefined`。\n\n注意，`Symbol.for()`为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\n\n```javascript\nfunction foo() {\n  return Symbol.for('bar');\n}\n\nconst x = foo();\nconst y = Symbol.for('bar');\nconsole.log(x === y); // true\n```\n\n上面代码中，`Symbol.for('bar')`是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行`Symbol.for('bar')`可以取到这个 Symbol 值。\n\n`Symbol.for()`的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\n\n```javascript\niframe = document.createElement('iframe');\niframe.src = String(window.location);\ndocument.body.appendChild(iframe);\n\niframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')\n// true\n```\n\n上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。\n\n### Set和Map数据结构\n\n#### 1.set\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\n\n```javascript\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n```javascript\n// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll('div'));\nset.size // 56\n\n// 类似于\nconst set = new Set();\ndocument\n .querySelectorAll('div')\n .forEach(div => set.add(div));\nset.size // 56\n```\n\n向 Set 加入值的时候，不会发生类型转换，所以`5`和`\"5\"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。\n\n```javascript\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n```\n\n上面代码向 Set 实例添加了两次`NaN`，但是只会加入一个。这表明，在 Set 内部，两个`NaN`是相等的。\n\n另外，两个对象总是不相等的。\n\n```javascript\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n```\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n**Set实例的属性和方法**\n\nSet 结构的实例有以下属性。\n\n- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n- `Set.prototype.size`：返回`Set`实例的成员总数。\n\nSet 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n- `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身。\n- `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n- `Set.prototype.clear()`：清除所有成员，没有返回值。\n\n上面这些属性和方法的实例如下。\n\n```javascript\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n**遍历操作**\n\nSet 结构的实例有四个遍历方法，可以用于遍历成员。\n\n- `Set.prototype.keys()`：返回键名的遍历器\n- `Set.prototype.values()`：返回键值的遍历器\n- `Set.prototype.entries()`：返回键值对的遍历器\n- `Set.prototype.forEach()`：使用回调函数遍历每个成员\n\n需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\n而且，数组的`map`和`filter`方法也可以间接用于 Set 了。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n```\n\n因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。\n\n```javascript\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n```\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。回调函数列表，调用时就能保证按照添加顺序调用。\n\n#### 2.WeakSet\n\n**含义**\n\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n\n首先，WeakSet 的成员只能是对象，而不能是其他类型的值。\n\n```javascript\nconst ws = new WeakSet();\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\n```\n\n#### 3.Map\n\n**含义**\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n```javascript\nconst data = {};\nconst element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n```\n\n上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。\n\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n```javascript\nconst m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。\n\n上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n**遍历方法**\n\nMap 结构原生提供三个遍历器生成函数和一个遍历方法。\n\n- `Map.prototype.keys()`：返回键名的遍历器。\n- `Map.prototype.values()`：返回键值的遍历器。\n- `Map.prototype.entries()`：返回所有成员的遍历器。\n- `Map.prototype.forEach()`：遍历 Map 的所有成员。\n\n需要特别注意的是，Map 的遍历顺序就是插入顺序。\n\n#### 与其他数据的相互转化\n\n**（1）Map 转为数组**\n\n前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。\n\n```javascript\nconst myMap = new Map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n**（2）数组 转为 Map**\n\n将数组传入 Map 构造函数，就可以转为 Map。\n\n```javascript\nnew Map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n```\n\n**（3）Map 转为对象**\n\n如果所有 Map 的键都是字符串，它可以无损地转为对象。\n\n```javascript\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n```\n\n如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n\n**（4）对象转为 Map**\n\n对象转为 Map 可以通过`Object.entries()`。\n\n```javascript\nlet obj = {\"a\":1, \"b\":2};\nlet map = new Map(Object.entries(obj));\n```\n\n此外，也可以自己实现一个转换函数。\n\n```javascript\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// Map {\"yes\" => true, \"no\" => false}\n```\n\n**（5）Map 转为 JSON**\n\nMap 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。\n\n```javascript\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n```\n\n另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。\n\n```javascript\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n```\n\n**（6）JSON 转为 Map**\n\nJSON 转为 Map，正常情况下，所有键名都是字符串。\n\n```javascript\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n```\n\n但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n\n```javascript\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```\n\n### Proxy\n\n#### 1.概述\n\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n```javascript\nvar obj = new Proxy({}, {\n  get: function (target, propKey, receiver) {\n    console.log(`getting ${propKey}!`);\n    return Reflect.get(target, propKey, receiver);\n  },\n  set: function (target, propKey, value, receiver) {\n    console.log(`setting ${propKey}!`);\n    return Reflect.set(target, propKey, value, receiver);\n  }\n});\n```\n\n上面代码对一个空对象架设了一层拦截，重定义了属性的读取（`get`）和设置（`set`）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象`obj`，去读写它的属性，就会得到下面的结果。\n\n```javascript\nobj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n```\n\n上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。\n\n同一个拦截器函数，可以设置拦截多个操作。\n\n```javascript\nvar handler = {\n  get: function(target, name) {\n    if (name === 'prototype') {\n      return Object.prototype;\n    }\n    return 'Hello, ' + name;\n  },\n\n  apply: function(target, thisBinding, args) {\n    return args[0];\n  },\n\n  construct: function(target, args) {\n    return {value: args[1]};\n  }\n};\n\nvar fproxy = new Proxy(function(x, y) {\n  return x + y;\n}, handler);\n\nfproxy(1, 2) // 1\nnew fproxy(1, 2) // {value: 2}\nfproxy.prototype === Object.prototype // true\nfproxy.foo === \"Hello, foo\" // true\n```\n\n对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。\n\n下面是 Proxy 支持的拦截操作一览，一共 13 种。\n\n- **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。\n- **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。\n- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。\n- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。\n- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。\n- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。\n- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。\n- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。\n- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。\n- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。\n- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。\n- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。\n- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。\n\n####  2.Proxy.revocable()\n\n`Proxy.revocable()`方法返回一个可取消的 Proxy 实例。\n\n```javascript\nlet target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n```\n\n#### 3.this问题\n\n虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的`this`关键字会指向 Proxy 代理。\n\n```javascript\nconst target = {\n  m: function () {\n    console.log(this === proxy);\n  }\n};\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true\n```\n\n### Reflect\n\n#### 1.概述\n\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\n\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\n\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。\n\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n（3） 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。\n\n```javascript\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n\n（4）`Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。\n\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n\n上面代码中，`Proxy`方法拦截`target`对象的属性赋值行为。它采用`Reflect.set`方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。\n\n下面是另一个例子。\n\n```javascript\nvar loggedObj = new Proxy(obj, {\n  get(target, name) {\n    console.log('get', target, name);\n    return Reflect.get(target, name);\n  },\n  deleteProperty(target, name) {\n    console.log('delete' + name);\n    return Reflect.deleteProperty(target, name);\n  },\n  has(target, name) {\n    console.log('has' + name);\n    return Reflect.has(target, name);\n  }\n});\n```\n\n上面代码中，每一个`Proxy`对象的拦截操作（`get`、`delete`、`has`），内部都调用对应的`Reflect`方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。\n\n有了`Reflect`对象以后，很多操作会更易读。\n\n```javascript\n// 老写法\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\n\n// 新写法\nReflect.apply(Math.floor, undefined, [1.75]) // 1\n```\n\n#### 2.静态方法\n\n`Reflect`对象一共有 13 个静态方法。\n\n- Reflect.apply(target, thisArg, args)\n- Reflect.construct(target, args)\n- Reflect.get(target, name, receiver)\n- Reflect.set(target, name, value, receiver)\n- Reflect.defineProperty(target, name, desc)\n- Reflect.deleteProperty(target, name)\n- Reflect.has(target, name)\n- Reflect.ownKeys(target)\n- Reflect.isExtensible(target)\n- Reflect.preventExtensions(target)\n- Reflect.getOwnPropertyDescriptor(target, name)\n- Reflect.getPrototypeOf(target)\n- Reflect.setPrototypeOf(target, prototype)\n\n上面这些方法的作用，大部分与`Object`对象的同名方法的作用都是相同的，而且它与`Proxy`对象的方法是一一对应的。下面是对它们的解释。\n\n### Promise对象\n\n#### 1.Promise的含义\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\n\n`Promise`对象有以下两个特点\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n#### 2.基本用法\n\nES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`p1`和`p2`都是 Promise 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。\n\n注意，这时`p1`的状态就会传递给`p2`，也就是说，`p1`的状态决定了`p2`的状态。如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变；如果`p1`的状态已经是`resolved`或者`rejected`，那么`p2`的回调函数将会立刻执行。\n\n```javascript\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\n\n上面代码中，`p1`是一个 Promise，3 秒之后变为`rejected`。`p2`的状态在 1 秒之后改变，`resolve`方法返回的是`p1`。由于`p2`返回的是另一个 Promise，导致`p2`自己的状态无效了，由`p1`的状态决定`p2`的状态。所以，后面的`then`语句都变成针对后者（`p1`）。又过了 2 秒，`p1`变为`rejected`，导致触发`catch`方法指定的回调函数。\n\n注意，调用`resolve`或`reject`并不会终结 Promise 的参数函数的执行。\n\n#### 3.Promise.prototype.then()\n\nPromise 实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函数，它们都是可选的。\n\n`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。\n\n#### 4.Promise.prototype.catch()\n\n`Promise.prototype.catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。\n\n```javascript\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n#### 5.Promise.prototype.finally()\n\n`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\n```javascript\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n```\n\n上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。\n\n下面是一个例子，服务器使用 Promise 处理请求，然后使用`finally`方法关掉服务器。\n\n```javascript\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n```\n\n#### 6.Promise.all()\n\n`Promise.all()`方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n\n```javascript\nconst p = Promise.all([p1, p2, p3]);\n```\n\n上面代码中，`Promise.all()`方法接受一个数组作为参数，`p1`、`p2`、`p3`都是 Promise 实例，如果不是，就会先调用下面讲到的`Promise.resolve`方法，将参数转为 Promise 实例，再进一步处理。另外，`Promise.all()`方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。\n\n`p`的状态由`p1`、`p2`、`p3`决定，分成两种情况。\n\n（1）只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。\n\n（2）只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。\n\n#### 7.Promise.race()\n\n`Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n\n```javascript\nconst p = Promise.race([p1, p2, p3]);\n```\n\n上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数。\n\n`Promise.race()`方法的参数与`Promise.all()`方法一样，如果不是 Promise 实例，就会先调用下面讲到的`Promise.resolve()`方法，将参数转为 Promise 实例，再进一步处理。\n\n#### 8.Promise.allSettled()\n\n有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。\n\n`Promise.allSettled()`方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是`fulfilled`还是`rejected`），返回的 Promise 对象才会发生状态变更。\n\n#### 9.Promise.any()\n\nES2021 引入了`Promise.any()`方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。\n\n只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。\n\n`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是`Promise.any()`不会因为某个 Promise 变成`rejected`状态而结束，必须等到所有参数 Promise 变成`rejected`状态才会结束。\n\n#### 10.Promise.resole()\n\n有时需要将现有对象转为 Promise 对象，`Promise.resolve()`方法就起到这个作用\n\n#### 11.Promise.reject()\n\n`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。\n\n```javascript\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n#### 12.应用\n\n**图片加载**\n\n我们可以将图片的加载写成一个`Promise`，一旦加载完成，`Promise`的状态就发生变化。\n\n```javascript\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n```\n\n**Generator函数Promise的结合**\n\n```javascript\nfunction getFoo () {\n  return new Promise(function (resolve, reject){\n    resolve('foo');\n  });\n}\n\nconst g = function* () {\n  try {\n    const foo = yield getFoo();\n    console.log(foo);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nfunction run (generator) {\n  const it = generator();\n\n  function go(result) {\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) {\n      return go(it.next(value));\n    }, function (error) {\n      return go(it.throw(error));\n    });\n  }\n\n  go(it.next());\n}\n\nrun(g);\n```\n\n#### 13.Promise.try()\n","categories":["-ES6"],"tags":["小结"]},{"title":"antd 中 Table 的 dataSource 不更新？？","url":"/posts/34168/","content":"\n答应我，别再修改对象属性的时候不深拷贝原对象了！\n\n![](/gallery/bg-001.jpeg)\n\n<!-- more -->\n\n# 背景\n\n   前几天在快乐的使用antd组件时，做了一个选择权限的表格，表格的结构是树形的，单元格中有select框，选择是否有权限，写完了，啪，出问题了。\n\n![](/gallery/antd-table-error-01.gif)\n\n# 分析\n\n   在图中可以看出问题来，当选择的权限后，表格组件没有重新渲染\n\n![](/gallery/problem.jpeg)\n\n在代码中也调用了this.setState去重新渲染页面\n\n![](/gallery/antd-table-error-02.png)\n\n**是我写的修改权限树的算法耗费太多时间了吗？**\n\n在调用函数之前写上 console.time('aaa')\n\n在调用函数之后写上console.timeEnd('aaa')\n\n![](/gallery/antd-table-error-03.png)\n\n从图中，我们基本上可以确定问题了，修改权限树的函数调用的时间是0.17ms,肯定不是算法的问题，我们选择了select框，但是控制台上没有打印render，可以证明没有调用table的渲染。\n\n**为什么Table没有重新渲染呢？**\n\n冷静的再看下代码，猛的发现，我好像是直接修改了原对象的引用指向的内存数据，没有修改引用，`React`认为虚拟`DOM`并没有改变，因此，不会重新渲染页面，这就会照成Table组件的dataSource改变了，但是Table并没有重新渲染。\n\n# 解决\n\n  既然问题出在对象的引用没有改变，那么我们让他改变就行了，我只需要对原对象进行拷贝就行了，这时候就要请出我们的深拷贝了，先来手写一个深拷贝函数。\n\n```js\ndeepCopy = (obj) => {\n    if (!obj || typeof obj != 'object') return;\n    // 判断对象是不是数组\n    let newObj = Array.isArray(obj) ? [] : {};\n    for (let key in obj) {\n        // 防止拷贝对象原型链上的属性 hasOwnProperty,不会判断原型链上的属性\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] == 'object' ? deppCopy(obj[key]) : obj[key]\n        }\n    }\n    return newObj;\n}\n```\n\n看看改进的效果\n\n![](/gallery/antd-table-error-04.gif)\n\n![](/gallery/good.jpg)\n\n# 总结\n\n答应我，别再修改对象属性的时候不深拷贝原对象了！\n","categories":["深拷贝"],"tags":["antd, 深拷贝"]},{"title":"第一周学习总结","url":"/posts/4870/","content":"\n\n\n<!-- more -->\n\n# promise\n\n## 手写promise\n\n**es5版（简化版）**\n\n```js\nconst pending = 'pending';\nconst fulfilled = 'fulfilled';\nconst reject = 'reject';\nfunction MyPromise (fn) {\n    // 保存this\n    var self = this;\n    // 保存初始化状态\n    self.state = pending;\n    // 初始化value resolve\n    self.value = null;\n    // 初始化reason reject\n    self.reason = null;\n    // 保存resolve的回调函数\n    self.resolvedCallbacks = [];\n    // 保存reject的回调函数\n    self.rejectedCallbacks = [];\n    // resolve 方法\n    function resolve (value) {\n       // 判断传入的元素是否为promise值，如果是，则状态改变必须等前一个状态改变后再进行改变\n        if (value instanceof MyPromise) {\n            return value.then(resolve, reject);\n        }\n        // 保证代码的执行顺序为本轮时间循环的末尾\n        setTimeout(() => {\n            if (self.state === pending) {\n                // 改变状态\n                self.state = fulfilled;\n                // 传入值\n                self.value = value;\n                // 执行回调函数\n                self.resolvedCallbacks.forEach( callback => callback (value));\n                \n            }\n        })\n    }\n    \n}\n```\n\n","categories":["小结"],"tags":["promise","浏览器的缓存机制","浏览器安全","http","工具函数","设计模式"]},{"title":"2021 年终总结","url":"/posts/8569/","content":"\n![](/gallery/2021.jpeg)\n\n<!-- more -->\n\n2021年已经过去了，2022年已经开始了，今年我就要毕业了。18年刚踏入大学的校园时感觉大学的生活是多么的精彩啊！回首2021，最大的遗憾还是在校招上吧，没有能进到自己梦想中的公司。\n\n**春招**\n\n当时准备了，但是没有投，想着再多学一点再投吧，时间不等人啊。不去尝试的话就不知道结果，当时我有几个朋友他们找到了实习，感觉挺后悔的，在实践中学习是最快的。\n\n**秋招**\n\n秋招也是吃了投的晚的亏，9月20多号才开始投简历（主要是开学了，还要进行两周的实习，耽误了时间），\n\n最后大公司没面上，只oc了几个小公司，结束了自己的秋招。\n\n现在，只要一有空就会用来学习。\n\n早上9点上班，下午6点下班，然后回家做饭，差不多1个半小时后回公司继续学习，晚上10点半走。先刷算法题，再看技术文档，边学边实践。\n\n**最后**\n\n要明白勇于尝试的道理，也要踏实的学习，多总结，希望在2022年能升职加薪！！\n","categories":[],"tags":[]},{"title":"初识 React","url":"/posts/53413/","content":"\n\n\n<!-- more -->\n\n### 使用react脚手架创建react工程\n\n```\nnpm i create-react-app -g       //安装脚手架\ncreate-react-app hello-react    //创建项目\n```\n\n","categories":[],"tags":[]},{"title":"vue3 实现 todolist","url":"/posts/8383/","content":"\n![](/gallery/vue3-todolist-index.jpg)\n\n<!-- more -->\n\n今天来做一个Vue3的小demo，UI框架使用Vant。\n\n## 准备工作\n\n### 安装依赖\n\n```js\nvue create vue3-todolist    //使用vue-cil创建vue3工程\nyarn add vant@next -S       //安装vant\nyarn add vue-router@4       //安装路由\nyarn add vuex@next          //安装 vuex\n```\n\n### 创建文件\n\n- 在src中创建store、router文件夹，分别在文件夹中创建index.js\n\n![](/gallery/vue3-todolist-createpackage.jpg)\n\n- 在main.js中引用\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport Router from './router'\nimport Vuex from './store'\nimport Vant from 'vant';\nimport 'vant/lib/index.css';\nconst app = createApp(App);\n\napp.use(Router).use(Vuex).use(Vant).mount('#app');\n\n```\n\n## 编写代码\n\n### 登录页面\n\n先在src中创建page文件夹，再在login文件下创建login.vue文件\n\n","categories":["vue3"],"tags":["todolist"]},{"title":"闲谈 webpack","url":"/posts/7780/","content":"\n![](/gallery/webpack-img.jpeg)\n\n<!-- more -->\n\n# webpack\n\nWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。\n中文官方网站：https://www.webpackjs.com/\n\n**打包的好处**：\n\n- 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。\n- 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。\n- 将代码打包的同时进行混淆，提高代码的安全性。\n\n1、安装\nwebpack支持全局安装和本地安装，官方推荐是本地安装\n输入命令：npm install webpack --save-dev\nwebpack 4+ 版本，还需要安装 CLI ，输入命令：npm install webpack webpack-cli --save-dev\n2、核心概念\n学习Webpack，需要先理解四个核心概念：\n\n入口(entry)\nwebpack打包的起点，可以有一个或多个，一般是js文件。webpack会从起点文件开始，寻找起点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据\n输出(output)\n出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。\n加载器（loader）\nwebpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。\n插件(plugins)\n插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。\n","categories":["资源构建工具"],"tags":["webpack"]},{"title":"CSS 常见的布局","url":"/posts/3613/","content":"\n![](/gallery/css-layout.jpg)\n\n几种常见的布局\n\n<!-- more -->\n\n## 单列布局\n\n![](/gallery/layout-one-way.jpg)\n\n常见的单列布局有两种：\n\n- header,content和footer等宽的单列布局\n- header与footer等宽,content略窄的单列布局\n\n先通过对header,content,footer统一设置width：1000px;或者max-width：1000px(这两者的区别是当屏幕小于1000px时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置margin:auto实现居中即可得到。text-align:center 文字水平居中，line-height:高度文字垂直居中。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>一栏布局</title>\n    <style>\n        .header {\n            margin: 20px auto;\n            max-width: 960px;\n            height: 100px;\n            text-align: center;\n            line-height: 100px;\n            background-color: red;\n        }\n        .content {\n            margin: 20px auto;\n            max-width: 960px;\n            height: 100px;\n            text-align: center;\n            line-height: 100px;\n            background-color: blue;\n        }\n        .footer {\n            margin: 20px auto;\n            max-width: 960px;\n            height: 100px;\n            text-align: center;\n            line-height: 100px;\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"header\">头部</div>\n    <div class=\"content\">内容</div>\n    <div class=\"footer\">尾部</div>\n</body>\n</html>\n\n```\n\n![](/gallery/layout-one.jpg)\n\n**上下固定，中间自适应的单列布局**\n\n- flex\n\n父元素设置flex布局，flex-direction:column,上下固定高度，中间flex设为1即可\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>中间自适应的上中下布局</title>\n    <style>\n      .box {\n        display: flex;\n        flex-direction: column;\n        height: 100vh;\n        width: 400px;\n        margin: 0 auto;\n      }\n      .main {\n        flex: 1;\n        background-color: red;\n      }\n      .header {\n        height: 100px;\n        background-color: yellow;\n      }\n      .footer {\n        height: 100px;\n        background-color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\">\n      <div class=\"header\"></div>\n      <div class=\"main\"></div>\n      <div class=\"footer\"></div>\n    </div>\n  </body>\n</html>\n\n```\n\n- float+calc\n\n给元素设置float，固定宽度，元素会纵向排布，上下固定高度，中间元素利用calc计算出高度\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>浮动单列布局</title>\n    <style>\n      .box {\n        height: 100vh;\n        width: 400px;\n        margin: 0 auto;\n      }\n      .header, .main, .footer {\n        float: left;\n        width: 400px;\n      }\n      .main {\n        background-color: red;\n        height: calc(100vh - 200px);\n      }\n      .header {\n        height: 100px;\n        background-color: yellow;\n      }\n      .footer {\n        height: 100px;\n        background-color: green;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\">\n      <div class=\"header\"></div>\n      <div class=\"main\"></div>\n      <div class=\"footer\"></div>\n    </div>\n  </body>\n</html>\n\n```\n\ngird\n\n父元素设置display:grid,grid-template:rows:100px 1fr 100px;\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>grid布局</title>\n  <style>\n     .box {\n        display: grid;\n        height: 100vh;\n        width: 400px;\n        margin: 0 auto;\n        grid-template-rows: 100px 1fr 100px;\n      }\n      .main {\n        background-color: red;\n      }\n      .header {\n      \n        background-color: yellow;\n      }\n      .footer {\n      \n        background-color: green;\n      }\n  </style>\n</head>\n<body>\n  <div class=\"box\">\n    <div class=\"header\"></div>\n    <div class=\"main\"></div>\n    <div class=\"footer\"></div>\n  </div>\n</body>\n</html>\n```\n\n\n\n## 两列自适应布局\n\n### 1.float+overflow:hidden\n\n如果是普通的两列布局，**浮动+普通元素的margin**便可以实现，但如果是自适应的两列布局，利用**float+overflow:hidden**便可以实现，这种办法主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下\n\n```html\n<div class=\"parent\" style=\"background-color: lightgrey;\">\n    <div class=\"left\" style=\"background-color: lightblue;\">\n        <p>left</p>\n    </div>\n    <div class=\"right\"  style=\"background-color: lightgreen;\">\n        <p>right</p>\n        <p>right</p>\n    </div>        \n</div>\n```\n\n```html\n.parent {\n  overflow: hidden;\n  zoom: 1;\n}\n.left {\n  float: left;\n  margin-right: 20px;\n}\n.right {\n  overflow: hidden;\n  zoom: 1;\n}\n```\n\n## 三栏布局\n\n**特征：中间列自适应宽度，旁边两侧固定宽度**\n\n### 圣杯布局\n\n圣杯布局特点\n（1）父元素包含三个元素，分别设置他们左浮动\n（2）中间的盒子宽度设置为100%，自适应，并且在三个元素的最前面显示，第一个渲染\n（3）左右两边使用margin-left的负值，使他们与中间的盒子同行，（左边：-100%，右边：-右边盒子的宽度）\n（4）中间的盒子width:100%后，需要父元素通过padding设置左右两边空白，为左右两边的盒子留同等大小的空间\n（5）设置左右两边position:relative,通过left移动位置\n\n**比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载**。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>圣杯布局-float</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      .container {\n        padding: 0 100px;\n        overflow: hidden;\n      }\n      .middle {\n        background: paleturquoise;\n        float: left;\n        width: 100%;\n      }\n      .left {\n        background: palevioletred;\n        float: left;\n        width: 100px;\n        margin-left: -100%;\n        position: relative;\n        left: -100px;\n      }\n      .right {\n        background: purple;\n        float: left;\n        width: 100px;\n        margin-left: -100px;\n        position: relative;\n        left: 100px\n      }\n      header,\n      footer {\n        width: 100%;\n        height: 50px;\n        line-height: 50px;\n        text-align: center;\n        border: 1px solid deeppink;\n        background: pink;\n      }\n    </style>\n  </head>\n  <body>\n    <header>上</header>\n    <div class=\"container\">\n      <div class=\"middle\">中</div>\n      <div class=\"left\">左</div>\n      <div class=\"right\">右</div>\n    </div>\n    <footer>下</footer>\n  </body>\n</html>\n\n```\n\n![](/gallery/css-shengbei.png)\n\n### 双飞翼布局\n\n**同（1）（2）（3）同上\n  （4）给中间元素设置子元素，并给其设置其margin-left 和 margin-right值，为左右盒子留位置**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>圣杯布局-float</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      .container {\n        overflow: hidden;\n      }\n      .middle {\n        background: paleturquoise;\n        float: left;\n        width: 100%;\n      }\n      .middle div {\n          margin: 0 100px;\n      }\n\n      .left {\n        background: palevioletred;\n        float: left;\n        width: 100px;\n        margin-left: -100%;\n      }\n      .right {\n        background: purple;\n        float: left;\n        width: 100px;\n        margin-left: -100px;\n      \n      }\n      header,\n      footer {\n        width: 100%;\n        height: 50px;\n        line-height: 50px;\n        text-align: center;\n        border: 1px solid deeppink;\n        background: pink;\n      }\n    </style>\n  </head>\n  <body>\n    <header>上</header>\n    <div class=\"container\">\n      <div class=\"middle\">\n          <div>中</div>\n      </div>\n      <div class=\"left\">左</div>\n      <div class=\"right\">右</div>\n    </div>\n    <footer>下</footer>\n  </body>\n</html>\n\n```\n\n![](/gallery/css-shuangfeiyi.png)\n\n### flex\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      header,\n      footer {\n        width: 100%;\n        height: 50px;\n        line-height: 50px;\n        text-align: center;\n        border: 1px solid deeppink;\n        background: pink;\n      }\n      .container {\n        display: flex;\n      }\n      .middle {\n        background: paleturquoise;\n        width: 100%;\n        flex: 1;\n      }\n      .middle div {\n        margin: 0 100px;\n      }\n\n      .left {\n        background: palevioletred;\n        width: 100px;\n      }\n      .right {\n        background: purple;\n\n        width: 100px;\n      }\n    </style>\n  </head>\n  <body>\n    <header>上</header>\n    <div class=\"container\">\n      <div class=\"left\">左</div>\n      <div class=\"middle\">\n        <div>中</div>\n      </div>\n      <div class=\"right\">右</div>\n    </div>\n    <footer>下</footer>\n  </body>\n</html>\n\n```\n\n### grid\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      header,\n      footer {\n        width: 100%;\n        height: 50px;\n        line-height: 50px;\n        text-align: center;\n        border: 1px solid deeppink;\n        background: pink;\n      }\n      .container {\n        display: grid;\n        grid-template-columns: 100px 1fr 100px;\n      }\n      .middle {\n        background: paleturquoise;\n      }\n      .middle div {\n        margin: 0 100px;\n      }\n\n      .left {\n        background: palevioletred;\n\n      }\n      .right {\n        background: purple;\n\n\n      }\n    </style>\n  </head>\n  <body>\n    <header>上</header>\n    <div class=\"container\">\n      <div class=\"left\">左</div>\n      <div class=\"middle\">\n        <div>中</div>\n      </div>\n      <div class=\"right\">右</div>\n    </div>\n    <footer>下</footer>\n  </body>\n</html>\n\n```\n\n","categories":[],"tags":[]},{"title":"axios 封装及处理","url":"/posts/47662/","content":"\n![](/gallery/axios.jpg)\n\n<!-- more -->\n\n# axios封装以处理\n\n### 接口封装必要性\n\n在大型前端项目中，当有很多接口实现数据输入、流出并附加拦截，结合状态管理，抵御XSRF攻击等时，统一管理API接口就成为大型前端项目必须面对的环节。axios作为最流行的基于Promise的HTTP库可以同时运行在浏览器端和服务器端，已经成为大部分前端项目的首选。\n\n### POST序列化\n\n通过`JSON.stringify`我们同样可以实现序列化,但是对于复杂`ObjectJSON.stringify`的支持行不如`qs.stringify`。所以通过引入qs这个库，qs可以帮我们对深层嵌套的JSON以及Array形式进行序列化，让我们的API封装兼容更多的场景。\n\n```js\nvar a = {name:'hehe',age:10};\n qs.stringify(a)\n// 'name=hehe&age=10'\nJSON.stringify(a)\n// '{\"name\":\"hehe\",\"age\":10}'\n```\n\n例外：现在后台工程大多可以在body里面获取json，array等，某些情况下，可能后台是直接读取的字符串信息，这种情况下，qs.stringify封装参数中的JSON以及Array格式无法获取，需要使用`JSON.stringify`去处理\n\n### axios 对于配置的处理\n\n在正式进行axios二次封装之前，简单了解一下axios对于配置项的处理；可以从axios暴露出来的方法了解，可以在axios.defaults上配置config，也可以在拦截器上以及新的instance config上去配置；通过阅读源码，发现其实axios的config配置是通过merge方法去实现的：\n\n```js\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n```\n\naxios default以及新的instance的config之外，也提供了初始化的默认config；\n\n```js\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n```\n\naxios的config是这样一个逻辑：\n\n1.默认的初始化config与defaultconfig进行merge\n\n2.将第一步得到的结果和新instance上的config进行merge\n\n通过分析，我们可以直接将请求的接口进行配置化处理，更方便的一步化适应各种场景\n\n#### default config\n\naxios给我提供了一个default系列的属性，可以直接向`axios.default`的一些属性赋值，这个`axios.default`的赋值会作用给所用axios请求；官方文档给我提供了一些参考：比如设置默认的baseURL，为基于token的请求把token放到header的Authorization中，以及设置post的请求类型；\n\n```js\naxios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n#### 请求拦截以及响应拦截\n\n作为一个出色的http请求库，axios提供了强大请求拦截和响应拦截功能。\n\n##### 请求拦截\n\n```js\n//引入vuex\nimport store from '@/store'\n...\naxios.interceptors.request.use(config => {\n  //将token添加到了request的header里面\n  const token = store.state.token;\n  config.headers.common['Authorization'] = token\n  // loading\n  return config\n}, error => {\n  console.log(error)\n  return Promise.reject(error)\n})\n```\n\n通过拦截器可以实现请求的前置操作，例如，这里实现了比较常见的将token添加到header中。当然，在default中处理token也是可以的。所以网上大部分对拦截器的操作都是可以放到defaults中执行的，并没有什么区别；个人认为请求前拦截可以结合一些定时器已经前端监控相关插件的使用。\n\n##### 响应拦截\n\n需要注意一下响应拦截的执行顺序，先执行`axios.interceptors.response.use`然后再执行正常的响应处理;\n\n```js\n// 响应拦截器\naxios.interceptors.response.use(    \n    response => {\n        // 这里的response返回的HTTP状态码为2XX的情况，可以在这里集中处理200+JSON形式中JSON中前后端约定的状态码\n    },   \n    //这里的error返回的是HTTP状态码不是2XX的情况，可以在这里处理不同HTTP的status\n    error => {            \n        if (error.response.status) {            \n            switch (error.response.status) {                \n                case 401:                    \n                //未登录的处理              \n                case 403:\n                //权限不足的处理                \n                    break; \n                case 404:\n              // 404请求不存在的处理\n                    break;\n                // 其他错误，直接抛出错误提示\n                default:\n                //默认处理\n            }\n            return Promise.reject(error.response);\n        }\n    }    \n});\n```\n\n### axios完全配置化\n\n通过上面对axios的具体config分析，我们可以通过增加merge结合封装方法来实现多种场景的配置；可以实现诸如，是否跨域携带cookie，是否附带loading，配置特殊接口的请求时常等待等\n\n可以创建一个config.js\n\n```js\nconst configMap = {\n  defaultConfig: {\n    withCredentials: false,\n    baseURL: path.baseUrl,\n    headers: {\n      post: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },\n    },\n  },\n  long: {\n    timeout: 60000,\n  },\n  nocookie: {\n    withCredentials: false,\n  },\n  ...\n```\n\n通过在httpjs中引入\n\n```js\nimport configMap from './config'\nimport { showFullScreenLoading, tryHideFullScreenLoading } from './loading'\nimport merge from 'lodash.merge'\n...\nmerge(axios.defaults, configMap['defaultConfig'])\nfunction handleTypeString(type) {\n  type.toLowerCase().split('-').map(item => merge(axios.defaults, configMap[item]))\n}\nexport default {\n  post(url, data, type) {\n    handleTypeString(type)\n    return axios({\n      method: 'post',\n```\n\n这样可以实现多个接口请求的配置组合，后面的会覆盖前面的，一个接一个，实现axios请求的完全配置化处理；\n\n在vue中使用\n\n```js\nimport http from \"@/api/http\";\nimport path from \"@/api/path\";\n//配合async await更加优雅\nasync test() {\n  const res = await http.post(path.test, params, \"long-nocookie\");\n```\n\n有些人比较喜欢使用偏函数的方式再包装一层，也可以再增加封装一层使调用时候直接使用。\n\n```js\ntest(param)\n```\n\n### 全局loading状态的处理\n\n封装loading.js来处理部分url请求接口需要loading菊花图的情况；需要设置needLoadingCount来记录处理多个需要loading请求接口处理的情况。\n\n```js\nimport { Loading } from 'element-ui';\nlet loading; \nfunction startLoading() { // 使用Element loading.tart 方法\n  loading = Loading.service({\n    lock: true,\n    text: 'loading……',\n    background: 'rgba(0, 0, 0, 0.5)',\n  });\n}\nfunction endLoading() { // 使用Element loading.close 方法\n  loading.close();\n}\n//通过needLoadingCount来记录，在多个地方使用loading时候处理\nlet needLoadingCount = 0;\nexport function showLoading() {\n  if (needLoadingCount === 0) {\n    startLoading();\n  }\n  needLoadingCount++;//eslint-disable-line\n}\nexport function tryHideLoading() {\n  if (needLoadingCount >= 0) needLoadingCount--;//eslint-disable-line\n  if (needLoadingCount === 0) {\n    endLoading();\n  }\n}\n```\n\n在http中配置\n\n```js\n    if (type === 'long') {\n      showFullScreenLoading()\n      return axios(config).then(response=>{\n         tryHideFullScreenLoading()\n         rerurn response;\n      })\n    }\n    //其他无loading的axios请求\n     return axios(config)\n```\n\n### 多种环境切换的封装\n\n在前后端分离的spa场景下，axios的baseUrl等各种环境参数是预先设定好的；然后打包成静态文件，上传到nginx或者tomcat类似的http服务器中，从本地开发到测试，提供静态文件给不同的后台去使用，可能不同后台设置的接口地址是不一样的，为了避免一个个的去打包，我们需要配置一个针对不同域名环境的封装；\n\n```js\nimport merge from 'lodash.merge'\nconst path = {\n  baseUrl: 'http://localhost:3000',\n  login: '/users/login',\n  test: '/test',\n};\nconst pathMap = {\n  'http://localhost:3001': { baseUrl: 'http://localhost:3001' },\n    'http://localhost:3002': { baseUrl: 'http://localhost:3002',login:'/login' },\n}\n\nconst getClientIdByLocation = () => {\n  const { href } = window.location;\n  const matchedKey = Object.keys(pathMap).filter(url => href.indexOf(url) > -1);\n  merge(path, pathMap[matchedKey])\n};\ngetClientIdByLocation();\nexport default path;\n```\n\n可以通过直接在pathMap中配置不同的url对应的path对象，来实现处理不同的url对应的baseUrl以及各种子路由情况不同时候的情况\n","categories":["网络请求"],"tags":["axios"]},{"title":"面试总结 10-14.md","url":"/posts/33370/","content":"\n 今天面试官问的是基础问题加场景题和项目问题\n\n<!-- more -->\n\n## 题目\n\n### 自我介绍\n\n### 项目问题\n\n- 前后端接口\n- axios的使用\n- GET、POST有什么区别\n\n应用场景：GET请求是幂等的(就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的),一般GET请求不会对服务器资源产生影响的场景，比如说请求一个网页的资源，而POST不是一个幂等的请求，一般用于对服务器资源会产生影响，比如说注册用户这一类的操作\n\n是否缓存：浏览器会对GET请求缓存，很少对POST请求缓存\n\n发送的报文格式：GET请求的报文中实体部分为空，POST请求的报文中的实体部分是向服务器请求的数据\n\n\n\n\n\n### 用js实现修改一个元素的颜色\n\n### 怎么使用flex布局实现垂直水平居中\n\n### 一个div下有8个div(没有类名和ID)，怎么使8个div的颜色变成红色\n\n### 对象怎么添加属性 \n\n### 两个数组怎么合并\n\n### 数组中常见的方法\n\n### 数组中slice的用法\n\n### 数组中的splice的用法\n\n### 块级元素有哪些\n\n### es6的新特性你用过哪些\n\n### promise的用法\n\n### 了解过storage吗\n\n### 文本超出内容该怎么隐藏\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>文本超出隐藏</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .container {\n            width: 100px;\n            height: 100px;\n            border:2px solid red;\n            overflow: hidden;\n        }\n\n    </style>\n</head>\n<body>\n  <div class=\"container\">\n      <p>我们是才华横溢的设计师， 也是勤勤恳恳的木匠，要能用上帝视角凌空俯视，也能回到现实操盘世界</p>\n  </div>\n</body>\n</html>\n```\n\n\n\n### 其他题目\n\n### [首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)\n\n设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。\n\n### 01串\n\n### res加密算法不是基于hash，md5、sha是基于hash.\n\n### Vue如何实现双向绑定的\n\n### proxy好在哪里\n\n### 聊一聊脏检查\n\n### js中判断数据类型的方法\n\n- typeof\n\ntypeof是一个操作符，其右侧跟着一个一元表达式，并返回这个表达式的数据类型，返回的结果是一个字符串。\n\n对于基本类型，除了null返回object外均有效。\n\n对于引用类型，除了function返回function外，一律范围object。\n\n其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。\n\n- instanceof\n\ninstanceof判断A是否为B的实例，表达式为A instanceof B，如果A是B的实例 ，则返回true，否则返回false。instanceof检查的是**原型**\n\n```js\ninstanceof (a, b) = {\n    val l = a.__proto__;\n    val r = b.__proto__;\n    if (l == r) {\n        return true;\n    }\n    return false;\n}\n```\n\n**instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。instanceof在不同的全局环境下无效**\n\n针对数组，es5中有Array.isArray()的方式，本质上是检测对象的[[class]],[[class]]包含了对象的类型信息。\n\n- constructor\n\n当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。\n\n当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F。\n\n可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。\n\n1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。\n\n2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object\n\n- toString\n\ntoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。\n\n对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n\n### 判断数组的方法有哪些\n\nobject.prototype.toString.call()\n\n原型链\n\nArray.isArray()\n\ninstanceof\n\nArray.prototype.isPrototypeOf\n\n### ==操作符的强制转化规则\n\n对于==来说，如果双方的类型不太一样，就会类型转化，流程如下。\n\n1.首先判断两者的类型是否相同，相同这比较两者的大小。\n\n2.类型不同的话，就会进行类型转换。\n\n3.会判断是否在对比null和undefined，是的话就返回true。\n\n4.判断两者类型是否为string和number，是的话就会把字符串转成number。\n\n5.一方是否为boolean，就会把boolean转成number，再进行判断\n\n6.判断一方是否为object且另一方为string、number、symbol，\n\n正常情况下调用toString()方法，有运算操作符的时候先调用valueOf()方法再调用toString()方法。\n\n### 其他值转化布尔类型的转化规则\n\n以下为假值\n\nundefined、null、false、+0、-0、NaN、\"\"\n\n其他为真值\n\n### object.is()与比较操作符的区别\n\n使用双等号(==)进行相等判断，如果两边的类型不一样则会强制类型转化。\n\n使用三等号(===)进行相等判断，如果两边的类型不一样不会做强制类型转化，直接返回false。\n\n使用object.is来判断相等，一般情况下和三等号的情况相等，特殊情况+0、-0不在相等，两个NaN是相等的。\n\n### es6的扩展运算符(...)\n\n对象中的扩展运算符(...)用于取出参数对象中的所有可遍历的属性拷贝到当前对象中。\n\n```\nlet bar = { a: 1, b: 2 };\nlet baz = { ...bar }; // { a: 1, b: 2 }\n```\n\n上述方法实际上等价于:\n\n```\nlet bar = { a: 1, b: 2 };\nlet baz = Object.assign({}, bar); // { a: 1, b: 2 }\n```\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\n### 如果new一个箭头函数会怎么样\n\n箭头函数是es6中提出来的，它没有prototype,也没有自己的this指向，更不可以使用arguments参数，所以不能new一个箭头函数。\n\nnew操作符的实现步骤如下:\n\n- 创建一个对象\n- 将构造函数的作用域赋给新对象，也就是将对象的proto属性指向构造函数的prototype属性\n- 指向构造函数中的代码，构造函数中的this指向该对象，为这个对象添加属性和方法\n- 返回新的对象\n\n由上可知第二、三步，箭头函数都是没办法执行的。\n\n### 箭头函数与普通函数有什么区别\n\n箭头函数比普通函数更加简洁\n\n箭头函数没有自己的this(在定义的时候就确定了)\n\n箭头函数继承来的this指向永远不会改变(及不能new一个箭头函数，因为new可以改变this的指向)\n\ncall()、apply()、bind()等方法不能改变this的指向\n\n箭头函数不能作为构造函数使用\n\n箭头没有自己的arguments对象，在箭头函数中访问arguments实际上获得是它外层 函数的arguments值\n\n箭头函数没有自己的prototype\n\n箭头函数不能 作为generator函数，不能用yeild的关键字\n\n### arguments\n\n1.arguments对象和Function是分不开的。\n\n2.因为arguments这个对象不能显式创建。\n\n3.arguments对象只有函数开始时才可用。\n\narguments对象并不是一个数组（类数组），但是访问单个参数的方式与访问数组元素的方式相同\n\n### generator\n\ngenerator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。\n\n```js\nfunction* n(a) {\n    let i = 0;\n\n    while (i < a) {\n        yield i;\n        i++\n    }\n    return;\n}\nlet value = n(5);\nconsole.log(value.next());    //{value: 0, done: false}\nconsole.log(value.next());    //{value: 1, done: false}\nconsole.log(value.next());    //{value: 2, done: false}\n```\n\n### yield\n\nyield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。\nyield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。\nyield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。\n\n### es6处理字符串的方法\n\n- 模板字符串\n\n在模板字符串中空格、缩进、换行都能被保留下\n\n```js\nvar name = 'css'   \nvar career = 'coder' \nvar hobby = ['coding', 'writing']\nvar finalString = `my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}`\n```\n\n- includes\n\n用来判断字符串与子串的包含关系\n\n```js\nconst son = 'haha' \nconst father = 'xixi haha hehe'\nfather.includes(son) // true\n```\n\n- startsWith\n\n判断字符串是否以某个/串字符串开头\n\n```js\nconst father = 'xixi haha hehe'\nfather.startsWith('haha') // false\nfather.startsWith('xixi') // true\n```\n\n- endWith\n\n判断字符串是否以某个/串字符串结尾\n\n```js\nconst father = 'xixi haha hehe'\nfather.endsWith('hehe') // true\n```\n\n- repeat\n\n可以使用同一个字符串输出多次\n\n```js\nconst sourceCode = 'repeat for 3 times;'\nconst repeated = sourceCode.repeat(3) \nconsole.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;\n```\n\n","categories":["面经"],"tags":["面经"]},{"title":"面试总结 10-13","url":"/posts/13632/","content":"\n今天的面试官人也很好\n\n<!-- more -->\n\n### 题目\n\n1.自我介绍(还没说完，面试官就开始问我问题了)\n\n2.css定位\n\n3.说一下transform\n\ntransform属性可以实现文字或图片的旋转、缩放、倾斜、移动，这4种类型的变形处理。\n\n#### 2D\n\n#### 1）旋转\n\n**rotate方法**，定义 2D 旋转。**在参数中加入角度值，角度值后面跟表示角度单位的“deg”文字**即可，**旋转方向为顺时针方向。**\n\n> 例：transform：rotate（45deg）； 旋转45度。\n\n#### 2）缩放\n\n**scale方法来实现文字或图像的缩放处理，在参数中指定缩放倍率。**\n\n> 例：transform：scale（0.5）；//缩小一半\n\n可以分别指定元素的水平方向的放大倍率与垂直方向的放大倍率。\n\n> 例：transform：scale（0.5，2）；//水平方向缩小一半，垂直方向放大一倍。\n\n**scaleX(*x*)通过设置 X 轴的值来定义缩放转换。\n**\n\n**scaleY(*y*)通过设置 Y 轴的值来定义缩放转换。**\n\n#### 3）倾斜  \n\n**skew方法实现文字或图像的倾斜处理**，在参数中分别指定**水平方向上的倾斜角度**与**垂直方向上的倾斜角度**。\n\n> 例：transform：skew（30deg，30deg）；//水平方向上倾斜30度，垂直方向上倾斜30度。\n\n**skewX(*angle*)定义沿着 X 轴的 2D 倾斜转换。\n**\n\n**skewY(*angle*)定义沿着 Y 轴的 2D 倾斜转换。**\n\n#### 4）移动\n\n**translate方法来实现移动文字或图像**，在参数中分别指定**水平方向上的移动距离与垂直方向上的移动距离。**\n\n> 例：transform：translate（50px，50px）；// 水平方向上移动50px，垂直方向上移动50px\n\n**只使用一个参数，省略另一个参数。这种情况下视为只在水平方向上移动，垂直方向上不移动。**\n\n**translateX(*x*)定义转换，只是用 X 轴的值。\n**\n\n**translateY(*y*)定义转换，只是用 Y 轴的值。**\n\n#### **5）变形的基准点 **\n\n在使用transform方法进行文字或图像变形的时候，是**以元素的中心点为基准点进行变形的。**\n\ntransform-origin属性可以改变变形的基准点。\n\n> 例：ransform：rotate（45deg）；\n\n**transform-origin：left bottom；// 把基准点修改为元素的左下角**\n\n**基准点在元素水平方向上的位置：left、center、right；**\n\n**基准点在元素垂直方向上的位置：top、center、bottom。**\n\n### **2、3D旋转**\n\n#### 1）旋转\n\n**rotate3d(*x*,*y*,*z*,*angle*) 定义 3D 旋转。**\n\n或者**分别使用rotateX方法、rotateY方法、rotateZ方法使元素围绕X轴、Y轴、Z轴旋转**，在参数中加入角度值，角度值后面跟表示角度单位的deg文字即可，**旋转方向为顺时针旋转。**\n\n> 例：transform：rotate3d(x,y,z,angle)\n>\n> transform：rotateX（45deg）；\n>\n> transform：rotateY（45deg）；\n>\n> transform：rotateZ（45deg）；\n>\n> transform：rotateX（45deg） rotateY（45deg） rotateZ（45deg）；\n>\n> transform：scale（0.5） rotateY（45deg） rotateZ（45deg）；\n\n#### **2）缩放 **\n\n**scale3d(*x*,*y*,*z*)定义 3D 缩放转换。\n**\n\n或者**分别使用scaleX方法、scaleY方法、scaleZ方法使元素按X轴、Y轴、Z轴进行缩放，在参数中指定缩放倍率。**\n\n> 例：transform：scale3d(x,y,z)；\n>\n> transform：scaleX（0.5）；\n>\n> transform：scaleY（1）；\n>\n> transform：scaleZ（2）；\n>\n> transform：scaleX（0.5）scaleY（1）；\n>\n> transform：scale（0.5） rotateY（45deg）；\n\n#### **3）倾斜 **\n\n**分别使用skewX方法、skewY方法使元素在X轴、Y轴上进行顺时针方向倾斜\\*~~（无skewZ方法）~~\\***，在参数中指定倾斜的角度。\n\n> 例：transform：skewX（45deg）；\n>\n> transform：skewY（45deg）；\n\n#### 4）移动\n\n**使用translateX方法、translateY方法、translateZ方法、使元素在X轴、Y轴、Z轴方向上进行移动，在参数中加入移动距离。**\n\n> 例：transform：translateX（50px）;\n>\n> transform：translateY（50px）;\n>\n> transform：translateZ（50px）;\n\n4.transition和animation的区别分析\n\nransition和animation是通过css3实现动画的两种方式，但是两者存在着什么区别呢\n\n首先先分别介绍一下transition和animation具体如何实现动画吧！\n\n- transition\n\n举个例子：\n\n```css\n.box{\n   width: 100px;\n   height:100px;\n   transition: width height 2s;\n }\n .box:hover{\n    width:200px;\n    height:200px;\n }\n```\n\n当鼠标悬停在类名为box的盒子上时，盒子的宽度和高度会在两秒内变成200px\n\ntransition: property duration timing-function delay;\nproperty：指定CSS属性的name，transition效果\nduration：transition效果需要指定多少秒或毫秒才能完成\ntiming-function：指定transition效果的转速曲线，默认是 “ease”\ndelay：定义transition效果开始的时候\n注意：transition-duration为必须值，否则持续时间为0，transition不会有任何效果。\n\n- animation\n\n```css\n.box{ \n   animation: name duration timing-function delay iteration-count direction fill-mode play-state;\n}\n```\n\nname：规定 @keyframes 动画的名称。\nduration：动画指定需要多少秒或毫秒完成\ntiming-function： 规定动画的速度曲线，默认是 “ease”\ndelay：设置动画在启动前的延迟间隔，默认是 0\niteration-count：定义动画的播放次数(infinite为循环播放)（默认为1）\ndirection：指定是否应该轮流反向播放动画，默认是 “normal”\nfill-mode：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式\nplay-state：指定动画是否正在运行或已暂停，默认是 “running”\n- 二者的区别\n\ntransition和animation大部分属性是相同的，他们都是随时间改变元素的属性值，主要区别在于以下几点：\n\ntransition需要触发一个事件才能改变属性，而animation不需要触发任何事件就会随时间改变属性值\ntransition为两帧，而animation可以是一帧一帧的，跟随自定义动画而言，自定义动画定义了多少帧就执行多少帧\nanimation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次\n性能方面：在使用 aniamtion 的时候可以改变很多属性，比如 width、height、postion 等等这些改变文档流的属性的时候就会引起页面的回流和重绘，对性能影响比较大，而使用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等，不会生成新的位图，就不会引起页面的重绘了\n5.说下重绘和回流\n\n- 回流\n\n回流又称之为重排，当Render Tree中的一部分（或者全部）因元素的规模，尺寸，布局等改变，而需要重新构建页面，就会触发回流\n\n具体总结为：\n\n页面初始渲染\n添加、删除可见的DOM元素\n改变元素位置，尺寸，内容\n触发回流的属性：\n\n盒子模型相关属性：width、height、display、border、border-width…\n定位及浮动：position、left、right、top、bottom、float、padding、margin…\n文字相关：text-align、overflow、font-weight、font-family、line-height，vertical-align、font-size、white-space…\n- 重绘\n\n当Render Tree中的一些元素需要更新属性，而这些属性只是影响到元素的外观，风格而不影响布局，就会触发重绘\n\n触发重绘的属性：\n\ncolor、border-style、border-radius、outline、visibility、background-color、text-decoration、background、background-image、box-shadow…\n\n回流一定重绘，但是重绘不一定回流\n\n- 如何减少回流和重绘\n\n用translate代替top\n用opacity代替visibility\n预先定义好className，然后统一修改Dom的className\n不要把Dom结点的属性值放在一个循环里面变成循环变量\n让要操作的元素进行“离线处理”，处理完后一起更新\n\n6 setTimeout的顺序问题\n\n```js\nfor (var i = 1; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i);\n    }, 1000);\n}\n```\n\n利用函数闭包，用立刻执行的函数来生成一个函数作用域，将i传到匿名函数中。\n\n```js\nfor (var i = 1; i < 5; i++) {\n  ((i) => {\n    setTimeout(() => {\n      console.log(i)\n    },1000);\n  })(i)\n}\n```\n\nes6,把var变成let,形成块级作用域\n\n```js\nfor (let i = 1; i < 5; i++) {\n    setTimeout(() => {\n        console.log(i);\n    }, 1000);\n}\n```\n\n使用setTimeout的第三个参数。\n\n```js\nfor (var i = 1; i < 5; i++) {\n    setTimeout((i) => {\n        console.log(i);\n    }, 1000, i);\n}\n```\n\n7.求数组的深度\n\n```js\nvar arr = [1,2,3,[1,5,6,[7,9,[11,32]]],10];\nvar a=1;\nfunction multiarr(arr){\n    for (i=0;i<arr.length;i++){\n                if(arr[i] instanceof Array){\n                a++;\n                arr = arr[i];\n                multiarr(arr);\n            }\n        }\n    return a;\n}\nconsole.log(multiarr(arr)); \n```\n\n8.Vue中的$nextTick怎么理解?\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n参考：https://blog.csdn.net/weixin_44475093/article/details/111056047\n\n9.vueRoute的模式\n\n10.hash模式的原理\n\n11.TCP稳定的原因\n\n12.说下Content-Type\n\n","categories":["面经"],"tags":["面经"]},{"title":"面试总结 2","url":"/posts/63846/","content":"\n今天面试的小哥哥人真好，非常耐心的指导\n\n<!-- more -->\n\n### 题目\n\n1.介绍下项目，说说项目中的难点\n\n问:问了项目中用户列表下面那个分页的和用户列表是不是同一个组件\n\n答:当时我有点记不清了，说了不是。用户列表是用的el-table组件，分页用的是pagination组件，所以不是同一个组件。\n\n问:如果要把分页组件放到屏幕的下方该怎么做\n\n答:用fixed定位(position:fixed),感觉没答好\n\n2.手写一个总高800px,上面200px,下面200px,中间撑开\n\n答：QAQ，之前没练过，小哥哥提醒说用fex,当时忘了设置flex-direction: column,让他们纵向排序了，也忘了中间设置，flex:1,放大充满剩余的地方。正确代码如下：\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        .container {\n            display: flex;\n            background-color: black;\n            width: 100%;\n            height: 800px;\n            flex-direction: column;\n        }\n        .header {\n            width: 100%;\n            height: 200px;\n        }\n        .main {\n            flex: 1;\n            background-color: #03a9f4;\n        }\n        .footer {\n            width: 100%;\n            height: 200px;\n            background-color: red;\n        }\n\n    </style>\n</head>\n<body>\n  <div class=\"container\">\n      <div class=\"header\">头部</div>\n      <div class=\"main\">内容</div>\n      <div class=\"footer\">尾部</div>\n  </div>\n</body>\n</html>\n\n```\n\n3.在一个排好序中的数组中查找一个数，如果该数不存在则，返回这个数在插入的位置\n\n例如find([1,2,5,6,7,9], 5)  结果为2，find([1,2,5,6,7,9], 8)  结果为6,\n\nfind([], 3)  结果为0\n\n```js\nfunction find (nums, target) {\n    const len = nums.length;\n    if (len == 0 || nums[0] >= target) return 0;\n    if (nums[len - 1] < target) return len;\n    for (let i = 0; i < len; i++){\n        if (nums[i] == target) return i;\n        if (nums[i] < target && target < nums[i + 1]) return i + 1;\n    }\n}\n      \n      console.log(find([1,2,4,6], 4));\n      console.log(find([1,2,4,6], 5));\n      console.log(find([], 3));\n```\n\n然后面试官又让我用二分法写。\n\n4.怎么学习前端的，学了多久，以后会怎么学习\n\n5.反问\n\n公司的培养计划\n\n公司的技术栈\n\n### 总结\n\n面试感觉还是挺好的，主要是当时有点懵了，没答好，基础没答上，要把基础补一下。\n\n### 遇到的其他题目\n\n1.说一下css的盒模型\n\n```\ncss盒子模型:内容(content)、内边距(padding)、边框(border)、外边距(magrin)\n```\n\n2.http、https的区别\n\n参考:https://www.cnblogs.com/aidixie/p/11764181.html\n\n3.es5、es6了解吗\n\nEs5是第5版的js标准、es6是第6版的js标准。\n\nes6的新特性：\n\nlet、const，块级作用域\n\n模板字符串\n\n箭头函数\n\n函数可设置默认参数\n\n对象和解构赋值\n\n4.同源策略，为什么会有这个？安全性？\n\n源:只有两个页面具有相同的 协议+域名+端口，那么他们称之为同源\n\n同源策略：\n\n同源策略是浏览器的一个安全模型，它规定了：不同源的两个客户端脚本在没有授权的情况下，不能读写对方的资源。(同时这里需要注意的一个概念：同源策略是浏览器的一种安全措施，它并没有禁止脚本的执行，只是由于同源策略的作用禁止读取HTTP回复，实际上，脚本是成功运行了的)\n\n5.使用过正则吗\n\nvar reg = new RegExp('\\\\d{8-20}')\n\nreg.test(\"aa1244\")   //false\n\n 标识主要包括：    1. i 忽略大小写匹配    2. m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项    3. g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止\n\n代表特殊含义的元字符\n\n```\n\\d : 0-9之间的任意一个数字  \\d只占一个位置\n\\w : 数字，字母 ，下划线 0-9 a-z A-Z _\n\\s : 空格或者空白等\n\\D : 除了\\d\n\\W : 除了\\w\n\\S : 除了\\s\n . : 除了\\n之外的任意一个字符\n \\ : 转义字符\n | : 或者\n() : 分组\n\\n : 匹配换行符\n\\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 => 不占用字符串位数\n ^ : 限定开始位置 => 本身不占位置\n $ : 限定结束位置 => 本身不占位置\n[a-z] : 任意字母 []中的表示任意一个都可以\n[^a-z] : 非字母 []中^代表除了\n[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符\n```\n\n代表次数的量词元字符\n\n```\n* : 0到多个\n+ : 1到多个\n? : 0次或1次 可有可无\n{n} : 正好n次；\n{n,} : n到多次\n{n,m} : n次到m次\n```\n\n","categories":["面经"],"tags":["面经"]},{"title":"笔试中的 acm 模式","url":"/posts/61258/","content":"\nACM模式下JS的输入与输出\n\n<!-- more -->\n\n总结一下遇到的ACM模式\n\n## 牛客网\n\n### v8环境\n\n以计算a + b 为例\n\n输入\n\n```\n1 5\n10 20\n```\n\n输出\n\n```js\n6\n30\n```\n\n代码如下\n\n```js\nwhile (line=readline()) {\n    let num1 = parseInt(line.split(' ')[0]);\n    let num2 = parseInt(line.split(' ')[1]);\n    print(num1 + num2);\n}\n```\n\n小结：v8模式下的输入是**readline()**,读的是字符串，一行一行地读，如果有空格用spilt(' ')分割，如果要运行用parseInt()转成数字，toFixed(n)保留n位有效数字。输出用console.log()或者print()\n\n### node.js\n\n以计算a + b 为例\n\n输入\n\n```\n1 5\n10 20\n```\n\n输出\n\n```js\n6\n30\n```\n\n代码如下\n\n```js\nvar readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\nrl.on('line', function(line){\n    var tokens = line.split(' ');\n    console.log(parseInt(tokens[0]) + parseInt(tokens[1]));\n});\n```\n\n小结：node环境下需要引入 readline模块，相对于v8来说比较麻烦，所以有v8就用v8\n\n## 赛码网\n\n### v8\n\n## [版本](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=版本-3)\n\n> Google V8 Engine(6.2.340)\n\n## [输入API](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=输入api)\n\n### [读取一行输入](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=读取一行输入)\n\n> read_line()\n\n> 将读取至多1024个字符，当还未达到1024个时如果遇到回车或结束符，提前结束。\n\n> 读取多行最简单的办法是while((line = read_line()) != '')。\n\n> 或者使用下一个API。\n\n### [读取n个字符](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=读取n个字符)\n\n> gets(n)\n\n> 将读取至多n个字符，当还未达到n个时如果遇到回车或结束符，会提前结束。\n\n> 回车符可能会包含在返回值中。\n\n### [读取一个（长）整数](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=读取一个（长）整数)\n\n> readInt()\n\n### [读取一个浮点型](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=读取一个浮点型)\n\n> readDouble()\n\n## [输出API](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=输出api)\n\n### [不加回车的输出](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=不加回车的输出)\n\n> printsth(sth, ...)\n\n> 往控制台输出sth，当有多个参数时，空格分隔；最后不加回车。\n\n### [带回车的输出](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=带回车的输出)\n\n> print(sth, ...)\n\n> console.log(sth, ...)\n\n> 往控制台输出sth，当有多个参数时，空格分隔；最后加回车。\n\n## [示例代码1](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=示例代码1)\n\n```js\nvar a, b;\nvar solveMeFirst = (a,b) => a+b;\nwhile((a=readInt())!=null && (b=readInt())!=null){\n    let c = solveMeFirst(a, b);\n    print(c);\n}\n```\n\n## [示例代码2](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=示例代码2)\n\n```js\nvar line;\nvar solveMeFirst = (a,b) => a+b;\nwhile((line = read_line()) != ''){\n    let arr = line.split(' ');\n    let a = parseInt(arr[0]);\n    let b = parseInt(arr[1]);\n    let c = solveMeFirst(a, b);\n    print(c);\n}\n```\n\n## [V8源码](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=v8源码)\n\n> https://github.com/acmcodercom/v8/tree/forstdio_baseon_6.2.340/samples\n\n# [Nodejs](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=nodejs)\n\n## [版本](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=版本-4)\n\n> 6.9.1\n\n## [输入输出](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=输入输出-1)\n\n> process.stdin、process.stdout\n\n> readline\n\n> node-stdio (https://www.npmjs.com/package/node-stdio)\n\n## [示例代码1](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=示例代码1-1)\n\n```js\nvar cmd = require('node-stdio')\nvar a, b;\nvar solveMeFirst = (a,b) => a+b;\nwhile((a=cmd.readInt())!=null && (b=cmd.readInt())!=null){\n    let c = solveMeFirst(a, b);\n    cmd.print(c);\n}\n```\n\n## [示例代码2](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=示例代码2-1)\n\n```js\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\n \nvar input = \"\";\nvar input_array = \"\";\n\n//这里不灵活，需要全部读取数据后再处理，容易超内存。\nprocess.stdin.on('data', function (data) {\n    input += data;\n});\n\nvar solveMeFirst = (a, b) => a+b;\n\nprocess.stdin.on('end', function () {\n    let arr = input.split(\"\\n\");\n    for (var i=0; i<arr.length; i++) {\n        if (arr[i] != '') {\n            input_array = arr[i].split(\" \");\n            \n            let inline = 0;\n            let res;\n            let _a = parseInt(input_array[inline].trim(), 10);\n            inline += 1;\n        \n            let _b = parseInt(input_array[inline].trim(), 10);\n            inline += 1;\n        \n            res = solveMeFirst(_a, _b);\n            process.stdout.write(\"\" + res + \"\\n\");\n        }\n    }\n});\n```\n\n## [示例代码3](https://labfiles.acmcoder.com/ojhtml/index.html#/?id=示例代码3)\n\n```js\nvar readline = require('readline');\nprocess.stdin.setEncoding('utf-8');\n\nvar rl = readline.createInterface({input: process.stdin, output: process.stdout, prompt:''});\nrl.prompt();\n\nvar solveMeFirst = (a, b) => a+b;\n\nrl.on('line', function (data) {\n    let arr = data.split(' ');\n    if (arr && arr.length==2) {\n        let c = solveMeFirst(+arr[0], +arr[1]);\n        process.stdout.write('' + c + '\\n');\n    }\n});\n```\n\n","categories":[],"tags":[]},{"title":"笔试题总结","url":"/posts/771/","content":"\n笔试题汇总1\n\n<!-- more -->\n\n## 2021小米秋招前端方向第二场笔试\n\n### 选择题\n\n1.使用浏览器访问http://miui.com/时，以下哪些过程发生在**浏览器端**？\n\na.构建HTTP 请求\nb.解析HTTP 请求\nc.发送HTTP 响应\nd.渲染页面\n\n```\n解析:浏览器端构建HTTP请求，并发送 -> 服务器端接收到HTTP请求，并进行解析 -> 服务器端发送HTTP响应 -> 浏览器端接收到响应，并进行页面渲染。\n故发生在浏览器端的有-构建HTTP请求-页面渲染\n答案a、d\n```\n\n2.下列哪些关于HTTP/2 的描述是**正确**的？\n\na.解决了TCP 队头阻塞的问题\nb.解决了浏览器线头阻塞的问题\nc.使用了头部压缩\nd.使用二进制分帧封装HTTP 消息\n\n```\n解析:HTTP/0.9：功能简陋，只支持GET方法，只能发送HTML格式字符串。\nHTTP/1.0：支持多种数据格式，增加POST、HEAD等方法，增加头信息，每次只能发送一个请求（无持久连接）\nHTTP/1.1：默认持久连接、请求管道化、增加缓存处理、增加Host字段、支持断点传输分块传输等。\nHTTP/2.0：二进制分帧、多路复用、头部压缩、服务器推送\nHTTP/3.0：tcp队头阻塞 (不是链条，是数据流，互不影响)\n参考链接 https://www.jianshu.com/p/28a35094dc5d，\nHTTP/2并没有解决这个问题\n采用HTTP/2时，浏览器一般会在单个TCP连接中创建并行的几十个乃至上百个传输。\n如果HTTP/2连接双方的网络中有一个数据包丢失，或者任何一方的网络出现中断，整个TCP连接就会暂停，丢失的数据包需要被重新传输。因为TCP是一个按序传输的链条，因此如果其中一个点丢失了，链路上之后的内容就都需要等待。\n参考链接\nhttps://www.kancloud.cn/kancloud/http3-explained/1395005\n答案 b、c、d\n```\n\n3.下面对于服务端渲染和客户端渲染描述**正确**的是\n\na.通过vue-cli，create-react-app 等工具创建的项目是服务端渲染的\nb.服务端渲染的用户体验一定优于客户端渲染\nc.服务端渲染对SEO更加友好，而且首屏渲染通常更快一些\nd.SPA是客户端渲染的\n\n```js\n解析：https://ssr.vuejs.org/zh/\nserver-side-render\n就是让服务器来渲染页面。\nhttps://zhuanlan.zhihu.com/p/171579801\n优点\n与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：\n更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\n更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。首屏响应时间变短\n缺点\n开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。\n涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n答案 c、d\n```\n\n4.有效防止XSS 的手段有哪些？\n\na.过滤用户请求中的非法字符\nb.对请求中的特殊字符进行转译\nc.配置CSP（Content Security Policy）\nd.通过预编译来防止\n\n```\n解析:参考链接https://tech.meituan.com/2018/09/27/fe-security.html\n答案: a、b、c\n```\n\n5.下列排序算法中，哪些时间复杂度不会超过nlogn？\n\na.快速排序\nb.堆排序\nc.归并排序\nd.冒泡排序\n\n![](/gallery/sort-way.png)\n\n```\n解析: 看图注意是所有情况下的复杂度不超过nlogn,快排最坏的情况下是o(n2) 已经有序的情况下\n答案: b、c\n```\n\n6.下面关于transform说法正确的是\n\na.只对受控于盒模型的元素生效\nb.变形的原点默认是元素的左上角\nc.变形后元素在页面上的占位也随之变化\nd.可以通过matrix函数整合多种变形效果\n\n```\n解析:\ntransform变形默认圆点为中心。\ntransform变形后占位不会变化，它会创建一个新的图层来显示。\ntransform变形的几点可通过transform-origin设置，默认系中心点。所以B不对。\ntransform对行内元素不生效 可参考https://www.bbsmax.com/A/x9J2b7agJ6/\n答案:a、d\n```\n\n7.下面对于Webpack 描述正确的是\n\na.Webpack 是一个模块打包工具\nb.Webpack 可以运行在服务端和浏览器中\nc.Webpack 适合复杂的大型项目，小型项目可以使用 vue-cli 等简单的打包工具进行开发\nd.Webpack 可以实现热更新，开发更加高效\n\n```\n解析: webpack不在浏览器上运行，webpack适合小型项目，大型项目用vue-cli\n答案 a、d\n```\n\n8.下面哪些方法会中断js执行\n\na.alert\nb.sync ajax请求\nc.setTimeout\nd.fetch\n\n```\n解析 同步会中断js的执行 \n同步 alert sync \n异步 setTimeout fetch(参考链接https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html) async\n答案 a、b\n```\n\n9.在ES6 规范中，以下哪些类型属于基本数据类型？\n\na.string \nb.function\nc.number\nd.boolean\n\n```\n基本数据类型（原始数据类型）：Number,String, Null, Undefined,  Boolean，Symbol（es6新增）BigInt\n引用数据类型：Object，Function,Array\n答案 a、c、d\n```\n\n10.下列哪些协议是应用层协议？\n\na.HTTP\nb.SSL/TLS\nc.TCP\nd.SSH\ne.FTP\nf.IP\n\n![](/gallery/iso-7.jpg)\n\n```\n解析:SL/TLS协议工作在应用层和传输层之间\n答案 a、d、e\n```\n\n11.关于进程，下列说法错误的是？\n\na.进程有独立的地址空间\nb.进程间可以通过网络通信\nc.内存不能在不同进程间共享\nd.进程是系统进行资源分配和调度的基本单位\n\n```\n解析：进程（Process）是系统进行资源分配和调度的基本单位。\n进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。\n答案 c\n```\n\n12.下面哪个关于TCP 与 UDP 的描述是错误的？\n\na.TCP 提供可靠度的字节流服务\nb.建立TCP 连接需要三次握手\nc.使用UDP 传输数据，源端和终端不建立连接\nd.HTTP 建立在 UDP 之上\n\n```\n解析 http3用了udp\n答案 d\n```\n\n13.关于浏览器缓存，下列说法正确的是？\n\na.Service Worker cache 的优先级没有 disk cache 高\nb.服务端没法控制浏览器缓存的过期时间\nc.浏览器不会将缓存存在内存中\nd.浏览器会先在浏览器缓存中查询是否有要请求的文件满足需求，再决定是否发送请求\n\n```\n解析 浏览器缓存是性能优化中简单高效的一种方式，按照缓存位置划分为以下几种类型：. service Worker. Memory Cache. Disk Cache. Push Cache. 浏览器请求时，会按照如上的优先级顺序，进行查找缓存，都没有命中时，才会去请求网络 可参考：https://blog.csdn.net/m0_37217612/article/details/107942864\n答案 d\n```\n\n14.下面哪个不能解决跨域问题\n\na.CORS\nb.代理\nc.iframe\nd.JSONP\n\n```\n解析 CORS是一种允许当前域（domain）的资源（比如html/js/web service）被其他域（domain）的脚本请求访问的机制 iframe 某种情况下不能解决跨域\n```\n\n15.以下哪个排序算法不是稳定的？\n\na.快速排序\nb.插入排序\nc.归并排序\nd.选择排序\n\n```\n解析 快排和选择排序不稳定 a在b前面,a = b ,排序后a还在b前面则为稳定排序否则不稳定\n答案 a、d\n```\n\n16.下列关于GBK和UTF8编码描述错误的是？\n\na.GBK编码汉字占用2个字节\nb.UTF8编码占用3个字节\nc.GBK编码有包含中文简体和繁体字符\nd.UTF8编码有包含中文和繁体字符\n\n```\n解析 b选项 utf-8的长度是可变的 汉字大多数是3个字节也有4字节的 所有b是错的\n参考 https://www.cnblogs.com/zxz1987/articles/6544593.html\n答案 b\n```\n","categories":["笔试"],"tags":["笔试"]},{"title":"面试题","url":"/posts/27055/","content":"\n总结一下现在做过的面试题\n\n<!-- more -->\n\n## 公司介绍\n\n### 深信服\n\n深信服是一家专注于企业级网络安全、云计算、IT基础设施与物联网的产品和服务供应商\n\n## 笔试题\n\n1.本地存储了解多少\n\n答:cookie、localStorage、sessionStorage、indexedDB\n\ncookie、localStorage、sessionStorage异同\n\n| 特性           | Cookie                                                       | localStorage                                                | sessionStorage                                              |\n| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ----------------------------------------------------------- |\n| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除                |\n| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   | 一般为5MB                                                   |\n| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |\n| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |\n\nindexedDB的特点\n\n**（1）键值对储存。** IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。\n\n**（2）异步。** IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n\n**（3）支持事务。** IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n\n**（4）同源限制** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n\n**（5）储存空间大** IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。\n\n**（6）支持二进制储存。** IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。\n\n2.XSS与CSRF攻击了解多少，了解其他攻击吗？\n\nXSS：**跨站脚本攻击**（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。\n\nCSRF:**跨站请求伪造**（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。\n\n参考:https://www.cnblogs.com/itsuibi/p/10752868.html\n\n3.对跨域的了解，JSONP的原理，src为什么能跨域\n\n跨域是浏览器本身施加的安全限制，浏览器的同源策略决定了一个网站不可以执行非本网站下的脚本，浏览器的同源策略，即指网站域名，请求协议，服务端口均相同 \n\nJSONP的原理：其本质是利用了标签具有可跨域的特性，由服务端返回预先定义好的javascript函数的调用，并且将服务端数据以该函数参数的形式传递过来。\n\n**原理:**script img link 获取资源不受浏览器同源策略限制\n\n4.伪类与伪元素的区别\n\n伪类，更多的定义的是状态。常见的伪类有 :hover，:active，:focus，:visited，:link，:not，:first-child，:last-child等等。\n\n伪元素，不存在于DOM树中的虚拟元素，它们可以像正常的html元素一样定义css，但无法使用JavaScript获取。常见伪元素有 ::before，::after，::first-letter，::first-line等等。\n\nCSS3明确规定了，伪类用一个冒号(:)来表示，而伪元素则用两个冒号(::)来表示。但目前因为兼容性的问题，它们的写法可以是一致的，都用一个冒号(:)就可以了，所以非常容易混淆。\n\n参考链接：https://segmentfault.com/a/1190000017784553\n\n5.请说一下 Vue 的生命周期？\n\n初始化阶段：为 Vue 实例初始化一些事件、属性和响应式数据等\n\n模板编译阶段：把我们写的 `<template></template>` 模板编译成渲染函数 `render`\n\n挂载阶段：把模板渲染到真实的 DOM 节点上，以及数据变更时执行更新操作\n\n销毁阶段：把组件实例从父组件中删除，并取消依赖监听和事件监听\n\n![](/gallery/vue-life.webp)\n\n6.Git常用的命令\n\ngit init：仓库的初始化；\ngit status：查看当前仓库的状态；\ngit diff：查看仓库与上次修改的内容；\ngit add：将文件添加至暂存区；\ngit commit：提交代码；\ngit clone：克隆代码；\n<<<<<<< HEAD\ngit branch：查看当前分支；\n=======\ngit bransh：查看当前分支；\n>>>>>>> c728d66bef1038018a91f5229f0ef8f72309e64f\ngit checkout：切换当前分支；\n7.怎样提高代码的质量\n\n1.谨慎命名，取名清晰，避免误导\n\n2.函数和类都应该 坚持单一权责原则\n\n3.写好注释\n\n4.良好的代码格式\n\n5.有错误处理\n\n8.nextTick有了解吗？ \n\n  ：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM  \n\n  它的应用场景有哪些？ \n\n  ：在数据变化之后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中 \n\n  9.事件循环是什么？宏任务和微任务都有哪些？\n\nJS的代码执行是基于一种事件循环的机制\n\nJS中有两种任务类型：**微任务**（microtask）和**宏任务**（macrotask），在ES6中，microtask称为 jobs，macrotask称为 task。\n\n**宏任务**： script （主代码块）、`setTimeout` 、`setInterval` 、`setImmediate` 、I/O 、UI rendering\n\n**微任务**：`process.nextTick`（Nodejs） 、`promise` 、`Object.observe` 、`MutationObserver`\n\n10.防抖和节流，定义及适用场景\n\n防抖：文本编译器实时保存、登陆发送短信验证码等按钮避免用户点击太快、调整浏览器窗口大小\n\n实际使用：\n\n```HTML\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n  <body>\n    <button id=\"submit-btn\">提交</button>\n  </body>\n  <script>\n    function submit() {\n      console.log(\"submit\");\n    }\n\n    const debounce = (fn, delay) => {\n      let timerId = null;\n      return (...args) => {\n        if (timerId) {\n          window.clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n          fn.apply(this, args);\n          timerId = null;\n        }, delay);\n      };\n    };\n\n    const btnDebounce = debounce(submit, 1000);\n\n    const btn = document.getElementById(\"submit-btn\");\n    btn.addEventListener(\"click\", btnDebounce);\n  </script>\n</html>\n```\n\n\n\n节流：滚动加载、搜索[联想](https://www.nowcoder.com/jump/super-jump/word?word=联想)功能、浏览器播放事件\n\n实际使用\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>节流</title>\n    <meta charset=\"utf-8\" />\n  </head>\n  <body>\n    <button id=\"submit-btn\">提交</button>\n  </body>\n  <script>\n    function submit() {\n      console.log(\"submit\");\n    }\n\n    const throttle = (fn, delay) => {\n      let canUse = true;\n      return (...args) => {\n        if (canUse) {\n          fn.apply(this, args);\n          canUse = false;\n          setTimeout(() => (canUse = true), delay);\n        }\n      };\n    };\n\n    // 间隔设为3秒，效果比较明显\n    const btnThrottle = throttle(submit, 3000);\n\n    const btn = document.getElementById(\"submit-btn\");\n    btn.addEventListener(\"click\", btnThrottle);\n  </script>\n</html>\n```\n\n11.服务端渲染和客服端渲染\n\n客户端渲染：客户端渲染模式下，服务端把渲染的静态文件给到客户端，客户端拿到服务端发送过来的文件自己跑一遍js，根据JS运行结果，生成相应DOM，然后渲染给用户。\n\n服务端渲染：服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。\n参考：https://blog.csdn.net/guoshujie1/article/details/89884080\n\n12 css3的新特性\n\nCSS3中新添加了很多选择器，Transform和Animation，新的边框属性border-radius 圆角 ，border-image 边框图片，box-shadow 阴影，渐变linear-gradient(线性渐变)和radial-gradient(径向渐变)\n\n13 webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全\n\n- 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；\n- 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；\n- 确定入口：根据配置中的 entry 找出所有的入口文件；\n- 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；\n- 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；\n- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；\n- 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。\n\n14.Vue-router相关的问题\n\nhttps://www.cnblogs.com/qwer123dsada/p/14709952.html\n\n15.深拷贝\n\n```js\n// 定义一个深拷贝函数  接收目标target参数\nfunction deepClone(target) {\n    // 定义一个变量\n    let result;\n    // 如果当前需要深拷贝的是一个对象的话\n    if (typeof target === 'object') {\n    // 如果是一个数组的话\n        if (Array.isArray(target)) {\n            result = []; // 将result赋值为一个数组，并且执行遍历\n            for (let i in target) {\n                // 递归克隆数组中的每一项\n                result.push(deepClone(target[i]))\n            }\n         // 判断如果当前的值是null的话；直接赋值为null\n        } else if(target===null) {\n            result = null;\n         // 判断如果当前的值是一个RegExp对象的话，直接赋值    \n        } else if(target.constructor===RegExp){\n            result = target;\n        }else {\n         // 否则是普通对象，直接for in循环，递归赋值对象的所有值\n            result = {};\n            for (let i in target) {\n                result[i] = deepClone(target[i]);\n            }\n        }\n     // 如果不是对象的话，就是基本数据类型，那么直接赋值\n    } else {\n        result = target;\n    }\n     // 返回最终结果\n    return result;\n}\n```\n\n16.介绍一下项目 \n","categories":["面试题"],"tags":["面试题"]},{"title":"面试总结 9.24","url":"/posts/54740/","content":"\n总结一下今天面试的经历，防止踩坑\n\n<!-- more -->\n\n一面\n\n1.自我介绍(有点卡顿，还需要多加练习)\n\n2.你项目有什么亮点\n\n答:简单说了下(面试之前还是得好好想想这个问题，把项目说清楚，把难点也说清楚)\n\n3.HTML5的新特点\n\n答: 这个当时没答上(之前看过但是忘了QAQ)\n\n1.语义化标签 header. footer. section等\n2.增强型表单\ninput输入框增加了多个输入类型。比如新增：color.，date等\n新增表单：output. datalist.\n新增表单属性：placehoder\n3.视频和音频，新增视频和音频标签video和audio\n4.新增canvas绘图\n5.地理定位Geolocation\n6.拖放api.\n7.webstore，使用html5可在本地存储数据，客户端存储对象：locationStore和sessionStore.\n\n4.Vue的生命周期以及这个周期发生的事\n\n答：当时答了一些，没答全，附上文章链接https://www.cnblogs.com/goloving/p/8617785.html\n\n5.问了常见的定位\n\n答：相对定位（relative)相对于自己在文档流的位置\n\n将相对定位特征总结如下：\n\n**①相对定位的元素，在没有设置宽度的情况下，宽度是整个浏览器的宽度，或者是依赖于父元素的宽度。**\n\n**②相对定位的块状元素相对于原来位置移动，移动后仍然占据文档流的位置，不影响其他元素的布局**\n\n 绝对定位（absolute)\n\n看它的上级或上上级有没有定位了，使用left，right，top， bottom等属性相对于其最接近的一个有相对或者绝对定位设置的父级对象进行绝对定位，如果父级没有设置定位属性，则会相对于html根元素进行定位\n\n将绝对定位的特征总结如下：\n\n**①绝对定位的块状元素在没有设置宽度的情况下，宽度由元素里面的内容决定**\n\n**②脱离后原来的位置相当于是空的，下面的元素会来占据位置**\n\n**③绝对定位的对象相对于距离自己最近的设置了相对定位或者绝对定位的父对象进行定位**\n\n**④如果父元素没有定位，则相对于html根元素定位**\n\n6.你常用的样式\n\n答:说了自己常用的\n\n7.你认为学习前端最重要的是什么\n\n答：先是要有扎实的基础，然后要仔细，要总结自己所学的等，感觉没答好。\n\n从技术角度出发:过硬的编程技术、基础知识\n\n从心态角度出发:良好的心态，坚持和毅力，有事干心理\n\n还要有兴趣，对自己做出来的东西有成就感\n\n8.还问了其他的问题，比如说外出出差、成绩、了不了解公司等。\n\n 总结:问的问题不多但是我回答的问题的正确性他也不做评价，最后还问了为什么要加入他们公司，反问的时候问了工资怎么样，他说你能不能来实习都不知道，听到这句话的时候就感觉要凉，后来就没怎么问了。这家公司招的基本上是Java后端的，笔试题都是Java的，最后还是挂了。\n\n","categories":["面试经验"],"tags":["面试"]},{"title":"闲聊","url":"/posts/16446/","content":"\n今天是个转折点，心情变好了\n\n<!-- more -->\n\n今天收到了一个offer，终于不是0offer了，因为春招的时候准备的不多等秋招了，但是秋招因为简历投晚了，已经没多少公司了，这一段时间都在焦虑中，现在好了，终于有点进展了。但是最后还是拒绝了，应为想找个实习的岗位，但是他是正式岗位，所以决定了继续准备。现在已经投了几家公司就等面试了，继续加油吧。\n","categories":["闲聊"],"tags":["闲聊"]},{"title":"leetcode- 重新学动态规划","url":"/posts/17343/","content":"\n最近在刷动态规划的题目 ，决定重新整理一下关于动态规划的知识\n\n<!-- more -->\n\n## 什么是动态规划\n\n动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。\n\n所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，\n\n## 动态规划的解题步骤\n\n1. 确定dp数组（dp table）以及下标的含义\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n\n## 实战\n\n### 打家劫舍\n\n[力扣题目链接](https://leetcode-cn.com/problems/house-robber/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n**示例：**\n\n```\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n**分析：**\n\n1.确定dp数组，这里我们可以设dp[i]表示i间房偷窃的最高金额\n\n2.由题意可知偷第i间房可得dp[i] = dp[i - 2] + nums[i],偷i - 1间房(**重点是偷i- 1间房，应为不能连着偷，即不偷i间房**)可得dp[i] = dp[i - 1]\n\n3.由题意可知 dp[0] = nums[0], dp[1] = max(nums[0], nums[1])\n\n4.由2可知是从前往后遍历的\n\n5.输入[2,7,9,3,1]\n\ndp[i] = [2,7,11,11,12]\n\n```js\nvar rob = function(nums) {\n    let dp = [];\n    if (len < 2) {\n        return len === 1 ? nums[0] : Math.max(nums[0], nums[1]);\n    }\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n    for (let i = 2; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n    }\n    return dp[nums.length - 1];\n};\n//压缩一下 可以用三个变量代替\n```\n\n### 打家劫舍II\n\n[力扣题目链接](https://leetcode-cn.com/problems/house-robber-ii/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n\n**示例：**\n\n```\n输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**分析**\n\n本题和上题的区别就是首尾不能同时选，所以只考虑包含头或者尾的情况。\n\n```js\nvar rob = function(nums) {\n    const len = nums.length;\n    if (len <= 2) {\n        return len == 1 ? nums[0] : Math.max(nums[0], nums[1]);\n    }\n    const robs = ((i, j) => {\n        let a = nums[i];\n        let b = Math.max(nums[i], nums[i + 1]);\n        let res = 0;\n        if (j - i <= 2) {\n            return j - i == 1 ? a : b;\n        }\n        for (let k = i + 2; k < j; k++) {\n            res = Math.max(a + nums[k], b);\n            a = b;\n            b = res;\n        }\n        return res;\n    })\n    let ans1 = robs(0, len - 1);\n    let ans2 = robs(1, len);\n    return ans1 > ans2 ? ans1 : ans2; \n};\n```\n\n## 337.打家劫舍 III\n\n[力扣题目链接](https://leetcode-cn.com/problems/house-robber-iii/)\n\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n**示例:**\n\n```\n输入: [3,2,3,null,3,null,1]\n\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n\n输入: [3,4,5,1,3,null,1]\n\n     3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n```\n\n**分析**\n1.由题可知每个结点有两种状态[偷，不偷]\n\nval1表示偷该结点盗取最大的值，val2表示不偷该结点盗取最大的值\n\n2.偷该结点则不偷儿子结点 val1 = val + left[1] + right[1]\n\n  不偷该结点则为两个儿子结点两种状态的最大值的和\n\n  val2 = max(left[0], left[1]) + max(right[0], right[1])\n\n3.偷的结点是空 则返回 [0, 0]\n\n4.由上可知由儿子结点推父结点则采用后续遍历\n\n```js\nvar rob = function(root) {\n   const dfs = (node) => {\n     if (node == null) return [0, 0];\n     let left = dfs(node.left);\n     let right = dfs(node.right);\n     let val1 = node.val + left[1] + right[1];\n     let val2 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n     return [val1, val2]; \n   }\n   let ans = dfs(root);\n   return Math.max(...ans);\n\n};\n```\n\n","categories":["刷题"],"tags":["动态规划"]},{"title":"CSS 画一个月饼","url":"/posts/4214/","content":"\n今天是中秋节准备整个活，用CSS画一个月饼\n\n![](/gallery/moon.png)\n\n<!-- more -->\n\n开始整活\n\n工具：webstorm，nginx，阿里云服务器\n\n## 画一个月饼\n\n### 画一个圆\n\n使用flex布局画一个圆同时给上背景色\n\n```html\n<div class=\"main\">\n    <div class=\"cake\">\n    </div>\n</div>\n```\n\n\n\n```css\nbody {\n    background-image: linear-gradient(110deg, rgba(73, 93, 109, 1) 0%, rgba(49, 55, 82, 1) 100%);\n}  /*线性渐变*/\n.main {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    flex-direction: column;\n}\n.cake {\n    width: 250px;\n    height: 250px;\n    left: 10px;\n    border-radius: 50%;\n    position: relative;\n    background-color: var(--base-color);\n    animation: moon 4s infinite ;\n}\n```\n\n![](/gallery/moon-1.jpg)\n\n使用伪元素画月饼的边\n\n```html\n<div class=\"main\">\n    <div class=\"cake\">\n        <div class=\"edge\"></div>\n        <div class=\"edge\"></div>\n    </div>\n</div>\n```\n\n\n\n```css\n.edge {\n    background-color: var(--base-color);\n    width: 100px;\n    height: 250px;\n    position: absolute;\n    border-radius: 50px;\n    transform: translateX(-50%) scale(1.05);\n    left: 50%;\n    top: 0;\n    box-shadow: inset 0px 0px 18px rgba(0, 0, 0, .2);\n}\n.edge::before,\n.edge::after {\n    content: '';\n    display: block;\n    background-color: inherit;\n    width: inherit;\n    height: inherit;\n    position: inherit;\n    border-radius: inherit;\n    left: inherit;\n    top: inherit;\n    box-shadow: inherit;\n}\n\n.edge::before {\n    transform: translateX(-50%) scale(1.03) rotateZ(-30deg);\n}\n\n.edge::after {\n    transform: translateX(-50%) scale(1.03) rotateZ(-60deg);\n}\n\n.edge:nth-child(2) {\n    transform: translateX(-50%) scale(1.05) rotateZ(90deg);\n}\n```\n\n![](/gallery/moon-2.jpg)\n\n以同样的方法画月饼里面\n\n```html\n<div class=\"main\">\n    <div class=\"cake\">\n        <div class=\"edge\"></div>\n        <div class=\"edge\"></div>\n        <div class=\"bevel\">\n            <div class=\"edge\"></div>\n            <div class=\"edge\"></div>\n        </div>\n        <div class=\"inner\">\n            <div class=\"edge\"></div>\n            <div class=\"edge\"></div>\n        </div>\n    </div>\n</div>\n```\n\n```css\n.bevel {\n    width: 250px;\n    height: 250px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 50%;\n    box-sizing: border-box;\n    transform: scale(0.93);\n}\n.bevel .edge {\n    background-color: var(--light-color);\n    box-shadow: none;\n}\n\n.bevel .edge::before,\n.bevel .edge::after {\n    box-shadow: none;\n}\n\n.inner {\n    width: 250px;\n    height: 250px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border-radius: 50%;\n    box-sizing: border-box;\n    transform: scale(0.88);\n}\n\n.inner .edge {\n    background-color: var(--surface-color);\n    box-shadow: none;\n}\n\n.inner .edge::before,\n.inner .edge::after {\n    box-shadow: none;\n}\n```\n\n![](/gallery/moon-3.jpg)\n\n写上文字\n\n```html\n<div class=\"text\">\n    <span>中秋快乐</span>\n</div>\n```\n\n```css\n.text {\n    width: 150px;\n    height: 150px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%) scale(0.9);\n\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    border: 8px solid var(--light-color);\n    border-radius: 40px;\n\n    background-image: linear-gradient(315deg, rgba(211, 129, 18, 1) 0%, rgba(233, 141, 30, 1) 100%);\n}\n\n.text span {\n    font-size: 60px;\n    line-height: 60px;\n    width: 120px;\n    font-family: Helvetica;\n    font-weight: bold;\n    color: var(--light-color);\n}\n```\n\n![](/gallery/moon-4.jpg)\n\n## 添加背景图片\n\n先从网上那个找一张背景图片\n\n![](/gallery/moon-old.jpeg)\n\n使用PS把图上文字P掉加上去\n\n![](/gallery/moon-new.png)\n\n```html\n<img class=\"img\" src=\"img/moon.png\" alt=\"X\">\n```\n\n```css\n.img {\n    display: block;\n    height: auto;\n    max-width: 100%;\n}\n```\n\n 调整下图片的位置，效果图如下\n\n![](/gallery/moon-5.jpg)\n\n## 给月饼添加一个简单的动画\n\n给月饼添加一个旋转的动画\n\n```css\n@keyframes moon {\n    from {transform: rotate(0deg);}\n    to {transform: rotate(360deg);}\n}\n```\n\n## 添加一首音乐\n\n```HTML\n<audio autoplay=\"autoplay\" controls=\"controls\" loop=\"loop\" id=\"bg-music\">\n    <source src=\"audio/但愿人长久-王菲.mp3\" type=\"audio/mpeg\" hidden=\"true\"></source>\n</audio>\n```\n\n搞定了 最终的效果图如下\n\n![](/gallery/moon-6.jpg)\n\n附上源码：https://github.com/GaussYuan191/CSSTest/tree/main/%E6%9C%88%E9%A5%BC\n","categories":["CSS"],"tags":["CSS"]},{"title":"leetcode 刷题","url":"/posts/35458/","content":"\n本篇博客记录每天刷题的记录，每天更新(已更新第十天)。\n\n<!-- more -->\n\n## 第一天\n\n#### [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n\n**示例：**\n\n```html\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n解释：需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n解释：需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n输出：[1]\n解释：需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n```\n\n**暴力解法**\n\n想法很简单直接比较nums1 nums2，小的插到大的前面，然后把最后的元素抛出(因为最后的元素都是0)如果nums1遍历完了就直接把nums2插入就行。\n\n```js\nvar merge = function(nums1, m, nums2, n) {\n    let j = 0;\n    for (let i = 0; i < m + n; i++) {\n        if (nums1[i] > nums2[j]) {\n            nums1.splice(i, 0, nums2[j]);\n            j++;\n            i++;\n            nums1.pop();\n        }\n        if (i - j >= m) {\n            nums1.splice(i, 0, nums2[j]);\n            j++;\n            nums1.pop();\n        }\n    }\n};\n```\n\n**暴击法2**\n\n直接从后开始比较，大的插到最后，直到nums2插完。\n\n```js\nvar merge = function(nums1, m, nums2, n) {\n    let i = m - 1;\n    let j = n - 1;\n    let end = m + n - 1;\n    while(j >= 0) {\n        if (nums1[i] > nums2[j]) {\n            nums1[end] = nums1[i];\n            i--;\n            end--;\n        } else {\n            nums1[end] = nums2[j];\n            j--;\n            end--;\n        }\n    } \n};\n```\n\n## 第二天\n\n#### [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n**示例：**\n\n```js\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**暴力法**\n\n找一个最小值，然后每个值与最小值相减取最大值\n\n```js\n    var maxProfit = function(prices) {\n      const len = prices.length;\n      if (len <= 1) return 0;\n      let min = prices[0], max = 0;\n      for (let i = 0; i < len; i++) {\n        max = Math.max(max, prices[i] - min);\n        min = Math.min(min, prices[i]);\n      }\n }\n```\n\n**动态规划**\n\n```js\n易知每天有两种状态\ndp[i][0] 表示第i天持股能获得最多的利润\ndp[i][1] 表示第i天不持股能获得最多的利润\ni天持股     i天买入股份                         i - 1天持股\n           -prices[i]                        dp[i - 1][0]\ni天不持股   i天卖股份                           i - 1天卖股份 \n   i - 1天持股 + prices[i]                    dp[i - 1][1]\n   \n取最大值，易知不持股的状态的利润大于持股的状态，即答案为dp[len - 1][1]\nvar maxProfit = function(prices) {\n    const len = prices.length;\n    if (len <= 1) return 0;\n    let dp = new Array(len).fill([0, 0]);\n    dp[0][0] = -prices[0];\n    dp[0][1] = 0;\n    for (let i = 1; i < len; i++) {\n        dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n    }\n    return dp[len - 1][1];\n};\n```\n\n## 第三天\n\n#### [字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。\n\n你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。\n\n**示例：**\n\n```js\n输入：num1 = \"11\", num2 = \"123\"\n输出：\"134\"\n输入：num1 = \"456\", num2 = \"77\"\n输出：\"533\"\n输入：num1 = \"0\", num2 = \"0\"\n输出：\"0\"\n```\n\n暴力法\n\n```js\n//每一位进行运行 最后判断是否有进位，然后把结果字符串反向就行了\nvar addStrings = function(num1, num2) {\n  let ans = '', ten = 0, one = 0;\n  let i = num1.length - 1;\n  let j = num2.length - 1;\n  if (num1 == '0') return num2;\n  if (num2 == '0') return num1;\n  if (num1 == '0' && num2 == '0') return num1;\n  while(i >= 0 || j >= 0) {\n    let val1 = num1[i] == undefined ? 0 : num1[i] - '0';\n    let val2 = num2[j] == undefined ? 0 : num2[j] - '0';\n    one = (val1 + val2 + ten ) % 10;\n    ans += one;\n    ten = val1 + val2 + ten - 10 >= 0 ? 1 : 0; \n    i--;\n    j--;\n  }\n  if (ten == 1) {\n    ans += 1;\n  }\n  return ans.split('').reverse().join('');\n};\n// 可稍微优化下\nvar addStrings = function(num1, num2) {\n    var index1 = num1.length - 1;\n    var index2 = num2.length - 1;\n    var res = [];\n    var up = 0;\n    while(index1 >= 0 || index2 >= 0){\n        var n1 = parseInt(index1 >= 0 ? num1[index1] : 0);\n        var n2 = parseInt(index2 >= 0 ? num2[index2] : 0);\n        var sum = n1 + n2 + up;\n        up = sum >= 10 ? 1 : 0;\n        res.unshift(sum % 10);\n        index1--;\n        index2--;\n    }\n    // 最后判断一下进位是否为1，为1则加入到res\n    if(up === 1){\n        res.unshift(1);\n    }\n    return res.join('');\n};\n```\n\n## 第四天\n\n#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例：**\n\n```js\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串\n输入: s = \"\"\n输出: 0\n```\n\n滑动窗口\n\n```js\n//维护一个数组 如果有重复的 就从重复的那里分隔字符串\nvar lengthOfLongestSubstring = function(s) {\n  let maxStr = [];\n  let res = 0;\n  if (s.length == 0) return 0;\n  for (let i = 0; i < s.length; i++) {\n    let index = maxStr.indexOf(s[i]);\n    if (index == -1) {\n      maxStr.push(s[i]);\n    } else {\n      maxStr = maxStr.splice(index + 1);\n      maxStr.push(s[i]);\n    }\n    res = Math.max(res, maxStr.length);\n  }\n  return res;\n};\n```\n\nMap  \n\n```js\n// 用map维护最大字符串的下标的长度，最大长度为下标+1\nvar lengthOfLongestSubstring = function(s) {\n  let map = new Map(),max = 0;\n  for (let i = 0, j = 0; j < s.length; j++) {\n    if (map.has(s[j])) {\n      i = Math.max(map.get(s[j]) + 1, i);\n      console.log(i);\n    }\n    max = Math.max(max, j - i + 1);\n    map.set(s[j], j);\n  }\n  return max;\n};\n```\n\n## 第五天\n\n#### [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)\n\n给你两个版本号 version1 和 version2 ，请你比较它们。\n\n版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。\n\n- 如果 `*version1* > *version2*` 返回 `1`，\n- 如果 `*version1* < *version2*` 返回 `-1`，\n- 除此之外返回 `0`。\n\n**示例：**\n\n```js\n输入：version1 = \"1.01\", version2 = \"1.001\"\n输出：0\n解释：忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n输入：version1 = \"0.1\", version2 = \"1.1\"\n输出：-1\n解释：version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 < 1，所以 version1 < version2\n输入：version1 = \"1.0.1\", version2 = \"1\"\n输出：1\n```\n\nsplit\n\n```js\n// 用split把字符串分割，然后用parseInt比较大小\nvar compareVersion = function(version1, version2) {\n  let ver1 = version1.split('.');\n  let ver2 = version2.split('.');\n  let i = 0, j = 0;\n  while (i < ver1.length || j < ver2.length) {\n     if (i < ver1.length) {\n         ver1[i] = ver1[i++];\n     }\n      if (j < ver2.length) {\n          ver2[j] = ver2[j++];\n      }\n     if (parseInt(ver1[i]) > parseInt(ver2[j])) {\n       return 1;\n     } \n     if (parseInt(ver1[i]) < parseInt(ver2[j])) {\n       return -1;\n     } \n  }\n  return 0;\n\n};\n```\n\n双指针\n\n```js\n// 双指针 碰到. 停止 比较一下\nvar compareVersion = function(version1, version2) {\n    let len1 = version1.length, len2 = version2.length;\n    let i = 0, j = 0;\n    while (i < len1 || j < len2) {\n        let num1 = 0, num2 = 0;\n        while (i < len1 && version1[i] != '.') {\n            num1 += num1 * 10 + version1[i] - '0';\n            i++;\n        }\n        i++;\n        while (j < len2 && version2[j] != '.') {\n            num2 += num2 * 10 + version2[j] - '0';\n            j++;\n        }\n        j++;\n        if (num1 > num2) {\n            return 1;\n        }\n        if (num1 < num2) {\n            return -1;\n        }\n    }\n    return 0;\n};\n```\n\n## 第六天\n\n#### [ 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n**示例：**\n\n```js\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\nMap\n\n```js\n // map 存 nums[i], i 判断target - nums[i] 在不在map中\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    let len = nums.length;\n    for(let i = 0; i < len; i++){\n        if(map.has(target - nums[i])){\n            return [map.get(target - nums[i]), i];\n        }else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n};\n```\n\n## 第七天\n\n#### [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n\n给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**示例：**\n\n```js\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n输入：nums = [1]\n输出：1\n输入：nums = [0]\n输出：0\n```\n\n动态规划\n\n```js\n// dp[i]表示包含i最大的子序列和 取最大值即为答案\n//dp[i] = max(dp[i - 1] + nums[i], nums[i])\nvar maxSubArray = function(nums) {\n  let cnt = nums[0], max = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    cnt = Math.max(cnt + nums[i],  nums[i]);\n    max = Math.max(max, cnt);\n  }\n  return max;\n};\n\n```\n\n详细的过程：https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/\n\n贪心\n\n```js\n // 贪心 如果这个序列 + nums[i] 大于0 则继续相加 否则赋0 更新最大值 \nvar maxSubArray = function(nums) {\n  let len = nums.length, max = 0, res = -100005;\n  for (let i = 0; i < len; i++) {\n     max += nums[i];\n     if (max > res) {\n        res = max;\n     }\n     if (max < 0) max = 0;\n  }\n  return res;\n  \n};\n```\n\n## 第八天\n\n#### [全排列](https://leetcode-cn.com/problems/permutations/)\n\n给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。\n\n**示例：**\n\n```js\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n输入：nums = [1]\n输出：[[1]]\n```\n\n回溯法，如果对回溯法不了解的同学可以看下\n\nhttps://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC\n\n```js\nvar permute = function(nums) {\n  let res = [], path = [];\n  backtracking(nums, nums.length, []);\n  return res;\n  function backtracking(n, k, used) {\n    // 设置出口\n    if (path.length == k) {\n      res.push(Array.from(path));\n      return;\n    }\n      //横向遍历\n    for (let i = 0; i < k; i++) {\n      if (used[i]) continue;\n      path.push(n[i]);\n      used[i] = true;\n      backtracking(n, k, used);  //纵向遍历\n      path.pop();                //回溯\n      used[i] = false;\n    }\n  }\n};\n```\n\n#### [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)\n\n给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。\n\n**示例：**\n\n```js\n输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n[1,2,1],\n[2,1,1]]\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n回溯+剪枝\n\n```js\nvar permuteUnique = function(nums) {\n    let res = [], path = [];\n    nums.sort();\n    backtracking(nums, nums.length, []);\n    return res;\n    function backtracking(n, k, used) {\n        // 设置出口\n        if (path.length == k) {\n            res.push(Array.from(path));\n            return;\n        }\n        for (let i = 0; i < k; i++) {\n            // used[i - 1] = false为树剪枝 used[i - 1] = true 为层剪枝\n            if (nums[i] == nums[i - 1]&& used[i - 1] == false) {\n                continue;\n            }\n            if (!used[i]) {\n                path.push(n[i]);\n                used[i] = true;\n                backtracking(n, k, used);\n                path.pop();\n                used[i] = false;\n            }\n        }\n    }\n};\n```\n\n## 第九天\n\n假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 *n* 是一个正整数。\n\n**示例：**\n\n```js\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n```\n\n动态规划\n\n```js\n//f(x)=f(x−1)+f(x−2)\nvar climbStairs = function(n) {\n  let dp1 = 1, dp2 = 2, dp3 = 0;\n  if (n <= 2) return n;\n  for (let i = 2; i < n; i++) {\n    dp3 = dp1 + dp2;\n    dp1 = dp2;\n    dp2 = dp3; \n  }\n  return dp3;\n};\n```\n\n~~**矩阵快速幂**~~\n\n具体解答可看\n\nhttps://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/\n\nhttps://www.cnblogs.com/cmmdc/p/6936196.html\n\n```js\nvar climbStairs = function(n) {\n    const q = [[1, 1], [1, 0]];\n    const res = pow(q, n);\n    return res[0][0];\n};\n\nconst pow = (a, n) => {\n    let ret = [[1, 0], [0, 1]];\n    while (n > 0) {\n        if ((n & 1) === 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nconst multiply = (a, b) => {\n    const c = new Array(2).fill(0).map(() => new Array(2).fill(0));\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n        }\n    }\n    return c;\n}\n```\n\n## 第十天\n\n#### [ 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例：**\n\n```js\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n输入：head = [1,2]\n输出：[2,1]\n```\n\n栈\n\n```js\n// 先存到栈中 在建一个新的链表\nvar reverseList = function(head) {\n    let stack = [], p = head, i = 0, tail, nhead = new ListNode(-1);\n    let len = 0;\n    while (p) {\n        stack.push(p.val);\n        p = p.next;\n    }\n    tail = nhead;\n    len = stack.length;\n    while (i < len) {\n        p = new ListNode(stack.pop());\n        tail.next = p;\n        tail = tail.next;\n        i++;\n    }\n    return nhead.next;\n\n};\n```\n\n链表头插法\n\n```js\nvar reverseList = function(head) {\n    let p = head, pnew, nhead = null;\n    while (p) {\n        pnew = new ListNode(p.val);\n        if (!nhead) {\n            nhead = pnew;\n            p = p.next;\n            continue;\n        }\n        pnew.next = nhead;\n        nhead = pnew;\n        p = p.next;\n    } \n    return nhead;\n};\n```\n\n### 第十一天\n\n#### [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n\n**示例：**\n\n```js\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n```\n\n快排的思想\n\n```js\n//，随机选取数组中的数，把数组分成大于这个数的和小于这个数的,求一下比它大的数组的长度就这个该数在数组中的大小了\nvar findKthLargest = function(nums, k) {\n    function findK(nums, k){\n        let right = [],left = [], mid = Math.floor(Math.random()*nums.length),cnt = 0;\n        cnt = nums[mid];\n        nums.splice(mid, 1);\n        for (let i = 0; i < nums.length; i++) {\n            if (nums[i] > cnt) {\n                right.push(nums[i]);\n            } else {\n                left.push(nums[i]);\n            }\n        }\n        //  console.log(k, cnt, left, right, nums);\n        if (right.length == k - 1) return cnt;\n        else if (right.length > k - 1) return findK(right\n                                                    , k);\n        else return findK(left, k - right.length - 1);\n\n    }\n    let res = findK(nums, k);\n    return res;\t\n};\n```\n\n### 第十二天\n\n#### [ 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n**示例：**\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n快慢指针\n\n```js\n//快指针走两步，慢指针走一步 ，如果快慢指针相遇则证明有环\nvar hasCycle = function(head) {\n    let fast = head, slow = head;\n    if (head == null) return false;\n    while (fast) {\n        if (fast.next == null)  return false;\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast ) return true;\n    }\n    return false;\n};\n```\n\n### 第十三天\n\n#### [求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n**示例：**\n\n```js\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n```\n\n```js\n//dfs\nvar sumNumbers = function(root) {\n    const getValue = (node, sum) => {\n        if (node == null) return 0;\n        let nsum = sum * 10 + node.val;\n        if (node.left == null && node.right == null) {\n            return nsum;\n        } else {\n            return getValue(node.left, nsum) + getValue(node.right, nsum);\n        }\n    }\n    return getValue(root, 0);\n};\n```\n\n### 第十四天\n\n#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n**示例：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n```js\n//动态规划     \nvar longestPalindrome = function(s) {\n      const len = s.length;\n      if (len == 1) return s;\n      if (len == 2) return s[0] == s[1] ? s : s[0];\n      let dp = Array(len).fill().map(() => Array(len).fill(0));\n      let maxlen = 1, st = 0;\n      for (let i = 0; i < len; i++) {\n        dp[i][i] = 1;\n      }\n      for (let i = 2; i <= len; i++) {\n        for (let j =  0; j + i <= len; j++) {\n          let t = i + j - 1;\n          if (s[j] != s[t]) continue;\n          if (i > 2 && !dp[j + 1][t - 1]) continue;\n          dp[j][t] = 1;\n          maxlen = i;\n          st = j;\n        }\n      }\n      return s.slice(st, maxlen + st);\n    };\n```\n\n### 第十五天\n\n#### [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n**示例：**\n\n![](/gallery/Xnip2021-11-21_21-50-56.jpg)\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n```\n\n```\n// 双指针法 从较矮的一端开始移动\nvar maxArea = function(height) {\n  let max = 0, l = 0, r = height.length - 1;\n  while (l < r) {\n    let maxVal = Math.min(height[l], height[r]) * (r - l);\n    max = Math.max(max, maxVal);\n    if (height[l] < height[r]) l++;\n    else r--;\n  }\n  return max;\n};\n```\n\n### 第十六天\n\n#### [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![](/gallery/Xnip2021-11-23_22-13-12.jpg)\n\n```js\n输入：digits = \"23\"\n输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n输入：digits = \"\"\n输出：[]\n```\n\n```js\n//递归 回溯法\nvar letterCombinations = function(digits) {\n  let res= [];\n  if (digits == null) return res;\n  let map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n  const dfs = (cur, t) => {\n    if (cur == digits.length) {\n      res.push(t);\n      return;\n    }\n    let index = digits[cur] - '0' - 2;\n    for (let c of map[index]) {\n      dfs(cur + 1, t + c);\n    }\n\n  };\n  dfs(0, \"\");\n  return res;\n};\n//bfs 层次遍历\nvar letterCombinations = function(digits) {\n  let res = [];\n  if (digits.length == 0) return res;\n  let map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n  res.push('');\n  for (let i = 0; i < digits.length; i++) {\n    const levelSize = res.length;\n    for (let j = 0; j < levelSize; j++) {\n      const curStr = res.shift();\n      console.log(curStr);\n      const letters = map[digits[i] - '2'];\n      for (const l of letters) {\n        res.push(curStr + l);\n      }\n    }\n  }\n  return res;\n};\n```\n\n### 十七天\n\n#### [最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。\n\n**示例：**\n\n```js\n输入：\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n输出：3\n解释：\n长度最长的公共子数组是 [3, 2, 1] 。\n```\n\n```js\n// 方法1 滑动窗口 时间复杂度（m + n) * min (m, n);\nvar findLength = function(nums1, nums2) {\n    const maxLen = (arr1, i, arr2, j, len) => {\n        let count = 0, max = 0;\n        for (let k = 0; k < len; k++) {\n            if (arr1[i + k] == arr2[j + k]) {\n                count++;\n            } else {\n                count = 0;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n   \n    let res = 0;\n    let m = nums1.length, n = nums2.length;\n    for (let i = 0; i < m; i++) {\n        let len = Math.min(n, m - i);\n        let max = maxLen(nums1, i, nums2, 0, len);\n        res = Math.max(res, max);\n    }\n    for (let i = 0; i < n; i++) {\n        let len = Math.min(m, n - i);\n        let max = maxLen(nums1, 0, nums2, i, len);\n        res = Math.max(max, res);\n\n    }\n    return res;\n\n    \n};\n```\n\n![](/gallery/最长重复字串.gif)\n\n```js\n// dp[i]][j] 表示以[i][j] 结尾的最长重复字串的长度\n// 从后往前遍历 dp[i][j] 由dp[i + 1][j + 1] 决定的\nvar findLength = function(nums1, nums2) {\n    let m = nums1.length, n = nums2.length;\n    let dp = Array.from({length: m + 1}).map(item => new Array(n + 1).fill(0));\n    let res = 0;\n    for (let i = m - 1 ; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            dp[i][j] = nums1[i] === nums2[j] ? dp[i + 1][j + 1] + 1 : 0;\n            res = Math.max(res, dp[i][j]);\n        }\n    }\n    return res;\n};\n```\n\n## 十八天\n\n#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n**示例**：\n\n```js\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n输入：target = 4, nums = [1,4,4]\n输出：1\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n```js\n// 暴力法 n^2 遍历i, j\nvar minSubArrayLen = function(target, nums) {\n    let res = Number.MAX_VALUE;\n    for (let i = 0; i < nums.length; i++) {\n        let sum = 0;\n        for (let j = i; j < nums.length; j++) {\n            sum += nums[j];\n            if (sum >= target) {\n                res = Math.min(res, j - i + 1);\n            }\n        }\n    }\n    return res == Number.MAX_VALUE ? 0 : res;\n};\n// 滑动窗口\nvar minSubArrayLen = function(target, nums) {\n    let n = nums.length;\n    if (n == 0) return 0;\n    let ans = Number.MAX_VALUE;\n    let start = 0, end = 0, sum = 0;\n    while (end < n) {\n        sum += nums[end];\n        while (sum >= target) {\n            ans = Math.min(ans, end- start + 1);\n            sum -= nums[start];\n            start++;\n        }\n        end++;\n    }\n    return ans == Number.MAX_VALUE ? 0 : ans;\n};\n```\n\n## 十九天\n\n#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n![](/gallery/letcode-160.png)\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n注意，相等不是数值相等，而是地址相等\n\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) return null;\n    let pA = headA, pB = headB;\n    while (pA  != pB) {\n        pA = pA != null ? pA.next : headB;\n        pB = pB != null ? pB.next : headA;\n    }\n    return pA;\n};\n```\n\n# 二十天\n\n#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n **示例：**\n\n```js\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n```js\n// 暴力法： 直接遍历每个下标\nvar minSubArrayLen = function(target, nums) {\n    let res = Number.MAX_VALUE;\n    for (let i = 0; i < nums.length; i++) {\n        let sum = 0;\n        for (let j = i; j < nums.length; j++) {\n            sum += nums[j];\n            if (sum >= target) {\n                res = Math.min(res, j - i + 1);\n            }\n        }\n    }\n    return res == Number.MAX_VALUE ? 0 : res;\n};\n// 滑动数组 找到一个满足条件的数组 然后缩短它的边界\nvar minSubArrayLen = function(target, nums) {\n    let n = nums.length;\n    if (n == 0) return 0;\n    let ans = Number.MAX_VALUE;\n    let start = 0, end = 0, sum = 0;\n    while (end < n) {\n        sum += nums[end];\n        while (sum >= target) {\n            ans = Math.min(ans, end- start + 1);\n            sum -= nums[start];\n            start++;\n        }\n        end++;\n    }\n    return ans == Number.MAX_VALUE ? 0 : ans;\n};\n```\n\n#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\npush(x) —— 将元素 x 推入栈中。\npop() —— 删除栈顶的元素。\ntop() —— 获取栈顶元素。\ngetMin() —— 检索栈中的最小元素。\n\n**示例：**\n\n```js\n输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> 返回 -3.\nminStack.pop();\nminStack.top();      --> 返回 0.\nminStack.getMin();   --> 返回 -2.\n```\n\n```js\n// 辅助栈 另一个栈来存最小的\n\nvar MinStack = function() {\n    this.res = [];\n    this.min = [Number.MAX_VALUE];\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    const item = this.min[this.min.length - 1];\n    if (item > val) {\n        this.min.push(val);\n    } else {\n        this.min.push(item);\n    }\n    this.res.push(val);\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    this.res.pop();\n    this.min.pop();\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    return this.res[this.res.length - 1];\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    return this.min[this.min.length - 1];\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\n\n// 不用额外的空间，栈中存的进栈值与最小值的差值 \nvar MinStack = function() {\n    this.min = Number.MAX_VALUE;\n    this.res = [];\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n    const minV = this.min;\n    if (val < minV) {\n        // 更新最小值\n        this.min = val;\n    }\n    // 保存最小值\n    this.res.push(val - minV);\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n    const item = this.res.pop();\n    // 如果最栈顶的值是大于0，则不会影响最小值，如果大于0 ，最小值 - 减去差值\n    if (item < 0) {\n        this.min = this.min - item;\n    }  // 返回差值+最小值\n    return item + this.min;\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n    const lastValue = this.res[this.res.length - 1];\n    // 如果栈顶小于0，则返回最小值\n    return lastValue > 0 ? this.min + lastValue : this.min;\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n    return this.min;\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\n```\n\n# 二十一天\n\n#### [ K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n进阶：\n\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n```js\n// 将k个一组的反转链表的问题分解为n个反转链表的子问题\nvar reverseKGroup = function(head, k) {\n    // 反转链表函数\n    var reversList = function(a, b) {\n        // 反转区间a, b上的节点\n       \n        let pre, cur, nxt;\n        pre = null;\n        cur = a; //用于循环\n        nxt = a;\n        // 进行的操作是每次循环将cur->pre, 注意b的方向没有改变\n        while (cur != b) {\n            // 保存a的下一个的值next\n            nxt = cur.next;\n            // 将cur指向上一个值的pre（反转指向）\n            cur.next = pre;\n            // 将pre 赋予当前值，当做下次循环的pre\n            pre = cur;\n            cur = nxt;\n        }\n        // pre 相当于 从后遍历到头，所有循环结束后，pre指向头节点\n        \n        return pre;\n    }\n    if (!head) {\n        return null;\n    }\n    let a = head;\n    let b = head;\n    // 判断区间a,b可以分为多少个长度为k的子区间\n    for (let i = 0; i < k; i++) {\n        // 剩余的节点不足k个，反转结束\n        if (b == null) {\n            return head;\n        } else {\n            b = b.next;\n        }\n        \n    }\n    // 反转前k个元素\n        let newHead = reversList(a, b);\n        a.next = reverseKGroup(b, k);\n        return newHead;\n};\n```\n\n# 二十二天\n\n#### [ 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n**示例**\n\n![](/gallery/minimun-path-sum.png)\n\n```js\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n```js\n// 简单的一道dp题 和之前走楼梯的思路差不多，不过这里dp[i][j]存的是从左或者从上来的最小值加上本身的数字\n\n// dp[i][j] 表示到达i, j 所走的最短路径\n // dp[i][j] = Math.min(dp[i - 1][j], grid[i][j] ) +  + dp[i][j - 1]\nvar minPathSum = function(grid) {\n    if (grid == null || grid.length == null || grid[0].length == null) return 0;\n    let m = grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0).map(item => new Array(n).fill(0));\n    dp[0][0] = grid[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] =  grid[0][i] + dp[0][i - 1];\n    }\n    for (let j = 1; j < m; j++) {\n        dp[j][0] = grid[j][0] + dp[j - 1][0];\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n};\n// 压缩状态 压缩列\nvar minPathSum = function(grid) {\n    if (grid == null || grid.length == null || grid[0].length == null) return 0;\n    let m = grid.length, n = grid[0].length;\n    let dp = new Array(m).fill(0).map(item => new Array(n).fill(0));\n    // dp[j] = dp[i - 1][j];\n    // dp[j - 1] = dp[i][j - 1]\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[j] = grid[i][j]\n            }\n            else if (j == 0) {\n                dp[j] = dp[j] + grid[i][j];\n            }\n            else if (i == 0) {\n                dp[j] = dp[j - 1] + grid[i][j];\n            } else {\n                dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];\n            }\n            \n        }\n    }\n    return dp[n - 1];\n};\n```\n\n# 二十三天\n\n#### [翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)\n\n给你一个字符串 s ，逐个翻转字符串中的所有 单词 。\n\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n\n请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。\n\n说明：\n\n输入字符串 s 可以在前面、后面或者单词间包含多余的空格。\n翻转后单词间应当仅用一个空格分隔。\n翻转后的字符串中不应包含额外的空格。\n\n**示例：**\n\n```js\n输入：s = \"the sky is blue\"\n输出：\"blue is sky the\"\n输入：s = \"  hello world  \"\n输出：\"world hello\"\n解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。\n```\n\n```js\n// 利用api trim去除字符串两端的空格， split以一个或多个空格(\\s)分隔， reverse()反转， join(\" \") \n// 以空格分开\nvar reverseWords = function(s) {\n    return s.trim().split(/\\s+/).reverse().join(\" \")\n};\n// 利用双端队列 找出单词，然后连接\nvar reverseWords = function(s) {\n    let left = 0, right = s.length - 1;\n  let ans = [], word = \"\"\n  while (s.charAt(left) == \" \") left++;\n  while (s.charAt(right) == \" \") right--;\n  while (left <= right) {\n    let char = s.charAt(left);\n    if (char == \" \" && word) {\n      ans.unshift(word);\n      word = \"\"\n    } else if (char != \" \") {\n      word += char;\n    }\n    left++;\n  }\n  ans.unshift(word)\n  return ans.join(\" \");\n};\n\n```\n\n# 二十四天\n\n#### [二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n**示例**\n\n![](/gallery/zigzagLevelOrder.png)\n\n```\n输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[20,9],[15,7]]\n```\n\n```js\n// 层次遍历， 如果是奇数次，则往前插入数据，偶数则往尾部插入\nvar zigzagLevelOrder = function(root) {\n    if (root == null) return [];\n    let res = [], queue = [], times = 0;\n    queue.push(root);\n    let bfs = (root) => {\n        while (queue.length) {\n            let arr = [];\n            let len = queue.length\n            for (let i = 0; i < len; i++) {\n                let node = queue.shift();\n                node.left && queue.push(node.left)\n                node.right && queue.push(node.right)\n                if (times & 1 == 1) {\n                    arr.unshift(node.val)\n                } else {\n                    arr.push(node.val);  \n                }\n                           \n            }\n            res.push(arr);\n            times++;          \n        }\n    }\n    bfs(root);\n    return res;\n\n};\n```\n\n# 二十五天\n\n#### [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n**示例**\n\n```js\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2]\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[9,4]\n```\n\n```js\n// 利用set去重， 从数量少的集合中找， 时间复杂度O(n + m),使用set存数据的时间复杂度为O(n + m),查找）O(min(m, n));\nvar intersection = function(nums1, nums2) {\n    let set1 = new Set(nums1);\n    let set2 = new Set(nums2);\n    const dealResult = (set1, set2) => {\n        let ans = [];\n        for (let s of set1) {\n            if (set2.has(s)) {\n                ans.push(s);\n            }\n        }\n        return ans;\n    }\n    return set1.size > set2.size ? dealResult(set2, set1) : dealResult(set1, set2);\n};\n// 双指针，时间复杂度O(mlogm + nlogn)\nvar intersection = function(nums1, nums2) {\n    if (nums1 == null) return nums2;\n    if (nums2 == null) return nums1;\n    nums1.sort((a, b) => a - b);\n    nums2.sort((a, b) => a - b);\n    let i = 0, j = 0, res = [];\n    while (i < nums1.length && j < nums2.length) {\n        if (nums1[i] < nums2[j]) {\n            i++;\n        } else if (nums1[i] > nums2[j]) {\n            j++;\n        } else {\n            res.push(nums1[i]);\n            i++;\n            j++;\n        }\n    }\n    return Array.from(new Set(res));\n};\n```\n\n#### [旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n\n**示例**\n\n![](/gallery/rotate-image.png)\n\n```\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n```\n\n```js\n// 先上下翻转 在对角翻转\nvar rotate = function(matrix) {\n    let n = matrix.length;\n    // 水平翻转\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = 0; j < n; j++) {\n            [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];\n        }\n    }\n    // 对角线翻转\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n    return matrix;\n};\n```\n\n# 二十六天\n\n#### [54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)\n\n给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。\n\n**示例 1:**\n\n```js\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 4\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 4\n```\n\n```js\n// 易知，二叉排序树的中序遍历是从小到到大已经排好序的\n// 递归 逆中序遍历， 先遍历右节点再遍历根节点，最后遍历左节点\n// O(n) O(n)\nvar kthLargest = function(root, k) {\n    let res = 0;\n    const dfs = (node) => {\n        if (node === null) return;\n        dfs(node.right) \n        if (--k  === 0 ) {\n            res = node.val;\n            return;\n        }\n        dfs(node.left);\n    }\n    dfs(root);\n    return res;\n};\n// 莫里斯遍历，其实就是树形结构的扁平化，逆莫里斯遍历就能得到答案了\n// 正序莫里斯遍历\nlet res = []\nconst morris = (root) => {\n    if (root === null) return;\n    // 先判断该节点有没有左儿子\n    while (root) {\n        if (root.left) {\n            //如果有，就找左儿子的最右边的孩子pre，其实就是中序遍历该节点的前一个节点\n            let pre = root.left;\n            // 注意这里该节点的右节点不能指向自己\n            while (pre.right && pre.right != root) {\n                pre = pre.right;\n            }  \n            // 再看pre有没有右孩子\n            if (pre.right == null) {\n                //如果没有，则pre的right指向root, root指向root的左孩子\n                pre.right == root;\n                root = root.left;\n            } else {\n                // 如果有，就说明，这个节点之前已经遍历过了，它的左边已经遍历完了，pre的right设为null\n                // 此时root就是我们要找的元素， root向右移动\n                pre.right = null;\n                // 这里处理结果\n                // 例如\n                res.push(root.val);\n                root = root.right;\n            }\n            \n        } else {\n            // 没有，此时root元素就是我们要找的元素，root向右移动\n            // 处理结果\n            res.push(root.val)\n            root = root.right;\n        }\n    }\n    // res中保留着中序遍历的结果\n    return res;\n}\n// 逆莫里斯遍历\nconst morris = (node) => {\n       while (node) {\n\n            if (node.right) {\n                let pre = node.right;\n                // 找左儿子的最右端\n                while (pre.left && pre.left != node) {\n                    pre = pre.left;\n                }\n                if (pre.left == null) {\n                    pre.left = node;\n                    node = node.right;\n                } else {\n                    pre.left = null;\n                    k--;\n                    node = node.left;\n                }\n            } else {\n                node = node.left;\n                k--;\n            }\n            if (k === 0) {\n                res = node.val;\n                return;\n            }\n        }\n\n\n}\n// 利用栈实现迭代遍历\nif (root === null) return;\nlet stack = [];\nlet ans = [];\nwhile (root || stack.length != 0) {\n    // 左节点\n    while (root) {\n        stack.push(root);\n        root = root.left;\n    }\n    root = stack.pop()\n    // 根节点\n    ans.push(root.val);\n    root = root.right;\n}\t\n```\n\n","categories":["刷题"],"tags":["刷题"]},{"title":"前端简历该怎么写","url":"/posts/49802/","content":"\n秋招马上快来了，今天我们来思考下web前端的简历到底该怎么写，好的简历是一块大厂的敲门砖。\n\n<!-- more -->\n\n## 大厂招聘的要求\n\n1.字节跳动web前端开发\n\n```\n1. 本科学历及以上，计算机相关专业在读生\n2. 计算机基础扎实，熟悉掌握Javascript，ES5/6，CSS，熟练掌握各种布局\n3. 了解常见的前端技术栈和工具（如Vue、React、Chrome调试工具等）\n4. 具备较强的学习能力、较好的协作沟通能力，自驱力好\n5. 有跨端开发经验（Weex/React Naitve/Flutter等）优先\n6. 有过其他相关实习经历优先\n```\n\n2.阿里巴巴web前端开发\n\n```html\n我们希望你，可以熟练使用各种Web前端技术，包括HTML(5)/CSS(3)/Javascript等，并有相关的项目开发经验或成果；\n我们希望你，熟悉前端工程化，用过git，gulp或webpack等工具，最好有自己的github仓库；\n我们希望你，有基于Ajax应用的开发经验，有NodeJS/Java开发经验，或者有移动端开发经验；\n我们希望你，深刻理解Web标准，对可用性、可访问性等相关知识有实际的了解；\n我们希望你，对算法、数据结构、建模有一定了解；\n还等什么呢？快来加入我们，期待你的大展身手！\n同时，我们还希望你：\n1. 学习能力强，对新事物保有好奇心，并能快速适应新环境\n2. 良好的沟通能力和团队协同能力；能与他人合作，共同完成目标\n3. 对所在领域有热情，相信方法总比困难多，善于独立思考并反思总结\n```\n\n3.腾讯web前端开发\n\n```html\n22届毕业生，计算机或相关专业，基础扎实，熟悉常用的数据结构和算法；\n熟悉Javasript/HTML/CSS等前端开发技术，使用过至少一款当下主流的前端框架(react/vue/angular等)；\n熟悉Web应用系统开发，对HTTP、TCP/IP协议及WEB服务器等有所理解；拥有良好的安全意识，熟悉常见的网络安全攻防策略；\n熟悉至少一门后台开发语言，有Node.js/PHP开发经验优先；\n具有较强的沟通能力与团队合作精神，具有良好的分析问题、解决问题的能力以及较强的学习能力\n```\n\n4.京东web前端开发\n\n```html\n1-2021年10月1日至2022年9月30日期间毕业，统招本科及以上学历；\n2-扎实的计算机基础，熟悉数据结构并能熟练使用相关知识解决问题；\n3-HTML, CSS, JavaScript基础扎实, 熟悉ES6，TypeScript和面向对象编程；\n4-对前端开发有持续热情，良好的团队写作能力，能独立完成开发工作，做事认证负责，追求高质量的代码交付；\n5-具有良好的沟通协作能力，优秀的分析问题和解决问题的能力；\n6-项目经验要求：熟悉前端工程化和模块化开发，掌握并能熟练应用至少一种前端开发框架进行页面以及组件开发，包括且不限于React, Vue。\n```\n\n5.小米web前端开发 \n\n```html\n1、计算机相关专业本科及以上学历，具备扎实的计算机理论基础；\n2、具备基本的HTML、CSS及JavaScript等Web前端技术；\n3、了解至少一种Server端语言（Node、js/PHP/Python/Java等）；\n4、具备扎实的计算机基础，对数据结构和算法设计有充分理解；\n5、有强烈的上进心，自我驱动，学习适应能力强，乐观自信，能挑战自我不断追求卓越；\n6、有强烈的责任心和团队精神，善于沟通和合作。\n```\n\n6.米哈游web前端开发\n\n```html\n岗位要求：\n1.计算机或相关专业；\n2.深刻理解计算机原理、数据结构、常用算法和常见设计模式；\n3.熟悉ES6/CSS3/HTML5 等基础语法和开发调试技术，熟悉Vue或者React框架；\n4.对创建前端UI有强烈的兴趣和成就感；\n5.有WEB类实战开发经验可加分；\n```\n\n7.美团web前端开发\n\n```html\n1.热爱前端（移动端）开发，对使用自己代码直接服务亿万用户着迷；或者是技术极客，对写出完美代码有执着者；\n2.有前端领域开发经验，能独立完成基础的前端开发工作；\n3.熟悉W3C标准与ES规范，熟悉Web语义化和相关前端技术；\n4.熟悉至少一种JavaScript前端框架或者具有小型专项JavaScript框架的开发经验；或具有Node项目开发经验；\n5.掌握至少一门其他开发语言（如C/C++/Go/Rust/Java/Python/Ruby/Dart等），并有一定的实践经验。\n```\n\n## 要求总结\n\n```html\n基本要求:本科学历以上，计算机相关专业\n基础知识:计算机基础扎实、熟悉常用的数据结构和算法、计算机网络、设计模式\n基本技术要求:熟息掌握HTML、CSS、JavaScript，熟练各种布局\n框架:熟息Vue、React、Angular，熟悉组件开发，熟息一个UI常用的框架\n请求:用过axios\n有跨端开发的经验:了解week、React Naitve、Flutter\n开发工具: 用过Git、gulp、webpack等工具，有自己的GitHub仓库\n服务端:熟息一种后台语言，Node.js、PHP\n加分项:熟悉Typescript、es6、熟悉网络安全，能够优化页面\n个人能力:热爱前端，学习能力强，对新事物保持有好奇心，并能快速适应新环境，良好的团队沟通能力和团队协作能力，善于独立思考并反思总结，做事认真负责，最求高质量代码\n```\n\n所有我们要结合自己的能力和公司的要求编写自己的简历，把重点和自己的突出点写在前面，不太重要的写在后面。\n\n## 项目该怎么写\n\n相信大家在面试的时候都会被问到一个问题\"你的项目有什么亮点或你在项目中最自豪的地方是什么\"\n\n这个问题在知乎上有好的解答\n\nhttps://www.zhihu.com/question/23150301\n\n","categories":["简历"],"tags":["简历"]},{"title":"面试中可能会问到的基础","url":"/posts/7446/","content":"\n总结一下面试中可能会问到的基础知识\n\n<!-- more -->\n\n1 js中常见的数据结构与算法\n\n**js的数据结构：**\n\n```html\n1、数组（Array）\n2、栈（Stack）\n3、队列（Queue）\n4、链表（Linked List）\n5、树（Tree）\n6、图（Graph）\n7、堆（Heap）\n8、散列表（Hash）\n```\n\n**算法：**\n\n**1.字符串回文：字符串倒序**\n\n```js\nlet a=\"sasdfghjkl\"\nfunction changeStr(){\n    return a.split(\"\").reverse().join(\"\");\n}\n\n```\n\n**2.数组去重**\n\n```js\n1) 利用对象key值的唯一性\nlet a=[1,3,3,3,1,2,6,4,5,6]\nfunction changes(){\n    let obj={};\n    let arr=[];\n    for(let i in a){\n        if(!obj[a[i]]){\n            arr.push(a[i]);\n            obj[a[i]]=true;\n        }\n    }\n    return arr\n}\n\n\n2）利用es6 new Set\nfunction changes(){\n    return Array.from(new Set(a))\n}\n\n```\n\n**3.统计字符串出现最多的字母**\n\n```js\nlet a='gffhghjllyesdfffnmfffssssffffjjffff'\nfunction changes(){\n    let obj={}\n    for(let i in a){\n        if(!obj[a[i]]){\n            obj[a[i]]=1;\n        }else{\n            obj[a[i]]++;\n        }\n    }\n    let max=0;\n    let maxStr\n    for(let i in obj){\n        if(obj[i]>max){\n            max=obj[i];\n            maxStr=i;\n        }\n    }\n    return maxStr\n}\n\n```\n\n**4. 排序算法**\n\n```js\n冒泡排序：纯数组，数组对象\nlet a = [4,6,32,11,5,667,39,56,78,2,42,7];\nlet ob=[\n    {age:11},\n    {age:21},\n    {age:8},\n    {age:7}\n];\nfunction changes(){\n    a.sort(function(a,b){\n        return a-b\n    })\n    ob.sort(function(a,b){\n        return a.age-b.age\n    })\n    return ob\n}\n\n```\n\n**5.数组查重**\n\n```js\nlet a = [4,6,32,6,5,6,5];\nfunction changes(){\n    let obj={};\n    for(let i in a){\n        if(!obj[a[i]]){\n            obj[a[i]]=\"0\";\n        }else{\n            obj[a[i]]=Number(obj[a[i]])+1+''\n        }\n    }\n    let n=0;\n    for(let i in obj){\n        if(obj[i]>=n){\n            n=obj[i];\n        }\n    }\n\n    let str=\"\"\n    for(let i in obj){\n        if(obj[i]==n){\n            str=str+i+\" \";\n        }\n    }\n    return str;\n}\n\n```\n\n7.**经典排序问题**\n\n这个问题附上博客地址\n\nhttps://www.cnblogs.com/ybygb-geng/p/9355425.html\n\n2 计算机网络的基础知识\n\n附上地址\n\nhttps://www.runoob.com/w3cnote/summary-of-network.html\n\n3 Vue 、 elementui、uni-app等前端框架的基本知识\n\n4 Git的使用\n\n```shell\nmkdir test\ncd test\ngit init\ntouch README.md\ngit add README.md\ngit commit -m \"first commit\"\ngit remote add origin git@gitee.com:mohuani/test.git\ngit push -u origin master\n```\n\n5 webpack 怎么创建项目 怎么打包\n\n```shell\nvue create vue-cli-project  //创建\nnpm insatll  //安装依赖\nnpm run dev  //启动项目\nnpm run build  //打包项目\n```\n\n6 Vue-router 基础\n\n附上地址\n\nhttps://blog.csdn.net/pengjunlee/article/details/97787117\n\nhttps://www.cnblogs.com/SamWeb/p/6610733.html\n\n7 axios 基础\n\n附上地址\n\nhttps://www.cnblogs.com/nanhuaqiushui/p/10514122.html\n\n8 Vue的组件基础\n\n附上地址\n\nhttps://cn.vuejs.org/v2/guide/components.html\n\n9 Vue的生命周期\n\n附上地址\n\nhttps://www.jianshu.com/p/672e967e201c/\n\n10 vuex基础\n\n附上地址\n\nhttps://www.cnblogs.com/wazy999/p/12563196.html\n\n11 node.js基础-创建TCP服务器、创建接口\n\nTCP服务器\n\nhttps://blog.csdn.net/sctec/article/details/78966209\n\n创建接口\n\nhttps://www.cnblogs.com/yiyangl/p/10307485.html\n\n12 css伪类和伪元素的区别\n\n附上地址\n\nhttps://segmentfault.com/a/1190000000484493 \n\n13 flex布局\n\nhttps://www.cnblogs.com/echolun/p/11299460.html\n","categories":["面试"],"tags":["基础"]},{"title":"超详细 TCP 三次握手四次挥手","url":"/posts/39625/","content":"\n- 三次握手过程理解\n- 四次挥手过程理解\n- 常见面试题\n\n<!-- more -->\n\n先来张图\n\n![图片](/gallery/http-data.jpg)\n\n**序列号seq：** 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。\n\n**确认号ack：** 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。\n\n**确认ACK：** 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效\n\n**同步SYN：** 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。\n\n**终止FIN：** 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接\n\n**PS：** ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。\n\n| 字段 | 含义                                                         |\n| :--- | :----------------------------------------------------------- |\n| URG  | 紧急指针是否有效。为1，表示某一位需要被优先处理              |\n| ACK  | 确认号是否有效，一般置为1。                                  |\n| PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走。                |\n| RST  | 对方要求重新建立连接，复位。                                 |\n| SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 |\n| FIN  | 希望断开连接。                                               |\n\n# 三次握手过程理解\n\n![图片](/gallery/http-3.jpg)\n\n**第一次握手：** 建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n\n**第二次握手：** 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n\n**第三次握手：** 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n# 四次挥手过程理解\n\n![图片](/gallery/http-4.jpg)\n\n1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n\n2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。\n\n3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。\n\n4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n\n5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n\n6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n\n# 常见面试题\n\n**为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n\n答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n\n**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**\n\n答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。\n\n**为什么不能用两次握手进行连接？**\n\n答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。\n\n现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。\n\n**如果已经建立了连接，但是客户端突然出现故障了怎么办？**\n\n答：TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n","categories":["网络"],"tags":["TCP"]},{"title":"数据结构之栈 Stack 和队列 Queue","url":"/posts/3164/","content":"\n栈（Stack）和队列（Queue），了解栈和队列的基础知识，学习它们的基础应用。\n\n<!-- more -->\n\n# 栈Stack\n\n栈Stack是一种线性结构，是线性表的一种具体形式。栈这种后进先出（Last In First Out，LIFO）的应用非常广泛，例如网页的前进后退功能，编辑器的后一步前一步功能，方法调用时的函数栈等等。\n\n栈Stack的特性：\n- 栈的元素必须“后进先出”\n- 栈的操作只能于线性表表尾进行\n- 栈的表尾被称为栈顶（Top），栈的表头被称为栈底（bottom）\n\n栈Stack的操作：\n- 插入操作（Push），进栈\n- 删除操作（Pop），出栈\n\n![Stack Pop And Push](/gallery/data-structure-stack.png)\n\n## 栈的顺序存储结构\n\n应用顺序存储结构的栈，元素必须从开始表尾进行操作，从而节省下元素前移补充位置的操作，而不像链式结构可以从表头操作。当栈初始化时，不含有任何数据的栈被称为空栈，此时栈顶就是栈底。\n\n## 栈的链式存储结构\n\n**栈一般使用顺序存储结构**实现。使用链式存储结构时，栈底为链表头部，栈顶为链表尾部。\n\n## 使用栈来进行进制转换\n\n例子，使用顺序存储结构的栈计算把`8`位数的二进制数转换成十进制数。\n``` js Javascript\nlet stack = [1, 1, 0, 0, 1, 0, 0, 1]; // 11001001 (2)\n// 1*2^0 + 0*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 1*2^6 + 1*2^7\nlet result = 0;\nlet power = 0; // start with power of 0 in first digit\nwhile (stack.length) {\n  result += stack.pop() * Math.pow(2, power++);\n}\n// result = 201 (10)\n\n// Faster way in JavaScript\nparseInt('11001001', 2).toString(10);\n```\n\n例子，使用顺序存储结构的栈计算把`8`位数的二进制数转换成八进制数。\n``` js Javascript\nlet stack = [1, 1, 0, 0, 1, 0, 0, 1]; // 11001001 (2)\n// 001=>1, 001=>1, 11=>3, final 311 (8)\nlet temp = [];\nwhile (stack.length) {\n  // 3-digit pair\n  let d0 = stack.pop() | 0;\n  let d1 = (stack.pop() | 0) * 2;\n  let d2 = (stack.pop() | 0) * 4;\n  let D = d0 + d1 + d2;\n  temp.push(D);\n}\nlet result = temp.reverse().join(''); // result = 311 (8)\ntemp = parseInt(result, 8); // 201 (10)\n\n// Faster way in JavaScript\nparseInt('11001001', 2).toString(8);\n```\n\n例子，使用顺序存储结构的栈计算把`8`位数的二进制数转换成十六进制数。\n``` js Javascript\nlet stack = [1, 1, 0, 0, 1, 0, 0, 1]; // 11001001 (2)\n// 1001=>9, 1100=>C, final C9 (16)\nlet letters = ['a', 'b', 'c', 'd', 'e', 'f'];\nlet temp = [];\nwhile (stack.length) {\n  // 4-digit pair\n  let d0 = stack.pop() | 0;\n  let d1 = (stack.pop() | 0) * 2;\n  let d2 = (stack.pop() | 0) * 4;\n  let d3 = (stack.pop() | 0) * 8;\n  let D = d0 + d1 + d2 + d3;\n  temp.push(D > 9 ? letters[D % 10] : D);\n}\nlet result = temp.reverse().join(''); // result = C9 (16)\ntemp = parseInt(result, 16); // 201 (10)\n\n// Faster way in JavaScript\nparseInt('11001001', 2).toString(16);\n```\n\n## 使用栈来计算普通数学表达式\n\n计算`1 + (2 - 3 * 4.5) / 6`;\n\n第一步，转换中缀表达式到后缀表达式（逆波兰表达式）。\n\n``` js JavaScript\n// Expected Result: 1 2 3 4.5 * - 6 / +\nlet input = '1 + (2 - 3 * 4.5) / 6';\ninput = input.replace(/\\s/g, ''); // 1+(2-3*4.5)/6\nlet numbers = input.split(/[\\+\\-\\*\\/\\(\\)]+/);\n// [\"1\", \"2\", \"3\", \"4.5\", \"6\"]\nnumbers.forEach((num, i) => {\n  input = input.replace(num, i); // 0+(1-2*3)/4\n});\nlet result = '';\nlet stack = [];\nfor(let i = 0; i < input.length; i++) {\n  let value = input.charAt(i);\n  if (/[\\+\\-\\*\\/\\(\\)]/.test(value)) {\n    if (value === ')') {\n      let symbol = stack.pop();\n      while (symbol !== '(') {\n        result += `${symbol} `;\n        symbol = stack.pop();\n      }\n    } else {\n      if (stack.length > 0) {\n        let symbol = stack.pop();\n        if (/\\*\\//.test(symbol) && !/\\*\\//.test(value)) {\n          result += `${symbol} `;\n        } else {\n          stack.push(symbol);\n        }\n      }\n      stack.push(value);\n    }\n  } else {\n    result += `${numbers[value]} `;\n  }\n}\nwhile (stack.length > 0) {\n  result += `${stack.pop()} `;\n}\n\n// result = \"1 2 3 4.5 * - 6 / + \"\n```\n\n第二步，计算转换后的逆波兰表达式，最后输出结果。\n\n``` js JavaScript\n// Expected Result: -0.9166666666666667\nlet input = '1 2 3 4.5 * - 6 / + ';\ninput = input.trim().split(/\\s/);\n// [\"1\", \"2\", \"3\", \"4.5\", \"*\", \"-\", \"6\", \"/\", \"+\"]\nlet stack = [];\nlet result = 0;\nfor (let i = 0; i < input.length; i++) {\n  let value = input[i];\n  if (isNaN(value)) {\n    let backNum = stack.pop();\n    let frontNum = stack.pop();\n    let subResult = 0;\n    if (value === '+') {\n      subResult = frontNum + backNum;\n    } else if (value === '-') {\n      subResult = frontNum - backNum;\n    } else if (value === '*') {\n      subResult = frontNum * backNum;\n    } else if (value === '/') {\n      if (backNum === 0) {\n        throw new Error('Divisor cannot be 0');\n      }\n      subResult = frontNum / backNum;\n    } else {\n      throw new Error('Operator must be \"+\", \"-\", \"*\" or \"/\"');\n    }\n    if (stack.length > 0) {\n      stack.push(subResult);\n    } else {\n      result = subResult;\n    }\n  } else {\n    stack.push(parseFloat(value));\n  }\n}\n\n// result = -0.9166666666666667\n```\n\n# 队列Queue\n\n队列Queue是一种线性结构，也是线性表的一种具体形式。队列这种先进先出（First In First Out，FIFO）的应用也非常广泛，是只允许在一段进行插入操作，而在另一端进行删除操作的线性表，例如输入缓冲功能，任务顺序加载功能等等。\n\n队列可以用顺序储存结构实现，但是跟栈相反，**队列一般都用链式储存结构**实现。\n\n队列Queue的特性：\n- 队列的元素必须“后进先出”\n- 队列的操作只能于线性表头尾进行\n\n队列Queue的操作：\n- 插入操作（Offer），进队列\n- 删除操作（Poll），出队列\n\n![Queue Offer And Poll](/gallery/data-structure-queue.png)\n\n> 本文参考：\n> [【C语言描述】《数据结构和算法》（小甲鱼）](https://www.bilibili.com/video/BV1jW411K7yg)","categories":["数据结构与算法"],"tags":["Stack","Queue"]},{"title":"CSS 面试题","url":"/posts/22871/","content":"\n总结59道CSS面试题\n\n<!-- more -->\n\nCSS部分的面试题主要考察应试者对CSS基础概念模型的理解，例如文档流                                                                                                                                                                           、盒模型、浮动、定位、选择器权重、样式继承。CSS的基础知识在面试中也是十分重要的。\n\n1、CSS有哪些基本选择器？它们的权重是如何表示的？\n\n答：CSS基本的选择器有类型选择器、属性选择器和ID选择器。\n\nCSS选择器的权重预示着CSS选择器样式渲染的先后顺序，元素样式渲染时，权值高的选择器样式会覆盖权重低的选择器样式。\n\n通常将权重分为4个等级，可用0.0.0.0来表示4个等级。 ！important 关键词的等级优先级最高。\n\n注意：！important并非选择器，而是针对选择器内的单一样式设置的。当然，不同选择器内应用！important的权重也是不一样的，例如，在id选择器中！important关键字权重要高于类选择器权重组合。\n\n内联样式（非元素器）的优先级可看成1.0.0.0。id选择器的优先级为0.1.0.0。类属性选择器、属性选择器、伪类的优选级为0.0.1.0。\n\n元素选择器、伪元素选择器的优先级为0.0.0.1。通配符选择器对特殊性没有任何贡献值。当把选择器组合使用的时候，相应的层级权重也会递增，例如# id .class的权重为0.1.1.0。\n\n2、CSS引入方式有哪些？link 和 @import的区别是什么？\n\nCSS有三种引入的方式。\n\n- 行内式是指样式写在元素style属性内。\n\n    ```css\n    <div id = \"content\" style=\"position: fixed; bottom: 80px; right: 30px; opacity: 1; cursor: pointer;\">这是一个div标签</div>\n    ```\n\n- 内嵌式是指将样式写在style元素内。\n\n    ```CSS\n    <style>\n    * {\n        magrin: 0;\n        padding: 0;\n    }\n    <style>\n    ```\n\n- 外链式是指通过link标签，引入CSS文件内的样式。\n\n通过link标签引入的样式与通过@import方式引入样式有如下区别。\n\n1. 加载资源的限制。\n\nlink是XHTML的标签，除了加载CSS文件外，还可以加载RSS（简易信息聚合，内容包装和投递协议）等其他实务，如加载模板等。@import只能加载CSS文件。\n\n2. 加载方式。\n\n如果用link引入CSS，在页面载入时同时加载，及同步加载。\n\n如果用@import引用CSS，则需要等到网页完全载入后，再加载CSS文件，即异步加载。\n\n3. 兼容性\n\nlink是XHTML的标签，没有兼容问题。\n\n@import是CSS2.1中提出的，不支持低版本的浏览器。\n\n4. 改变样式\n\nlink的标签是DOM元素，支持使用JavaScript控制DOM和修改样式，@import是种方法，不支持控制DOM和修改样式。\n\n3、浮动元素引起的问题和解决方法是什么？\n\n引起的问题有如下几个。\n\n- 父元素的高度无法被撑开，影响与父元素同级的元素。\n- 与元素同级的非浮动元素会紧跟其后（类似遮盖现象）。\n- 如果一个元素浮动，则该元素之前的元素也需要浮动；负责，会影响页面的结构（即通常所说的串行现象）。\n\n解决方法如下：\n\n- 为父元素设置固定高度。\n- 为父元素设置overflow：hidden即可清除浮动，让父元素的高度撑开。\n- 用clear：both样式属性清除元素浮动。\n\n注意：如果只有左浮动或右浮动，可单独设置clear：left或clear：right，但是设置clear：both则都可以解决，所以此方法在工作中用得更多。\n\n- 外墙法是指在父元素外面，添加“一道墙”，设置属性clear：both\n\n- 内墙法是指在父元素内部，浮动元素的最后面，添加“一道墙”，设置属性clear：both\n\n- 伪元素是指为了少创建元素，对父元素添加after伪元素，设置属性content：“”；dispaly:block;clear: both。（这里说的少创造元素，实际上并没有少创建元素，添加的伪元素也是元素，只不过没有写到HTML文档中而已）\n\n- 使用通用类clearfix，clearfix的实现如下（推荐使用这种方法）\n\n    ```css\n    clearfix:after {\n        dispaly:block;\n        clear:both;\n    }\n    ```\n\n    \n\n4、position的值分别是相当于哪个位置定位的？\n\nrelative表示相对定位，相对于自己本身所在正常文档流中的位置进行定位。absolute表示绝对定位，相对于最近一级（从父元素往上数，直到根元素）定位，相对于static的父元素进行定位。fixed用于绝对定位，相对于浏览器窗口或者frame进行定位。static是默认值，没有定位，元素出现在正常的文档流中。sticky是生成粘性定位的元素，容器的位置根据正常文档流计算得出。\n\n注意：CSS3的新增属性有类似于relative与fixed的结合体，如果目标区域在屏幕中可见，表现为relative；如果目标区域在屏幕中不可见，表现为fixed。\n\n5、请说明position：absolute和float属性的区别。\n\n共同点是对于内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。\n\n不同点是float仍可占据位置，不会覆盖另一个BFC区域上，浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框为止，absolute会覆盖文档流中的其他元素，即遮盖现象。\n\n6、CSS选择器有哪些\n\n- id选择器（#myid)\n- 类选择器（.my ClassName)\n- 标签选择器（div、p、h1）\n- 相邻选择器（h1 + p)\n- 子选择器（ul > li)\n- 后代选择器（li a)\n- 通配符选择器（*）\n- 属性选择器（button[disabled=\"true\"])\n- 伪类选择器（a:hover、li-child) 表示一种状态\n- 伪元素选择器（li:before、：after、first-letter、first-line) 表示文档某个部分的表现\n\n注意：在CSS3中规范，为了区别伪元素和伪类，CSS3建议伪类用单冒号“：”，伪元素用双冒号“：：”\n\n7、CSS的那些样式可以继承？那些不可以继承？\n\n可继承的样式有font-size font-famliy color，UL，LI DL DD DT\n\n不可继承的样式有border、padding、margin、width、height\n\n注意：为了方便辨识，与字体相关的样式通常可以继承，与尺寸相关的样式通常不能继承。\n\n8、CSS优先级如何排序？\n\n！import>style(内联)>id(权重100)>calss(权重10)>标签(权重1)。同类别的样式中，后面的会覆盖前面。\n\n9、HTML是什么？CSS是什么？JavaScript是什么？\n\n- HTML（Hyper Text Markup Language,超文本标记语言）是做网站时使用的文本标记标签，比如div、span等。\n- CSS (Cascading Style Sheet,层叠样式表) 是做网站时为了美化网站而为标签添加的样式，比如background(背景)、color(字体颜色) height(高度)width(宽度)等。\n- JavaScript 是网站中实现前后台交互效果、页面动画效果的一种开发语言，比如说鼠标单击（click）事件、前后台数据请求（Ajax)等。\n\n10、为什么要初始化CSS？\n\n应为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有初始化CSS，往往会导致页面在不同页面在不同浏览器之间出现的差异。\n\n11、如何居中div？如何居中一个浮动元素？\n\n确定容器的宽高，例如宽400px、高200px的div。设置层的外边距。\n\n```css\ndiv {\n    float:left;\n    width: 400px;\n    height: 200px;\n    margin: -100px 0 0 -200px;\n    position:relative;\n    left:50%;\n    top:50%;\n    background-color:pink;\n}\n```\n\n12、构成CSS的基本语句是什么？\n\n构成CSS的基本语句如下\n\n```html\n选择器 {\n 属性名称1：属性值1；\n 属性名称2：属性值2；\n}\n```\n\n13、display有哪些值？说明它们的作用。\n\ndisplay的值有block、none、inline、inline-block、list-item、table和inherit。其作用如下。\n\nblock是指块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none是指元素不会显示，已脱离文档流。\n\ninline是指行内元素类型，默认宽度为内容宽度，不可设置宽高，同行显示。\n\ninline-block是指默认宽度为内容宽度，可设置宽高，同行显示。\n\nlist-item是指块类型元素一样显示，并添加样式列表标记。\n\n14、简要描述块级元素和行内元素的区别。\n\n块级元素的前后都会自动换行。默认情况下，块级元素会独占一行。例如<P> <h1-h6><div>都是块级元素，当显示这些元素中间的文本时，都将从新行中开始显示，其后的内容也将在新行中显示。\n\n行内元素可以和其他行内元素位于同一行，在浏览器中显示时 不会换行。例如<a><span>等，对于行内元素，不能设置其高度和宽度。还有一种元素是行内元素，比如<img><input>元素等。这些元素可以和其他元素位于同一行，同时可以设置其高度和宽度。\n\n15、如何用DIV+CSS实现3栏布局（左右固定200px,中间自适应）？\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>实现3栏布局</title>\n    <link rel=\"stylesheet\" href=\"index.css\">\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"main\">\n        <h2>有课前端网</h2>\n    </div>\n    <div class=\"left\">左边内容</div>\n    <div class=\"right\">右边内容</div>\n</div>\n</body>\n</html>\n\n```\n\n```css\n.container div {\n    height: 200px;\n}\n.container {\n    padding: 0 200px;\n}\n.main, .left, .right {\n    position: relative;\n    float: left;\n}\n.left, .right {\n    width: 200px;\n}\n.main {\n    width: 100%;\n    background: yellow;\n}\n.left {\n    background: blue;\n    margin-left: -100%;\n    left: -200px;\n\n}\n.right {\n    background: green;\n    margin-left: -200px;\n    left: 200px;\n}\n\n```\n\n16、解释浮动及其工作原理\n\n浮动元素可以向左或向右移动，直到它的外边缘碰到包含元素（父元素）或另一个浮动元素的边框为止。要想是元素浮动，必须为元素设置一个宽度（width）。虽然浮动的元素已不再文档流中，但是它浮动后所处的位置依然在浮动之前的水平方向上。\n\n应为浮动元素不在文档流中，所以文档流中的块元素表现得像浮动元素不存在一样，下面的元素会填补原来的位置。\n\n有些元素会在浮动元素的下方。但是这些元素的内容并不一定会被浮动的元素覆盖。当定位内联元素时，要考虑浮动元素的边界，围绕浮动元素放置内联元素。也可以把浮动元素想象成被块级元素忽略的元素，而内联元素会关注元素。\n\n17、解释一下CSS Sprite,以及如何在网页或网站中使用它。\n\nCSS Sprite其实就是把网页中一些背景图片整合到一张图片中，在利用CSS的“background-image“ ”background-repeat\" \"background-position\"的组合进行背景定位，background-position可以用数字精确地定位出现背景图片的位置。\n\n注意：在高级浏览器中，可以基于图片的bose64编码存储，将图片与其他的类型的文件打包。\n\n18、在书写高效的CSS时有哪些问题需要考虑？\n\n1. 样式、从右向左解析一个选择器\n2. 类型选择器的速度，ID选择器最快，通配符（*）最慢，解析速度由快到慢依次是ID、class、tag、通配符。\n3. 不要用标签限制ID选择器（如ul#main-navigation{},ID已经是唯一的，不需要Tag来限制，这样做会让选择器变慢）。\n4. 后代选择器最糟糕（换句话说，HTML body ul li a{}这个选择器是很低效的）。\n5. 想清楚你的需求，再去书写选择器。\n6. CSS3的选择器（如nth-child )能够漂亮地定位我们想要的元素，又能保证CSS整洁易读。然而，这些神奇的会浪费很多浏览器资源。\n7. 我们知道ID选择器的速度最快，但是如果都用ID选择器，会降低代码的可读性和可维护性等。在大型项目中，相对于使用ID选择器提升速度，代码的可读性和可维护性带来的收益更大。\n\n19、说出几种解决IE6 bug的方法\n\n解决方案如下：\n\n1. 双边距问题是使用float引起的，解决方案是使用display：inline。\n\n2. 3像素问题，是使用float引起的，解决方案是使用margin-right： -3px。\n\n3. 超链接hover伪类样式，单击后失效，解决方案是使用一下正确的书写顺序：L->V->H->A(link,visited,hover,active)。\n\n4. z-index问题，解决方案是给父级添加position：relative\n\n5. PNG图片半透明问题，解决方法是使用Javascript代码库，或者使用IE滤镜\n\n    \n\n20、页面重构怎样操作？\n\n编写CSS,让页面结构更加合理化，提升用户的良好的体验，达到良好的页面效果并提升性能。\n\n21、display:none 和visibility:hidden的区别是什么？\n\ndisplay:none 隐藏对应元素，在文档流中不再给它分配空间，它各边的元素会合拢，即脱离文档流。\n\nvisibility:hidden隐藏对应元素，但是在文档流中仍然保留原来的空间。\n\n22、内联元素可以实现浮动吗？\n\n在CSS中，任何元素都可以浮动。不论浮动元素本身是何种元素都会生成个块级框。因此，对于内联元素，如果设置为浮动，会产生和块级框相同的效果。\n\n23、简要描述CSS中content属性的作用。\n\ncontent属性与：before及：after伪元素配合使用，用来插入生成的内容，可以在元素之前或之后放置生成的内容。可以插入文本、图像、引号，并可以结合计数器，为页面元素插入编号。比如下面的代码。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>demo</title>\n    <style>\n        body {\n            counter-reset: chapter;\n        }\n        h1:before {\n           content: \"第\" counter(chapter) \"章\";\n        }\n    </style>\n</head>\n<body>\n<h1></h1>\n<h1></h1>\n<h1></h1>\n</body>\n</html>\n```\n\n使用content属性，并结合：before选择器和计数器counter，可以在每个h1元素前插入新的内容。\n\n24、如何定义高度很小的容器？\n\n因为有一个默认的行高，所以在IE6下无法定义小高度的容器。\n\n两个解决方案分别是overflow：hidden 或font-size：容器高度px\n\n25、如何在图片下方设置几像素的空白间隙？\n\n定义img为display：block，或者定义父容器为font-size:0。\n\n26、如何解决IE6双倍margin的bug？\n\n使用display:inline\n\n27、如何让超出宽度的文字显示省略号？\n\n输入overflow：hidden；\n\nwidth：xxx ;\n\nwhite-space:nowrap;(规定段落中的文本不进行换行：)\n\ntext-overflow:ellipsis.( 显示省略符号来代表被修剪的文本。)\n\n28、如何实现英文单词发生词内断行？\n\n输入word-warp:break-word。\n\n29、如何实现IE6下的position：fixed?\n\n具体代码如下：\n\n```css\nhtml_ {\n    overflow: hidden;\n}\nbody_ {\n    overflow: auto;\n    height: 100%;\n}\n.fixed {\n    position: fixed;\n}\n_position: absolute;\nleft: 0;\ntop: 0;\npadding: 10px;\nbackground: #000;\n```\n\n30、如何让min-height兼容IE6？\n\n具体代码如下。\n\n```css\n.min-height {\n    min-height: 100px;\n    _height： 100px;\n    background: red;\n}\n```\n\n31、已知高度的容器如何在页面中水平垂直居中？\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>demo</title>\n    <style>\n        * {\n            margin: 0px;\n            padding: 0px;\n        }\n        div {\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            border: red solid 5px;\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            margin: -100px 0  0 -100px;\n            text-align: center;\n            align-items: center;\n            box-sizing: border-box;\n            line-height: 200px;\n\n        }\n    </style>\n</head>\n<body>\n<div>这是一段文字</div>\n</body>\n</html>\n\n```\n\n32、px和em的区别是什么？\n\npx和em都是长度单位，两者的区别是：px的值是固定的，指定为多少就是多少，计算比较容易；em的值不是固定的，是相等于容器字体的大小，并且em会继承父级元素的字体大小。\n\n浏览器的默认字体高都是16px，所以未经调整的浏览器都符合lem=16px,那么12px=0.75em,10px=0.625em。与cm对应的另一个长度单位是rem,是相对于根元素(通常是HTML元素)字体的大小。\n\n33、什么叫优雅降级和渐进增强？两者有什么区别？\n\n优雅降级graceful degradation是指一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n渐进增强 progressive enhancement是指对低版本浏览器构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进并追加功能，以达到更好的用户体验。\n\n两者的区别如下：\n\n优雅降级从复杂的形状开始，并试图减少用户体验的供给。\n\n渐进增强则从一个非常基础并且能够起作用的版本开始，并不断扩充，以适应未来环境的需要。\n\n降级(功能衰减)意味着往前看，而渐进增强意味着朝前看，同时保证其根基处于安全地带。\n\n34、网页制作会用到那些图片格式？\n\n用于网页制作的主流图片格式有JPG、PNG、GIF等。\n\nJPG：压缩率高、文件小、最常用。\n\nPNG：支持无损压缩，色彩损失小，保真率高，文件稍大。\n\nGIF：支持动画显示，但只支持256色显示，目前已被flash大量取代。\n\n35、CSS的content属性专门应用在before、after伪元素上，用于插入生成的内容最常见的应用是利用伪类清除浮动。\n\n36、对行内元素设置margin-top和margin-bottom是否起作用？\n\n不起作用（需要注意行内元素的替换元素img、input，它们是行内元素，但是可以设置它们的宽度和高度，并且margin属性也对它们起作用，margin-top和margin-botton有着类似inline-block的行为)\n\n37、div + css 的布局相较于table布局有什么优点？\n\n1. 改版的时候更加方便，只需改动CSS文件。\n2. 页面加载速度更快、结构清晰、页面简洁。\n3. 表现与结构分离。\n4. 搜索引擎（SEO）更友好，排名更加靠前。\n\n38、如果设置<P>的font-size为10rem,那么当用户重置或拖曳浏览器窗口时，它的的文本会不会受到影响。\n\n不会\n\n39、谈谈你对BFC规范的理解。\n\nBFC(block formatting context) 指块级格式化上下文，即创建了新的BFC的盒子是独立布局的，盒子里面的元素的样式不会影响到外面的元素。在同一个BFC中，两个相邻的块级盒在垂直方向的margin会发生折叠。\n\nBFC决定元素如何对其内容进行布局，也决定与其他元素的关系和相互作用。\n\n40、谈谈你对c规范的理解。\n\nIFC(inline formatting context) 指内联格式化上下文，IFC的线框(line box)高度由其包含的内联元素中最高的实际高度计算出来而来(不受竖直方向的padding和margin的影响)。IFC中线框一般左右都贴紧整个IFC，但是会被float元素扰动。同一个IFC的多个线框的高度不同。IFC中是不可能有块级元素的，当插入块级元素时(如在p中插入div)，会产生两个匿名块，两者与div分隔开，即产生两个IFC，每个IFC对外表现为块元素，与div垂直。\n\n41、谈谈你对GFC规范的理解。\n\nGFC(GridLayout Formatting Context) 指网格布局格式化上下文，即当把一个display值设为grid的时候，此元素将会获得一个独立的渲染区域。可以通过在网格容器(grid container)上定义网格定义行(grid defintion row) 和 网格定义列(grid defintion column),在网格项目(grid item)上定义网格行(grid row)和网格列(grid column)来为每一个网格定义位置和空间。\n\n42、谈谈你对FFC规范的理解。\n\nFFC(flex formatting context)指自适应格式化上下文，及display的值为flex或line-flex的元素将会生成自适应容器。伸缩容器中的每一个元素都是一个伸缩单元。伸缩单元可以试任意数量的。伸缩单元和伸缩容器外的一切元素都不会受影响。简单地说，flexbox定义伸缩容器内伸缩单元的布局。\n\n43、访问超链接后hover样式就不会出现的原因是什么？应该如何解决？\n\n应为访问过的超链接样式覆盖了原有的hover和active伪类选择器样式，解决方法是将CSS属性的排列顺序改为L->V->H->A(link,visited,hover,active)。\n\n44、什么是外边距重叠？重叠的结果是什么？\n\n外边距重叠就是margin-collapse在CSS中，相邻的两个盒子(可能是兄妹关系也可能是祖先关系)的外边距可以结合成一个独立的外边距。这种合并外边距的方式称为折叠，因此而结合的外边距称为折叠外边距。\n\n折叠结果遵循下列计算规则。\n\n- 当两个相邻的外边距都是正数时，折叠的结果是它们两者中较大的值。\n- 当两个相邻的外边距都是负数时，折叠的结果是两者中绝对值较大的值。\n- 当两个外边距一正一负时，折叠的结果是两者相加的和。\n\n45、rgba()与opacity的透明效果有什么不同?\n\nrgba()和opacity都能实现透明效果，但它们最大的不同是opacity作用于元素，并且可以设置元素内所有的元素的透明度；而rgba()只作用于元素的颜色或其背景色(设置rgba透明的元素的子元素不会继承透明效果)。\n\n46、CSS中可以让文字在垂直和水平方向上重叠的两个属性是什么？\n\n垂直方向的属性是line-height。水平方向属性是letter-spacing。\n\n47、你知道哪些关于letter-spacing的妙用？\n\n可以用于消除inline-block元素间的换行符空隙。\n\n48、有什么方法可以对一个DOM设置它的CSS？\n\n有以下三种方式。\n\n- 外链式：即通过link标签引入一个外部CSS文件。\n- 内嵌式：即通过CSS代码写在style标签内。\n- 行内式：即通过CSS代码写在元素的style属性内。\n\n49、在CSS中可通过那些属性定义，使得一个DOM元素不显示在浏览器可视范围内？\n\n最基本的方式如下。\n\n设置display属性为none，或者设置visibility属性为hidden技巧性的方式如下。设置宽高为0，透明度为0，设置z-index的位置为-1000。\n\n50、常用的块属性标签及其特征有那些？\n\n常用块标签有div、h(1-6)、ol、ul、li、d、table、p、br、form。块标签的特征有独占一行，换行显示，可以设置宽、高，块可以套块和行。\n\n51、常用的行内属性标签及特征有哪些？\n\n行标签有span、a、img、var(定义变量)、em(斜体)、strong(变粗)、textarea(定义多行文本输入控件)、select(创建选择列表)、option、\n\n```html\n<select>\n  <option value =\"volvo\">Volvo</option>\n  <option value =\"saab\">Saab</option>\n  <option value=\"opel\">Opel</option>\n  <option value=\"audi\">Audi</option>\n</select>\n```\n\ninput。行标签的特征有在行内显示，内容撑开宽、高，不可设置宽、高(input、img、textarea等除外)，行只能套用行标签。\n\n52、浏览器标准模式和怪异模式之间的区别是什么？\n\n**标准模式：**是浏览器按照W3C标准解析执行代码，这样用规定的语法去渲染，就可以兼容各个浏览器，保证以正确的形式展示网页。\n\n**怪异模式：**是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。\n\n2、**为什么还要存在怪异模式呢？**\n\n在HTML与CSS的标准化未完成之前，各个浏览器都有自己的解析，而有很多旧的网页都是按照这些非标准的实现去设计的。在HTML与CSS标准确定之后，浏览器一方面要按照标准去实现对HTML与CSS的支持，另一方面又要保证对非标准的旧网页的兼容。\n\n3、**浏览器如何确定用那种渲染模式？**\n\n如果你的页面添加了(**注意：大小写不敏感**)，那么就等同于开启了标准模式。如果省略了，浏览器会采用不符合某些标准的渲染模式。\n\n**4.标准模式和怪异模式常见的区别是什么？**\n\n**盒模型的处理差异****：**\n\n1、**标准模式：总宽度=width+margin(左右)+padding(左右)+border(左右)**\n\n2、**怪异模式：总宽度=width+margin(左右)（width直接包括了padding(左右)+border(左右) ）**。\n\n53、如何避免文档流中的空白符合并现象？\n\n空白符合并是标准文档流的特征之一，可以通过设置white-spac修改这一特性，属性值如下。\n\npre表示不会合并空白符，渲染换行符，自动换行，相当于pre元素。\n\npre-warp表示不会合并空白符。渲染换行符，自动换行pre-line表示合并空白符，渲染换行符，自动换行。\n\nnowrap表示合并空白符，不会渲染换行符，不会自动换行。\n\nnormal表示默认值，按照文档流特点渲染，合并空白符，不会渲染换行符，自动换行。\n\n 54、透明度具有继承性，如何取消透明度的继承？\n\n使用rgba给元素的背景设置透明度的方式，来代替使用opacity设置元素透明度的方式，解决子元素继承父元素透明度的问题。\n\n55、CSS中，自适应的单位有哪些？\n\n自适应的单位有一下几个\n\n- 百分比： %\n- 相当于视口宽度的单位：ww\n- 相对于视口高度的单位：vh\n- 相对于视口宽度或高度(取决于哪个小)的单位：vm\n- 相对于父元素字体大小的单位：em\n- 相对于根元素字体大小的单位：rem\n\n56、说说rem和em的区别\n\n他们都是相对单位\n\nrem表示相对于根元素的字体大小。\n\nem表示相对于父元素的字体大小。 \n\n\n\n","categories":["面试"],"tags":["CSS"]},{"title":"数据结构之线性表 List","url":"/posts/6004/","content":"\n线性表（List），了解线性表的基础知识，认识一下线性表的种类。\n\n<!-- more -->\n\n# 线性表List\n\n线性表（List）：由另个或多个元素组成的有限序列。**元素是有序的，可以被排列的**。在有序结构中，某个元素`ai`前面的元素`ai-1`称为**前驱元素**，后面的元素`ai+1`称为**后继元素**。在Java语言中，数组（ArrayList）和链表（Linked List）都属于线性表。其中数组使用了顺序结构，而链表使用了链式结构。\n\n线性表的数据对象集合为`{a1,a2,...,an-1,an}`，每个元素的类型均为`DataType`。**数据元素之间的关系是一对一的关系。**其中，除第一个元素`a1`外，每个元素有且只有一个直接前驱元素，除最后一个元素`an`外，每个元素有且只有一个直接后继元素。\n\n# 线性表伪代码\n\n```\nADT 线性表（List）\nData\n  数据对象集合 {a1,a2,...,an-1,an}\nOperation\n  init(*L)：初始化空线性表L\n  isEmpty(L)：判断线性表是否为空\n  clear(*L)：清空线性表\n  getElement(L,i,*e)：将线性表L中第i个元素返回给e\n  elementAt(L,e)：线性表L中查找与e相等的元素，返回元素的位置\n  insert(*L,i,e)：线性表L中第i个位置插入新元素e\n  delete(*L,i,*e)：删除线性表L中第i个位置元素，并返回该元素给e\n  length(L)：返回线性表L的元数个数\nendADT\n```\n\n# 线性表的顺序存储结构\n\n线性表的顺序存储结构封装需要3个属性：\n\n- 存储空间初始位置，数组指针\n- 线性表的最大长度，指存储空间总长度，初始化后不变\n- 线性表的当前长度，指表中元素数量，大于等于0，小于表的最大长度\n\n## 顺序存储结构的地址计算方法\n\n**注：`i`从“1”开始**\n\n假设每个元素类型的`DataType`都需要占用`c`个储存单位（字节），那么线性表中第`i+1`个元素和第`i`个元素的存储位置的关系是（LOC为获得存储位置的函数）：\n\n`LOC(ai+1) = LOC(ai) + c`\n\n所以找第`i`个元素`ai`的储存位置可以又线性表初始指针指向的`a1`推算出：\n\n**`LOC(ai) = LOC(a1) + (i-1) * c`**\n\n通过这个公式，计算出线性表中任意位置的地址，所用的时间都是相同的，那么他的存储时间性能就是`O(1)`，**这种结构通常被称为随机存储结构。**\n\n# 线性表的链式存储结构\n\n顺序存储结构最大的缺点，插入和删除需要移动大量元素，从而保持表中元素邻居的关系；链式存储结构通过携带后继元素的存储地址就解决了这个缺点。\n\n链式存储结构的线性表中元素称为“存储映像”，也称为“节点（Node）”。每个节点都是由两部分组成：\n\n- 数据域：储存数据元素信息的域\n- 指针域：存储直接后继元素地址的域\n\n## 单链表\n\n`n`个节点链接成一个链表，即为线性表`(a1,a2,...,an-1,an)`的链式存储结构。因为此链表的每个节点中只包含一个指针域，所以叫做单链表。\n\n![单链表图示](/gallery/data-structure-linked-list-normal.png)\n\n单链表必须有一个头部加上0到多个节点。头指针是链表指向第一个节点的指针，如果链表有头结点，则头指针指向头结点。头结点携带第一个元素的节点指针，放在第一个节点之前，其数据域一般无意义，但也可以存放链表的长度。头结点不是必须的，但是头结点可以放一些对列表有用的变量。\n\n尾指针是指向单链表的最后一个节点的指针，这个指针不是必须的，但是尾指针有好处，比如需要在尾部插入新节点。\n\n**若线性表需要频繁查找，很少进行插入和删除操作是，宜采用顺序存储结构。**\n\n**若需要频繁插入和删除时，宜采用单链表结构。**\n\n## 静态链表\n\n在内存中建立一个数组，在数组最大长度内的空间中再建立一个链表，这种链表就是静态链表。静态链表通过“游标（Cursor）”指向后继元素所处数组中的“下标（Index）”。下图为静态链表转普通链表，最大长度为`100`，第一个元素游标指向备用链表的头节点（既当前链表尾节点的游标，也是尾指针），最后一个元素游标指向当前链表头节点。\n\n![静态链表转普通链表](/gallery/data-structure-linked-list-static-to-normal.png)\n\n- 数组中第一个和最后一个元素不存放数据\n- 未使用的数组元素被称为备用链表\n- 数组第一个元素，即`Index = 0`的元素的游标（Cursor）存放备用链表的第一个节点的下标\n- 数组最后一个元素，即`Index = MAX_SIZE-1`的元素的游标（Cursor）存放当前链表的第一个节点的下标\n- 静态链表初始化时，`Index = 0`的元素的游标应从`1`开始，而`Index = MAX_SIZE-1`的元素的游标则是`0`，表示空链表\n\n## 循环链表\n\n在单链表中，如果不从头结点出发，就无法访问到全部节点。循环链表就解决了这个问题。只要有链表中某一节点的指针，就能跑完全部节点。当表为空时，头部后继指针指向头部本身。\n\n**循环链表所用的方法就是把尾节点的空指针指向头节点，使单链表形成一个环，这种头尾相接的单链表被称为单循环链表，简称循环链表。**\n\n原单链表判断尾节点用`node.next === null ?`，现在则是用`node.next === head ?`。\n\n## 双向链表\n\n对比单链表，双向链表的节点有两个指针：前驱指针和后继指针。双向列表允许从尾部往回跑。当表为空时，头部前驱指针和后继指针都指向头部本身。\n\n# 找单链表中间的节点的方法\n\n利用快慢指针原理：设置两个指针`*search`和`*middle`都指向单链表的头结点。其中`*search`的移动速度是`*middle`的2倍。当`*search`指向尾节点时，`*middle`正好就在中间。\n\n在一个长度为100的单链表中，当`*search`指向第100个节点时，`*middle`指向第50个节点。\n\n在一个长度为101的单链表中，当`*search`指向102（即超出长度）时，`*middle`指向第51个节点，正好在中间。\n\n# 判断一个链表是否有环\n\n方法一：设置两个指针`*q`和`*b`。`*q`一直在走的情况下，每遇到一个节点，`*b`就从新从头结点开始走。如果`*q`所在当前步数等于`*b`从头开始数的步数，则`*q`继续往前走一步，而`*b`从新走。如果`*q`所在当前步数不等于`*b`的从头开始数的步数，则存在环。这种方法可以找到环所在节点。\n\n方法二：设置两个指针`*q`和`*b`都指向单链表的头结点。其中`*q`的移动速度是`*b`的2倍，若在某个时候`*q == *b`，则存在环。一般偶数量节点的单循环链表跑两次后`*q == *b`。\n\n> 本文参考：\n> [【C语言描述】《数据结构和算法》（小甲鱼）](https://www.bilibili.com/video/BV1jW411K7yg)","categories":["数据结构与算法"],"tags":["线性表","List"]},{"title":"算法之基础","url":"/posts/2915/","content":"\n算法基础，了解算法的基础知识，算法的种类，知道什么是好算法。\n\n<!-- more -->\n\n# 算法特性\n\n- **输入**：可以有零个或多个参数\n- **输出**：必须有一个或多个结果\n- **有穷性**：算法必须会结束，没有无限循环\n- **确定性**：有唯一结果\n- **可行性**：算法每一步都能通过执行有限次数完成\n# 算法设计要求\n\n- **正确性**：算法至少具有输入、输出和过程明确的加工处理，正确反映问题的需求，最后得到期望的答案\n  - 算法程序没有语法错误\n  - 算法程序对于合法输入能产生期望的答案\n  - 算法程序对于非法输入能产生警告和提示\n  - 算法程序对于故意掉难得测试输入都能产生期望的结果\n- **可读性**：算法便于阅读、理解和交流\n- **健壮性**：能够处理异常、崩溃或莫名其妙的结果\n- **高时间效率和低存储量**：算法要考虑处理速度和内存用量\n  \n# 算法效率度量方法\n\n- 事后统计方法：通过执行多个输入测试，记录执行时间平均值\n- 事前估算方法：通过统计方法对算法进行估算，涉及以下因素\n  1. 算法策略，**例子使用公式或者循环等**\n  2. 编译后的代码质量，**基础操作的次数统计**\n  3. 问题的输入规模，**例子数值大小或元素数量等**\n  4. 机器执行指令的速度，**硬件性能**\n\n**算法基础种类分别有：`1`、`n`、`n*n`。**\n\n一般使用公式或瀑布式条件判断的算法策略属于`1`；使用单个循环的属于`n`；使用嵌套循环的属于`n*n`。3种算法中往往常数算法`1`要优于`n`和`n*n`。给以下基础操作次数公式分类：\n- `1`：`3`、`5`、`9`等\n- `n`：`n`、`n+1`、`2n+3`等\n- `n*n`：`n^2`、`n^2+5`、`2n^3+1`等\n\n**一般判断算法好坏，更应该关注函数公式的主项：指数最高项。**\n比如算法`2n^2+n+3`对比算法`n^3+2n+1`，因为`2n^2`指数低于`n^3`，所以算法`2n^2+n+3`优于算法`n^3+2n+1`。\n\n## 怎么分析一个算法的输入时间？\n\n- 抽象算法：去除算法中循环的外包装、条件的判断、变量的声明、打印输出等操作\n- 指令计数：统计关联的输入模式下基础操作的数量\n\n## 求和1-100的算法例子分析\n\n以下*算法一*，算法策略使用`循环`，编译后的代码质量为`n`次，问题的输入规模`100`，机器执行指令的速度取决于算法运行所在计算机。\n\n``` js JavaScript 算法一\nlet sum = 0, i = 1, n = 100;\nfor (; i <= n; i++) {\n  sum += i;                  // 执行 n 次\n}\n```\n\n以下*算法二*，算法策略使用`公式`，编译后的代码质量为`1`次，问题的输入规模`100`，机器执行指令的速度取决于算法运行所在计算机。\n\n``` js JavaScript 算法二\nlet sum = 0, i = 1, n = 100;\nsum = (i + n) * n  / 2;      // 执行 1 次\n```\n\n对比以上算法，它们的输入规模都是`100`，在同一计算机运行的情况下，**算法一**的基础操作次数受输入规模的影响，造成工作量超出**算法二**，**所以算法二效率更高**。\n\n## 求和3x3表格内数值的例子分析\n\n以下*表格遍历例子*，算法策略使用`嵌套的循环`，编译后的代码质量为`n^2`次，问题的输入规模`3x3`，机器执行指令的速度取决于算法运行所在计算机。\n\n``` js JavaScript 表格遍历求和例子\nlet sum = 0, \n    table = [\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    ];\nfor (let i = 0; i <= table.length; i++) {\n  for (let j = 0; j <= table[i].length; j++) {\n    sum += table[i][j];      // 执行 n^2 次\n  }\n}\n```\n\n以上算法，它根据表格的大小，基础操作的数量是以指数上升的，**所以`3x3`的表格内数值总和计算一共有基础操作`3^2`等于9次**。\n\n# 用大O记法表示算法时间复杂度\n\n复杂度分为：**时间复杂度**或**空间复杂度**\n**一般计算“复杂度”是指“时间复杂度”，而不是空间复杂度，目前主流还是时间复杂度，不求用内存换取时间。**\n\n**T(n) = O(f(n))**，`f(n)`为算法的函数或入口，随着输入规模`n`的增长，`T(n)`增长最慢的算法为最优算法。因为以下原因：\n\n**基础操作数量 = 时间**\n\n所以当`n`翻倍时，*基础操作数量*增长越少，花费的*时间*越少。\n\n上面用到的三个求和算法例子，如果用大O表示算法的时间复杂度分别为`O(1)`、`O(n)`、`O(n^2)`。\n\n**大O记法表示时间的增长率**\n\n- `O(1)`：增长率不变\n- `O(n)`：增长率倍数增长\n- `O(n^2)`：增长率指数增长\n\n## 推导大O阶方法\n\n用一下方法来推导`5`、`2n+3`、`n(n+1)/2`和`O(logn)`的大O阶：\n\n1. 用常数1取代所有加法常数\n2. 只保留最高阶项\n3. 最高阶项不是1的话，去除这个项相乘的常数\n\n`5` => `O(1)`，\n`2n+3` => `O(n)`，\n`n(n+1)/2` => `O(n^2)`\n\n一面这个例子的话就是`O(logn)`：\n\n``` js JavaScript\nlet i = 1, n = 100;\nwhile (i < n) {\n  i *= 2; // 2^x = n，那么 x = log(2)n，x为循环次数\n}\n```\n\n## 常见的时间复杂度\n\n| 例子 | 时间复杂度 | 术语 |\n| :---: | :---: | :---: |\n| 5 | O(1) | 常数阶 |\n| 3n+4 | O(n) | 线性阶 |\n| 3n^2+4n+5 | O(n^2) | 平方阶 |\n| 3log(2)n+4 | O(logn) | 对数阶 |\n| 2n+3nlog(2)n+14 | O(nlogn) | nlogn阶 |\n| n^3+2n^2+4n+6 | O(n^3) | 立方阶 |\n| 2^n | O(2^n) | 指数阶 |\n\n时间复杂度对比：\n**`O(1)` < `O(logn)` < `O(n)` < `O(nlogn)` < `O(n^2)` < `O(n^3)` < `O(2^n)` < `O(n!)` < `O(n^n)`**\n\n> 本文参考：\n> [【C语言描述】《数据结构和算法》（小甲鱼）](https://www.bilibili.com/video/BV1jW411K7yg)","categories":["数据结构与算法"],"tags":["基础","Big O"]},{"title":"数据结构之基础","url":"/posts/46208/","content":"\n数据结构基础，了解数据结构的分类，认识一下抽象数据类。\n\n<!-- more -->\n\n# 顺序结构\n\n**内存中元素紧挨在一起的数据结构为顺序结构**。在C语言中，声明一个整数结构类型长度为`5`的数组时，内存中会留出5个整数长度的连续空间用于存储数组。实际上，数组的指针可以说是指向在数组中的第一个元素。当要修改第4个元素时，计算机是找到了数组指针地址，跳跃3个整数长度的距离，从而找到第4个元素的位置。\n\n# 链式结构\n\n**内存中元素可连续也可不连续，通过指针寻找和连接元素的数据结构为链式结构**。在Java语言中，链表（Linked List）和树（Tree）都属于链式结构。他们属于抽象的结构类型，类型所包含的元素被称为节点（Node）。链表节点中的值可以为整数类、浮点类、字符串等，包括抽象数据类；但链表节点中还会包含有节点的一个后继元素指针。树节点对比链表节点的不同在于树节点中可以包含有多个后继元素指针。总结起来就是**链式结构节点在内存中连续摆放不是必须的**，当计算机查找某个节点时，会走遍目标节点前的所有节点，从而顺着第一个节点的指针找到目标指针。\n\n# 比较顺序结构和链式结构\n\n![顺序结构和链式结构在内存中的不同](/gallery/data-structure-random-linked-ram.png)\n\n- 顺序结构在内存中有固定最大长度，而链式结构在内存中没有，所以在流动数据多的情况下，链式结构对空间利用更灵活。\n- 顺序结构在内存中是元素之间是连续的，而链式结构在内存中很可能是不连续的，所以在查找元素时，通过地址计算公式查找，顺序结构的效率更高。\n- 在首部添加元素或删除中间某个元素的情况下，链式结构的效率会更高，因为对比顺序结构，链式结构不需要重新排列。\n- 顺序结构最大长度难以确定的情况下，会产生太多的储存空间“碎片”，而链式结构原本就是“碎片化”的。\n\n# C语言数据类型\n\n原子/基本类型：short, int, long, float, double, char\n结构/构造类型：数组, struct, union, enum\n其他：指针，空（void）\n\n# 抽象数据类型（Abstract Data Type）\n\n区别于基本数据类型，基本数据类型有设定数据占用空间的极限、数据表示的方式和内存中结构的特性；抽象数据类型基于基本数据类型形成更复杂的数据类型，例如链表（Linked List）和树（Tree）都属于抽象数据类。颜色（Color）、坐标（Point）等结构类也都属于抽象数据类。\n\n> 所谓抽象数据类型就是把数据类型和相关操作捆绑在一起。\n\nColor抽象数据类:\n由Red、Green和Blue，3个范围为0-255的整数值表示颜色范围，加上一个范围为0-1的浮点型Alpha数值表示透明度。\n\nPoint抽象数据类:\n由x、y和z，3个整数值表示三维空间中的坐标。\n\n# 抽象数据类型伪代码\n\n```\nADT 抽象数据类型名\nData\n  数据元素之间逻辑关系的定义\nOperation\n  操作\nendADT\n```\n\n> 本文参考：\n> [【C语言描述】《数据结构和算法》（小甲鱼）](https://www.bilibili.com/video/BV1jW411K7yg)","categories":["数据结构与算法"],"tags":["基础","抽象数据类"]},{"title":"JavaScript 中的对象","url":"/posts/10347/","content":"\nJS对象总结\n\n<!-- more -->\n\n学习js也有一段时间了，是时候来总结一下js中的对象以及它们的方法了。\n\n## Array对象\n\narray对象用于单个变量中存储多个值。\n\n###  创建Array对象的语法\n\n```js\nnew Array();\nnew Array(size);   //参数size是期望的数组的个数，返回的数组，length字段被设为size的值。\nnew Array(element0, element1, element2, element3, ....);\n//element.. 为参数列表。当使用这些参数来调用构造函数Array()时\n```\n\n### 返回值\n\n返回新创建并初始化了数组。\n\n如果调用了构造函数Array()时没有使用参数，那么返回的数组为空，length字段为0。\n\n当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为undefined的数组。\n\n当其他参数调用Array()时，该构造函数将用参数指定的值初始化数组。\n\n当构造函数作为函数调用，不用new运算符时，它的行为与使用new运算符调用它时的行为完全一样。\n\n### Array 对象属性\n\n#### constructor\n\n##### 定义和用法\n\nconstructor属性返回对创建此对象的数组函数的引用。\n\n##### 语法\n\n```html\nobject.constructor\n```\n\n例子1\n\n```js\n//构造函数创建数组\nvar test = new Array();\nif (test.constructor == Array) {\n  console.log(\"This is an Array\");\n} else {\n  console.log(\"hello world\");\n}\n//输出\nThis is an Array\n//字面量的方式\n var arr2=[];\n```\n\n### Array 对象方法\n\n1、Array.isArray(对象)---->判断这个对象是不是数组\n\n```js\n//判断对象是不是数组类型:两种\nvar arr1=new Array();\n//1 instanceof\nvar obj=[];\nconsole.log(obj instanceof Array);//true\n\n//2 使用数组的isArray\nconsole.log(Array.isArray(obj));//true\n```\n\n2、Array.concat(数组,数组,数组,...) 组合一个新的数组\n\n```js\nvar arr1=[10,20,30];\nvar arr2=[40,50,60];\nconsole.log(arr1.concat(arr2));//[10, 20, 30, 40, 50, 60]\n```\n\n3 、Array.every(函数)--是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。\n\n返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，第二个参数是索引值,第三个参数是原来的数组(没用)、如果这个数组中的每个元素的值都符合条件,最后才返回的是true\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6];\nconsole.log(arr.every(function (item, index, array) {\n    console.log('item=' + item + ',index=' + index + ',array=' + array);\n    //item是数组的值 index自动循环的值 array 自身的数组（一般没用 只用前面两项参数）\n    return item > 0;\n    //这里写函数的判断 只要有一个不是true就停止继续循环 只有全部函数判断结果为true才返回true\n}));//true\n\nvar arr=[\"小明明lkko\",\"小曹操674\",\"小白白bd\",\"笑眯眯a\"];\nvar flag=arr.every(function (ele,index) {\n    //数组中的每个元素的长度是不是大于4\n    return ele.length>4;\n});\nconsole.log(flag);//false \n```\n\n4、Array.some()(函数)--是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。some一直在找符合条件的值，一旦找到，则不会继续迭代下去\n\n```js\nvar arr = [ 1, 2, 3, 4, 5, 6 ]; \nconsole.log( arr.some( function( item, index, array ){ \n    console.log( 'item=' + item + ',index='+index+',array='+array ); \n    //item是数组的值 index自动循环的值 array 自身的数组（一般没用 只用前面两项参数）\n    return item > 3; \n    //这里写函数的判断 只要有一个是true就停止继续循环 有一个函数判断结果为true就返回true\n})); //true\n```\n\n5、Array.filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组\n\n```js\nvar arr = [10, 20, 30, 40, 50, 60, 70, 80];\nvar newArr = arr.filter(function (ele) {//ele---每个元素\n    return ele > 40;\n});\nconsole.log(newArr);//[50, 60, 70, 80]\n\n//可以用来去重\nvar arr = [10, 0, 20, 0, 40, 0, 60, 100];\nvar newArr = arr.filter(function (ele) {\n    return ele != 0;\n});\nconsole.log(newArr);//[10, 20, 40, 60, 100]\n```\n\n6、Array.push(值);--->把值追加到数组中,加到最后了---返回值也是追加数据之后的数组长度（重点+++）\n\n```js\nvar arr =[10,20,30];\nconsole.log(arr.push(40));//返回值是 增加后的数组涨肚\nconsole.log(arr);//[10, 20, 30, 40]\n```\n\n7、Array.pop();--->删除数组中最后一个元素,返回值就是删除的这个值（重点+++）\n\n```js\nvar arr =[10,20,30,40];\nconsole.log(arr.pop());//返回值是删除的值\nconsole.log(arr);//[10, 20, 30]\n```\n\n8、Array.shift();--->删除数组中第一个元素,返回值就是删除的这个值（重点+++）\n\n```js\nvar arr =[10,20,30,40];\nconsole.log(arr.shift());//返回值是删除的值\nconsole.log(arr);//[ 20, 30，40]\n```\n\n9、Array.unshift();--->向数组的第一个元素前面插入一个新的元素,----返回值是插入后的程度（重点+++）\n\n```js\nvar arr=[10,20,30,40,50];\nvar result=arr.unshift(5);\nconsole.log(result);//返回现在的长度\nconsole.log(arr);//[5,10,20,30,40,50]\n```\n\n10、Array.forEach(函数)方法---遍历数组用---相当于for循环\n\n```js\nvar arr = [10, 20, 30, 40];\narr.forEach(function (ele,index) {\n    console.log(\"数组的值：\"+ele+'----'+\"自迭代的值：\"+index);\n});\n// 数组的值：10----自迭代的值：0\n// 数组的值：20----自迭代的值：1\n// 数组的值：30----自迭代的值：2\n// 数组的值：40----自迭代的值：3\n```\n\n 11、Array.map(函数);--->数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中\n\n```js\nfunction f1(a) {\n    return Math.pow(a, 2);\n}\nvar arr = [1, 2, 3, 4, 5];\nconsole.log(arr.map(f1));//[1, 4, 9, 16, 25] \n```\n\n12、Array.indexOf(元素值);返回的是索引,没有则是-1\n\n```js\nvar arr=[10,20,30,40];\nconsole.log(arr.indexOf(10)); // 返回对于字符串的索引\nconsole.log(arr.indexOf(50));//找不到就返回-1\n```\n\n13、Array.join(\"字符串\");----数组中每个值与字符串拼接 返回的是一个字符串\n\n```js\nvar arr=[\"小白\",\"小黑\",\"小红\",\"小芳\",\"小绿\",\"小苏\"];\nvar str=arr.join(\"|\");\nconsole.log(str);//小白|小黑|小红|小芳|小绿|小苏\n```\n\n14、Array.reverse();----->反转数组\n\n```js\nvar arr=[10,20,30,40,50];\narr.reverse();//反转\nconsole.log(arr);//[50, 40, 30, 20, 10]\n```\n\n15、Array.sort();---排序\n\n```js\n//一维数组 倒序\nvar arr=[10,20,30,40,50,60,70,80,90,100];\narr.sort((a, b) => {\n    return b - a;\n})\n\n//二维数组 倒序\nvar arr=[[3,2,1],[5,7,4],[4,6,2],[8,2,1],[4,1,7]];\narr.sort((a, b) => {\n    return b[0] - a[0];\n})\n/*\n0: (3) [8, 2, 1]\n1: (3) [5, 7, 4]\n2: (3) [4, 6, 2]\n3: (3) [4, 1, 7]\n4: (3) [3, 2, 1]\n*/\n\n```\n\n16、Array.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值\n\n```js\nvar arr=[10,20,30,40,50,60,70,80,90,100];\nvar newArr= arr.slice(3,7);\nconsole.log(newArr);// [40, 50, 60, 70]\n```\n\n17、Array.splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素（重点++）\n\n```js\nvar myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];\nmyFish.splice(2, 0, 'drum'); // 在索引为2的位置插入'drum'\nconsole.log(myFish);//[\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"]\n\nmyFish.splice(2, 1); // 从索引为2的位置删除一项（也就是'drum'这一项）\nconsole.log(myFish);//[\"angel\", \"clown\", \"mandarin\", \"sturgeon\"]\n```\n\n## String对象\n\n**charAt()**: 返回在指定位置的字符。\n\n**charCodeAt()**: 返回在指定的位置的字符的 Unicode 编码。\n\n```js\nvar s = \"Smile forever!\";\ns.charAt(2);  //i\ns.charCodeAt(2);  //105\n```\n\n**concat()**: 连接字符串，参数可以是多个字符串。\n\n```js\nvar s1 = \"Smile forever!\";\nvar s2 = \"extend\";\ns1.concat(s2);  //Smile forever!extend\ns1.concat(\"a\",\"b\") //Smile forever!ab\n```\n\n**split()**: 用于把一个字符串分割成字符串数组。\n\n```js\nvar s = \"get out\";\ns.split(\"\");  //g,e,t, ,o,u,t\ns.split(\" \");  //get,out\ns.split(\"\",3);  //g,e,t 第二个参数指定返回的数组的最大\n```\n\n**replace()**: 替换字符串。该方法接受两个参数，第一个参数是被替换的字符串或正则表达式(RegExp对象)，第二参数是一个字符串或函数。如第一个参数是字符串，则只会替代第一个子字符串，需要全部替换，需要用正则表达式，指定全局标志g。\n\n```js\nvar s = \"cat, bat, sat\";\ns.replace(\"at\",\"od\");  //cod, bat, sat\ns.replace(/at/g,\"od\");  //cod, bod, sod\n```\n\n**indexOf()**: 返回某个指定的字符串值在字符串中首次出现的位置。该方法对大小写敏感！\n\n**lastIndexOf()**: 从后向前搜索字符串。该方法对大小写敏感！\n\n```js\nvar s = \"Smile forever!\";\ns.indexOf(\"smile\");  //-1\ns.indexOf(\"Smile\");  //0\ns.indexOf(\"e\",6);  //9,第二个参数规定在字符串中开始检索的位置。\ns.indexOf(\"e\");  //4\ns.lastIndexOf(\"e\");  //11\n```\n\n**match()**: 在字符串内检索指定的**值**，或找到一个或多个正则表达式的匹配。注意标志g(全局搜素模式)。\n\n**search()**: 参数与match()相同，返回字符串中第一个匹配项的**索引**，若没有找到匹配项，则返回-1。\n\n```js\nvar str=\"1 plus 2 plus 3\";\nstr.match(\"p\");  //p\nstr.match(/\\d+/); //1 \nstr.match(/\\d+/g); //1,2,3\n\nvar s = \"Smile forever!\";\ns.search(\"smile\");  //-1\ns.search(/le/);  //3\n```\n\n**slice()**: 提取字符串。slice(start,[end])\n\n```js\nvar s = \"Smile forever!\";\ns.slice(2);  //ile forever!\ns.slice(2,4);  //il\ns.slice(-4,-2); //ve\n```\n\n**substr()**: substr(start,[length])  ！注意：ECMAscript 没有对该方法进行标准化，因此反对使用它。\n\n```js\nvar s = \"Smile forever!\";\ns.substr(2);  //ile forever!\ns.substr(2,5);  //ile f\ns.substr(-4,2); //ve\n```\n\n**substring()**: substring(start,[stop]) 其内容是从 *start* 处到 *stop*-1 处的所有字符。如*start* 与 *stop* 相等，则返回空串。不接受负值！\n\n```js\nvar s = \"Smile forever!\";\ns.substring(2);  //ile forever!\ns.substring(2,4);  //il\ns.substring(2,2);  //\n```\n\n**toLowerCase()**: 把字符串转换为小写。\n\n**toUpperCase()**: 把字符串转换为大写。\n\n```js\nvar s = \"Smile forever!\";\ns.toLowerCase();  //smile forever!\ns.toUpperCase();  //SMILE FOREVER!\n```\n\n另外，toLocaleUpperCase()、toLocaleLowerCase()方法按照本地方式把字符串转换为大小写。只有几种语言（如土耳其语）具有地方特有的大小写映射，所有该方法的返回值通常与上面两张方法一样。\n\n**trim()**: 删除字符串首位的空格。该方法只是创建字符串的副本，不会改变原字符串。\n\n```js\nvar s = \"   Smile   \";\ns.trim();  //Smile\n```\n\n## Set\n\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n　　很多时候我们把Set叫做 集合,但是，Set可以是集合，集合不一定是Set。\n\n　　特性：唯一性=>不重复=>能够对数据进行去重操作。\n\n注：集合去重，是全等匹配，===。\n\n### 创建Set\n\n　　Set 本身是一个构造函数，调用构造函数用来生成 Set 数据结构。　　\n　　　　关键词　　标识符　= new Set();\n　　例 　　 let　　　　i　　 = new Set();　　\n　　Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。\n\n　　　　　 let i = new Set([1, 2, 3, 4, 4]);　　会得到　　set{1, 2, 3, 4,}\n\n注：如果初始化时给的值有重复的，会自动去除。集合并没有字面量声明方式。\n\n### Set的属性\n\n　　常用的属性就一个：size 　　返回 Set 实例的成员总数。\n\n　　let s = new Set([1, 2, 3]);\n\n　　console.log( s.size ); // 3\n\n### Set的方法\n\n　　Set 实例的方法分为两大类：操作方法（用于数据操作）和遍历方法（用于遍历数据）。\n\n### 操作方法:\n\n| add(value)    | 添加数据，并返回新的 Set 结构              |\n| ------------- | ------------------------------------------ |\n| delete(value) | 删除数据，返回一个布尔值，表示是否删除成功 |\n| has(value)    | 查看是否存在某个数据，返回一个布尔值       |\n| clear()       | 清除所有数据，没有返回值                   |\n\n```js\nlet set = new Set([1, 2, 3, 4, 4]);\n// 添加数据 5\nlet addSet = set.add(5);\nconsole.log(addSet); // Set(5) {1, 2, 3, 4, 5}\n// 删除数据 4s\nlet delSet = set.delete(4);\nconsole.log(delSet); // true\n// 查看是否存在数据 4\nlet hasSet = set.has(4);\nconsole.log(hasSet); // false\n// 清除所有数据\nset.clear();\nconsole.log(set); // Set(0) {}\n```\n\n### 遍历方法\n\nSet 提供了三个遍历器生成函数和一个遍历方法。\n\n| values()  | 返回一个键值的遍历器     |\n| --------- | ------------------------ |\n| entries() | 返回一个键值对的遍历器   |\n| forEach() | 使用回调函数遍历每个成员 |\n\n```js\nlet color = new Set([\"red\", \"green\", \"blue\"]);\nfor(let item of color.keys()){\n console.log(item);\n}\n// red\n// green\n// blue\nfor(let item of color.values()){\n console.log(item);\n}\n// red\n// green\n// blue\nfor(let item of color.entries()){\n console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\ncolor.forEach((item) => {\n console.log(item)\n})\n// red\n// green\n// blue\n```\n\n### 与数组相关操作\n\n#### Set 转数组：\n\n由于扩展运算符...，内部的原理也是使用的 for-of 循环，所以也可以用于操作 Set 结构。\n\n例如将 Set 结构转换为数组结构：　　　　　　　\n\n```\nlet color = new Set([\"red\", \"green\", \"blue\"]);\nlet colorArr = [...color];\n```\n\n#### 数组去重：\n\n扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。\n\n```js\nlet arr = [1,2,2,2,2,\"2\",24,5,6];\n//step1:数组转集合\nlet set = new Set(arr);//已经去掉重复值，当前不是数组，而集合　　Set { 1, 2, '2', 24, 5, 6 }\n//step2:集合转数组\narr = [...set];//[ 1, 2, '2', 24, 5, 6 ]\n```\n\n#### 扩展\n\n```js\nlet num1 = new Set([1, 2, 3, 4]);\nlet num2 = new Set([3, 4, 5, 6]);\n\n//并集\nlet union = new Set([...num1,...num2]);\nconsole.log(union);//Set { 1, 2, 3, 4, 5, 6 }\n\n//交集\nlet intersect = new Set(\n    [...num1].filter(x=> num2.has(x))\n)\nconsole.log(intersect); //Set { 3, 4 }\n\n//差集\nlet difference = new Set(\n    [...num1].filter(x => !num2.has(x))\n)\nconsole.log(difference); //Set { 1, 2 }\n```\n\n## Map：\n\nMap是一组键值对的结构，具有极快的查找速度。\n\n举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：\n\n```js\nvar names = ['Michael', 'Bob', 'Tracy'];\nvar scores = [95, 75, 85];\n```\n\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。\n\n如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：\n\n```js\nvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\nm.get('Michael'); // 95\n```\n\n初始化`Map`需要一个二维数组，或者直接初始化一个空`Map`。`Map`具有以下方法：\n\n```js\nvar m = new Map(); // 空Map\nm.set('Adam', 67); // 添加新的key-value\nm.set('Bob', 59);\nm.has('Adam'); // 是否存在key 'Adam': true\nm.get('Adam'); // 67\nm.delete('Adam'); // 删除key 'Adam'\nm.get('Adam'); // undefined\n```\n\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\n```js\nvar m = new Map();\nm.set('Adam', 67);\nm.set('Adam', 88);\nm.get('Adam'); // 88\n```\n","categories":["学习总结"],"tags":["js对象"]},{"title":"HTML5 标签大全","url":"/posts/15479/","content":"\nHTML5标签总结\n\n<!-- more -->\n\n本篇文章想梳理下HTML5 中的标签，下面就让我们开始吧。\n\n### HTML5 <!DOCTYPE>标签\n\n 这个标签是我们打开一个HTML文件看到的第一个标签，那它有什么作用吗？ 我们来看解释 <!DOCTYPE>是一种标准通用标记语言的文档类型声明，该声明很重要。通过该标签，浏览器能够了解HTML5文档正在使用HTML规范，它是起点，必须位于文档的第一行。如果少了，有些标签可能不支持了。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\"> \n<title>文档标题</title>\n</head> \n<body>\n文档内容......\n</body> \n</html>\n```\n\n### 简要介绍\n\n```html\n1、Web标准介绍\n    * web应用领域：\n        PC端\n        移动端\n    * 网页介绍\n        ** 组成：文字、图片、按钮、视频、音频。。。。这些元素组成\n        ** web标准：制作网页的规范\n            结构标准（HTML）\n            表现标准（CSS:美化网页）\n            行为标准(JavaScript：非常强大的语言)\n2、基本工具介绍\n    subline:\n        Ctrl+N,Ctrl+S\n        HTML文件：按住！+tab可以自动生成模板\n        快速复制：Ctrl+Shift+D或者p*10+tab\n        快速输入标签：div.(标签.)+tab\n        快速选中一行：Ctrl+N\n        查找替换：Ctrl+H\n\n3、HTML标签\n    * 单标签：\n        注释：<!--注释信息--> 快捷键：Ctrl+/\n        换行标签：<br>\n        横线标签：<hr>\n    * 双标签：\n        标题标签：<h1></h1>;<h2></h2>;<h3></h3>;<h4></h4>;<h5></h5>;<h6></h6>(从大到小)\n            注意：一个网页中1号标题标签最好出现一次\n        段落标签：<p></p>\n        强调标签：\n            文本标签:<font color=\"颜色属性\" size=\"大小\">改变属性</font>   \n            加粗标签:<strong>加粗</strong>或者<b>加粗</b>\n            文字斜体:<em>斜体</em>或者<i>斜体</i>\n            下划线:<ins>下划线</ins>或者<u>下划线</u>\n            删除线:<del>删除线</del>或者<s>删除线</s>\n        没有语义的双标签：\n                <div>实现网页布局</div> <!-- 自己独占一行（块元素），可以包含任何标签-->\n                <span>在网页布局过程中使用</span> <!-- 不会发生换行（行元素） -->\n\n    * 多媒体标签\n        图片标签:<img src=\"设置一个图片的路径\" title=\"显示鼠标悬停文字提示\" alt=\"图片显示不出来时，显示对图片的描述信息，并不是给用户看的，给搜索引擎提供搜索服务\" width=\"宽度(有一个宽高比，防止图片失真，改变一个属性就可以)\" height=\"高度\">\n    * 路径问题\n        绝对路径：\n            ** 带有磁盘目录的路径\n            ** 带有具体网址\n\n        相对路径：\n            ** 如果资源文件(img)和当前文件(html)文件在同一个文件夹中，只要写文件的名称即可\n            ** 如果资源文件(img)在当前文件的下一级目录:src='image/1.bmp'\n            ** 如果资源文件(img)在当前文件的上一级目录:src='../../image/1.bmp'\n    * 超链接\n        <a href=\"涉及到相对路径和绝对路径问题\" title=\"显示文字提示\">不跳转到任何页面写\"#\"</a>\n        <a href=\"#\" target=\"默认值'_self':在当前页面中显示跳转页面，'_blank':跳转到新的窗口中打开页面\">不跳转到任何页面</a>\n        超链接跳转页面的其他写法：在<head><base target=\"_blank\"></head>，跳转到新的窗口中（对当前页面的任何超链接都有效）\n\n    * 锚链接(超链接的另外一种用法，实现的是本页面的内部的跳转)\n        <a href=\"#\">跳转到顶部</a>\n        <a href=\"#ID值\">跳转到固定部分</a>\n    * 特殊符号\n        \"空格字符\": &nbsp:\n        \"<\": &lt;\n        \">\": &gt;\n        \"&\":&amp;\n        \"￥\":&yen;\n        \"版权\":&copy;\n        \"注册商标\":&reg;\n        \"摄氏度\":&deg;\n        \"正负号\":&plusmn;\n        \"乘号\":&times;\n        \"除号\":&divide;\n        \"平方2\":&sup2;\n        \"平方3\":&sup3;\n    * HTML5里面的标签(补充):\n        *  版本介绍;\n            html:4s+tab或者4t+tab或者xt=tab：产生不同的HTML版本，过渡版本和严格版本\n            过渡版本Transitional：可以包含所有的html元素(标签)和属性\n            严格版本strict：可以包含所有的html元素(标签)和属性，但是不包含已经废弃掉的标签，例如font、i和属性（align属性）\n\n        * 新标签：\n            <nav>导航标签</nav>\n            <section>区域</section>\n            <footer>底部</footer>\n            <aside>侧边栏</aside>\n            <article>文章</article>\n            <!-- 注意:以上的标签和div的用法一样，如果在IE浏览器中无法显示上面的标签，只需要CSS样式中动态的写一个相同名字的标签即可 -->\n            <!-- 视频标签 -->\n            <video src=\"movie.mp4\" controls=\"显示控制面板\" autoplay=\"自动播放\" loop=\"循环播放\"></video>\n            <video src=\"movie.mp4\" controls autoplay loop width=\"500\"></video>\n            <!-- 宽度高度只设置一个即可 -->\n            <!-- 多种视频格式 -->\n            <video controls >\n                <source src=\"movie.mp4\" type=\"\">\n                <source src=\"movie.mp3\" type=\"\">\n                <source src=\"movie.rmvb\" type=\"\">\n\n            </video>\n\n            <!-- 音频标签 -->\n            <audio src=\"See You Again.mp3\" controls autoplay loop></audio>\n            <audio src=\"See You Again.mp3\"></audio>\n\n\n\n```\n\n","categories":[],"tags":[]},{"title":"HTTP 是什么？","url":"/posts/8716/","content":"\nHTTP是客户端和服务端之间互动需要准守的其中一种协议。在日常上网过程中，用户通过浏览器浏览目标网站的操作，看起来就是进入目标网站的门户之后，想看哪里就点哪里，但是实际上客户端和服务端之间的数据互动都是通过一套标准来执行的。用旧时代的眼光来看就是网络节点两边统一使用了莫斯代码，所以两边之间的交流就没有了障碍。\n\n<!-- more -->\n\n**先来个更好的文章做参考：[HTTP协议超级详解](//www.cnblogs.com/an-wen/p/11180076.html)**\n\n# HTTP/1.1\n\nHTTP属于TCP/IP中的“顶层”应用层，这说明HTTP的包装是数据出发前的第一步。在这里不谈TCP相关连接过程，但是HTTP请求/响应都是要在连接之后的事；想看的话，可以看[TCP三次握手详解及释放连接过程](//www.cnblogs.com/kaleidoscope/p/9701117.html)。基本上HTTP就是请求和响应的模式，在服务方想理你客户方的情况下，你想要什么，她都会回应你。\n\nHTTP请求方法：\n- GET，一般请求的数据都是不需要处理的数据\n- HEAD，获取metadata，打个比方就是电脑上文件右键属性\n- POST，一般请求的数据都是需要处理的数据\n- PUT，像数据库的INSERT\n- DELETE，像数据库的DELETE\n- PATCH，像数据库的UPDATE\n- 还有TRACE、OPTIONS、CONNECT\n\nHTTP状态码：\n- 100及以上，普通的信息代码\n- 200及以上，请求成功被处理\n- 300及以上，请求被重定向了\n- 400及以上，这是客户方的错\n- 500及以上，这是服务方的错\n\n## HTTP请求/响应报文结构\n\n![HTTP请求报文结构](/gallery/http-request-format.png)*Image from: [HTTP协议超级详解](//www.cnblogs.com/an-wen/p/11180076.html)*\n\n![HTTP请求报文例子](/gallery/http-request-example.jpg)*Image from: [HTTP协议超级详解](//www.cnblogs.com/an-wen/p/11180076.html)*\n\n![HTTP响应报文结构](/gallery/http-response-format.png)*Image from: [HTTP协议超级详解](//www.cnblogs.com/an-wen/p/11180076.html)*\n\n![HTTP响应报文例子](/gallery/http-response-example.jpg)*Image from: [HTTP协议超级详解](//www.cnblogs.com/an-wen/p/11180076.html)*\n\n## 比较HTTP/1.1和HTTP/2\n\n- HTTP/2在一次TCP连接中可以同时发送多个请求，多行程减少了连接次数和响应的等待时间\n- HTTP/2压缩头部信息，包裹更小，运输更方便\n- HTTP/2使用二进制协议，不仅节省了不少分隔符和封箱胶带，还可以分成小份包装以数据流形式发送\n- HTTP/2允许服务端推送，一次请求把相关依赖的脚本也给客户端一起发来，很人性化\n\n# HTTPS\n\n在HTTP包装外再来个SSL/TLS加密包装，HTTPS有以下特点：\n\n1. 内容加密，传输过程中使用的密文\n2. 验证身份，找到对的服务端\n3. 保护数据完整性，防止传输过程中被动手脚\n\n基本上传输中的数据不易被动手脚。\n\n**_更多可以百度HTTP、HTTPS、TCP连接等。_**","categories":["网络"],"tags":["HTTP","HTTPS"]},{"title":"node.js 搭建服务器","url":"/posts/47877/","content":"\n# Nodejs搭建服务器及express编写接口\n\n<!-- more -->\n\n Nodejs用http模块搭建http服务器：\n\n```js\n//引入http模块\nvar http = require(\"http\");\nvar url = require('url');\n//设置主机名\nvar hostName = '192.168.1.7';\n//设置端口\nvar port = 8092;\n \n//创建服务\nvar server = http.createServer(function (req, res) {\n    var string = url.parse(req.url, true);\n    console.log(\"URL:\" + req.url + \"  \" + string.pathname);\n    res.setHeader('Access-Control-Allow-Origin', \"*\")\n    res.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n    res.setHeader('Content-Type', 'text/plain');\n    res.end(\"hello nodejs\");\n \n});\nserver.listen(port, hostName, function () {\n    console.log(`服务器运行在http://${hostName}:${port}`);\n});\n```\n\n效果如图所示\n\n![](/gallery/node-http-server.png)\n\n用Nodejs的express搭建http服务器：\n\n```js\nvar express = require('express')\nvar bodyParser = require('body-parser');\n//设置主机名\nvar hostName = '192.168.1.7';//172.50.4.113  192.168.1.130\n//设置端口\nvar port = 8092;//8086\nvar app = express();\nvar routes = express.Router();\n//设置路由访问路径和静态资源目录\napp.use(\"/a\", express.static('public'))\napp.use(\"/a\", routes);\n// app.use(express.static('./'));\nvar server = app.listen(port, hostName, (err) => {\n    if (err) {\n        console.log(err)\n    } else {\n        console.log(`服务开启成功【端口号:${port}】`)\n    }\n});\n```\n\n用express搭建GET请求接口：\n\n```js\n/**\n * express建立GET接口\n * http://192.168.1.7:8092/a/ab?name='name12'&pwd='123'\n */\nroutes.get('/ab', (req, res) => {\n    var string = url.parse(req.url, true);\n    //解析参数\n    var params = url.parse(req.url, true).query;\n    console.log(params)\n    var user = {};\n    user.name = params.name;\n    user.pwd = params.pwd;\n    var responseJson = { name: 'abc', pwd: '123' };\n    var response = { status: 2, data: user };\n    res.send(JSON.stringify(response));\n    console.log(\"URL:\" + req.url + \"  \" + string.pathname);\n    res.status(200).json(response);\n    //有数据返回用res.send();\n    //无数据返回用res.end();\n    // res.end(\"hello nodejs\");\n});\n```\n\n用express搭建POST请求接口：\n\n```js\n/**\n * express建立POST接口\n */\nroutes.post('/r', (req, res) => {\n    var string = url.parse(req.url, true);\n    console.log(\"URL:\" + req.url + \"  \" + string.pathname);\n    //解析参数\n    var params = req.body;\n    var user = {};\n    user.name = params.name;\n    user.pwd = params.pwd;\n    var response = { status: 1, data: user };\n    res.send(JSON.stringify(response));\n    res.send('post:' + string.pathname + \"  \" +\n        JSON.stringify(text));\n    res.end();\n    console.log(req.method);//post\n    console.log(req.body);//{ a: '3', b: '4', c: '5' }\n    // console.log(req.body.a); //3\n    // res.end(\"hello nodejs\");\n});\n```\n\n","categories":["node.js"],"tags":["搭建服务器"]},{"title":"Vue 知识点小结","url":"/posts/53151/","content":"\n\n\n<!-- more -->\n\n\n","categories":["Vue"],"tags":["总结"]},{"title":"面试学习计划","url":"/posts/64901/","content":"\n学习计划\n\n<!-- more -->\n\n​        随着时间的流逝，大三下期的生活已经过了半个月了，春招如火如荼的进行中。说实话还是有点慌的，身边的都开始在找实习了，希望现在开始努力准备不算太晚。\n\n​       在之前的学习中，接触的比较多，前端、后端都接触过。最后还是感觉前端比较有意思，希望想找一份前端实习的工作。\n\n​       计划分为以下三个阶段：第一阶段-快速入门基础知识，回顾知识。第二阶段-刷算法题目，可以尝试投递简历，看面试题目。第三阶段-更加深入了解前端方面的知识，积极投递简历，总结面试经验。\n\n​      \n","categories":["学习"],"tags":["面试准备"]},{"title":"leetcode 刷题之旅 01","url":"/posts/9594/","content":"\nJs中String自带栈的效果\n\n<!-- more -->\n\n题目如下：\n\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n\n \n\n示例：\n\n```html\n输入：\"abbaca\"\n输出：\"ca\"\n解释：\n例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\n```\n\n\n\n**提示：**\n\n1. `1 <= S.length <= 20000`\n2. `S` 仅由小写英文字母组成。\n\n\n\n解法：用栈可以解决，新加入的和栈顶的相比较，如果相同就出栈，不相同就进栈，当循环完后只要把栈里剩下的元素循环输出就行了。代码如下\n\n```js\n/**\n * @param {string} S\n * @return {string}\n */\nvar removeDuplicates = function(S) {\n   let obj = []\n   for(const ans of S) {\n       if(obj.length && obj[obj.length - 1] === ans) {\n           obj.pop()\n       }\n       else {\n           obj.push(ans)\n       }\n   }\n   return obj.join('')\n   \n};\n```\n\n\n\n题目链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/\n\n","categories":["算法刷题"],"tags":["栈"]},{"title":"TCP/IP 是什么？","url":"/posts/4785/","content":"\n**本文大半内容都不对，弃了弃了~**\n\n自计算机和互联网出现，大多数计算机都被用于上网、发邮件或者只是通过网路使用一下网络共享打印机。计算机网络[^1]可以连接各种功能不一样的电子设备，例如笔记本电脑、平板电脑、智能手机、服务器、打印机、扫描仪、路由器等设备。如果说以上设备连上网络后都算是“传统”节点，那在现在的物联网时代，各种计算机新品种就可以算作“非传统”节点了吧，毕竟现在能连网的设备真的是五花八门。再说征服王“互联网”现在真的可以说已经征服世界的情况下，计算机网络类型都可以分成5种：\n\n- PAN - 个人网络，一台电脑配打印机等设备\n- LAN - 局域网，一个路由器下的网络\n- WLAN - 无线局域网，一个无线路由器信号覆盖下的网络\n- MAN - 都市网，一个城市的网络\n- WAN - 广域网，一个省、国家或整个世界下的网络，比如互联网\n  \n\n在这么广阔的网络下，如果节点之间通讯只靠一个“节点ID”作为坐标来互动，那互动时所传输的数据恐怕是要迷路很久甚至有可能累死在路上。**TCP/IP**[^2]就包含了网络相关的标准规范。这个协议集合里的IP部分就很好的为迷路的数据指明了方向。\n\n<!-- more -->\n\n**先来个更好的文章做参考：[太厉害了，终于有人能把TCP/IP协议讲的明明白白了！](//developer.51cto.com/art/201906/597961.htm)，[TCP/UDP常见端口参考](//tool.oschina.net/commons?type=7)**\n\n网络上两个节点之间通讯需要3样东西来指路：\n- 节点在网络上的地址（IP地址）\n- 节点的名称（MAC地址）\n- 节点里应用或服务接收数据的端口（Port端口）\n\n# TCP/IP协议全家桶\n\n全家桶包含ARP, BGP, DHCP, DNS, FTP, HTTP, ICMP, IGMP, IP, TCP, Telnet, TFTP, UDP, WWW等。\n节点上的TCP/IP栈，需跟随所运行的网络应用的要求，从全家桶中选择合适的协议；不同的节点有可能会使用不一样的TCP/IP栈。\n\n## 网络体系结构OSI七层模型\n\n|      | 名称                 | 功能                                                 | TCP/IP协议族                              |\n| ---: | :------------------: | :--------------------------------------------------: | :--------------------------------------: |\n| 7    | 应用层(Applicaiton)   | 终端用户的接口支持：文件传输，电子邮件，文件服务，虚拟终端 | TFTP, HTTP, SNMP, FTP, SMTP, DNS, Telnet |\n| 6    | 表示层(Presentation)  | 数据格式化，代码转换，数据加密                          | N/A                                      |\n| 5    | 会话层(Session)       | 连接管理：解除或建立与别的节点的联系                    | N/A                                      |\n| 4    | 传输层(Transport)     | 端对端传输管理，提供端对端的接口                        | TCP, UDP                                 |\n| 3    | 网络层(Network)       | 端对端路由，为数据包选择路由                           | IP, ICMP, RIP, OSPF, BGP, IGMP           |\n| 2    | 数据链路层(Data Link) | 网络接入和架构管理，传输有地址的帧以及错误检测功能        | SLIP, CSLIP, PPP, ARP, RARP, MTU         |\n| 1    | 物理层(Physical)      | 比特流生成和接收，以二进制数据形式在物理媒体上传输数据    | ISO2110, IEEE802, IEEE802.2              |\n\n# IP协议\n\nIP协议理论上让每个网络不管大小都有一个唯一的IP地址（或称作“节点地址”），但事实上不是每个网络（小到一台电脑配一个打印机）都能独享世界唯一IP地址。讨论“不能独享世界唯一IP地址的情况下，数据到底怎么就不会迷路了？”的问题之前，我们要先认识IP地址的格式。\n\n## IPv4格式\n\nIPv4使用32-bit节点地址，分成4个8-bit部分，例如：\n\n`01110000.11011110.11100110.00001111`\n\n使用十进制的眼光来看这个节点地址就会变成这样：\n\n`112.222.230.15`\n\n每一个8-bit部分的最大值是255。\n一个IP地址包含有两组信息：网络ID和节点ID。\n\n网络ID分为3类：\n- A类\n  + IP地址范围：1.0.0.0 ~ 126.255.255.255\n  + A类网络ID为第1个8-bit部分\n  + 例子：`112.222.230.15`属于A类，网络ID为`112`，节点ID为`222.230.15`\n- B类\n  + IP地址范围：128.0.0.0 ~ 191.255.255.255\n  + B类网络ID为第1-2个8-bit部分\n  + 例子：`142.112.1.70`属于B类，网络ID为`142.112`，节点ID为`1.70`\n- C类\n  + IP地址范围：192.0.0.0 ~ 223.255.255.255\n  + C类网络ID为第1-3个8-bit部分\n  + 例子：`192.168.1.1`属于C类，网络ID为`192.168.1`，节点ID为`1`\n  其中以127开头的IP地址为“回环地址”，数据信息的发送者发出的数据流会原样送回发送者。\n  网络ID越大，处于该网络下的主机或节点越少。一般家庭用的路由器网络ID为`192.168.1`的情况下最多只能连接254个设备。\n\n## IPv6格式\n\nIPv6使用128-bit节点地址，分成8个4位数的八进制16-bit部分，例如：\n\n`2001:0000:5723:0000:0000:D14E:DBCA:0764`\n\n也可以缩写成这样：\n\n`2001:0:5723::D14E:DBCA:764`\n\n其他例子：\n\n`2001:0DA8:0000:0000:0001:0000:0000:0001` => `2001:DA8::1:0:0:1` OR `2001:DA8:0:0:1::1`\n`0:0:0:0:0:0:0:1` => `::1`\n`0:0:0:0:0:0:0:0` => `::`\n\n开头64-bit包含了网络和子网络的地址，后面64-bit是接口ID。因为IPv6地址是直接赋予接口的，所以一个主机可以有多个IPv6地址对应不同的网络连接。下图拆开开头64-bit网络地址：\n![IPv6 Prefix](/gallery/tcp-ip-ipv6-prefix.jpg)\n\n## 路由器\n\n路由器是能连接多个网络的设备。它们决定了数据的去向，但它们一般都不是数据的最终接收者。数据在传输过程中有可能经过多个跳板[^3]，一般这些数据跳的次数过多且还没到目的地的话就会累死在路上，造成的结果就是发送者得不到回应、响应超时或者收到路由甲回应的死亡信息。\n\n一个ID为`142.222`的网络例子：\n![Network 142.222.x.x](/gallery/tcp-ip-router-network.jpg)\n在这个网络中，所有的主机或节点都是必须要向路由器`142.222.9.255`发送他们的数据，这样数据才可以在这个网络中畅行或者从这个网络发出到更外面的网络；所以在这里路由器`142.222.9.255`被称为是默认网关。\n\n假如在以上网络中主机`142.222.12.27`要发送数据到服务器`112.111.72.56`，数据会先到路由器`142.222.9.255`，路由器会通过路由表查找数据的下个传送目标（随便一提，需要解析域名的情况下，找到一个IP记录丰富的DNS也能让你的数据少跳跳板，数据极低概率会累死在路上）。\n\n假如在以上B类网络基础上存在**子网络**：\n![Network 142.222.x.x with subnet](/gallery/tcp-ip-router-subnet.jpg)\n在子网络中主机`142.222.10.2`要发送数据到服务器`142.123.32.14`，数据会先到路由器`142.222.10.255`，再到外面网络的路由器`142.222.255.255`，再到更外面网络的路由器`142.255.255.255`；找到`142.255.255.255`的下级`142.123.255.255`，再到服务器`142.123.32.14`。当然，如果网络`142.123`底下也有子网络的话，就要通过网关`142.123.32.255`，之后才是服务器`142.123.32.14`。\n\n## MAC地址\n\nMAC地址一般说的就是网卡生产出来自带的12个十六进制数的ID，当然也可以通过软件生成一个随机的MAC地址，只要主机所在的网络路由器上的ARP表上没有就行。它能够在一个网络下确认主机发送者或接收者的身份。因为MAC地址都是厂家定的，对比IP地址，MAC地址就可以有唯一标识了，甚至一人手上说不定还能独享多个“唯一”。MAC地址例子如下：\n\n`00-0B-DB-45-A4-CC`\n\n前6个数代表制造商：`00-0B-DB`\n后6个数为唯一编号：`45-A4-CC`\n\n## ARP协议\n\nARP协议让路由器记录下哪个IP地址对应哪个MAC地址。因为IP地址多数为动态，一个设备说不定某天就移民了，所以路由器一般都有一个ARP表记录和分配IP地址给底下的子民；要是有的子民刚移民过来没有记录在案，在有数据传送过来路由找不到人的情况下会发广播，以这样的操作令底下子民回应，之后强制记录在案。\n\n**_更多可以百度TCP/IP全家桶各种协议，比较重要的还有数据包结构、DHCP[^4]和DNS[^5]。_**\n\n[^1]: 通过软硬件技术支持允许多台计算机之间交流和共享资源\n[^2]: 目前主流的网络相关协议集合，包括应用层、传输层、网络层和网络接口层\n[^3]: 数据在传输过程中经过的路由器\n[^4]: 为网关节点管理下的主机进行动态IP地址的分配；有效防止人工操作的失误；有主机被迁移或更替的情况下能够自动更新配置\n[^5]: 域名服务器能够帮助解析域名到对应IP地址","categories":["网络"],"tags":["TCP/IP","MAC","IPv6","IPv4"]},{"title":"网易云音乐歌单 JS 音乐播放器 JS 代码","url":"/posts/12019/","content":"\n![JS音乐播放器截图](/gallery/yaoplayer-0.jpg)\n网易云音乐歌单JS音乐播放器JS代码\n感谢[MessAPI](//github.com/messoer/mess-api-doc)提供的网易云音乐API\n代码依赖jQuery和fontawesome\n<!-- more -->\n\n## 使用方法\n\n``` JavaScript\n$.get('https://v1.itooi.cn/netease/songList', {\n\t'id': 998389130 // 此处歌单ID\n}, function(json){\n\tif (json.data != undefined && json.data != null &&\n\t\tjson.data.tracks != undefined && json.data.tracks != null) {\n\t\t$('body').append(new YaoPlayer('YaoPlayer', json.data.tracks.map(song => {\n      return {\n        'name': song.name,\n        'singer': song.artists.map(artist => artist.name).join(', '),\n        'lrc': 'Not found',\n        'pic': song.album.picUrl,\n        'url': `https://v1.itooi.cn/netease/url?id=${song.id}&quality=128`\n      };\n    })));\n\t}\n}, 'json');\n```\n\n## 插件全代码\n\n{% include_code lang:javascript from:1 to:59 yaoplayer.js %}","categories":["Blog","Plugin"],"tags":["音乐播放器","JavaScript"]}]